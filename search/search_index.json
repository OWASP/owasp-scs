{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Grant Support \u00b7 2025 Supported by Ethereum Foundation's Ecosystem Support Program (ESP) Read more\u2026","tags":[]},{"location":"#owasp-smart-contract-security","title":"OWASP Smart Contract Security","text":"","tags":[]},{"location":"#our-mission","title":"Our MissionOWASP SCSVSOWASP SCWEOWASP SCSTGOWASP SCS Checklist","text":"\"Define the industry standard for Smart Contract Security.\" <p>The OWASP Smart Contracts Security (SCS) is a comprehensive project aimed at enhancing the security of smart contracts. It provides a structured framework for developers, auditors, and security professionals to follow best practices, detect vulnerabilities, and implement robust security measures in smart contracts, decentralized applications (dApps) and EVM-based blockchain systems.</p>  Download the SCSVS  Access v1.0  Download the SCSTG  Visit the Checklist <p></p>","tags":[]},{"location":"#trusted-by","title":"Trusted By","text":"<p>The OWASP SCSVS and SCSTG are trusted by the following platform providers and standardization, governmental and educational institutions. Learn more.</p>","tags":[]},{"location":"#scs-advocates","title":"\ud83e\udd47 SCS Advocates","text":"<p>SCS Advocates are key industry adopters of the OWASP SCSVS and SCSTG who have invested a significant and consistent amount of resources to drive the project forward and ensure its continued success. This includes making consistent high-impact contributions and actively promoting the adoption and usage of the project. Learn more.</p> <p></p>","tags":[]},{"location":"contact/","title":"\ud83d\udcac Connect with Us","text":"<p>You can follow and reach out to the OWASP SCS team in many ways.</p> <ul> <li>Send us your questions and ideas to GitHub Discussions</li> <li>Stay always up-to-date by following us on Twitter.</li> <li>Join our Slack community</li> </ul> <p>If you'd like to contribute, take a look at our Contributions page or reach out to the project leaders or project maintainers mentioned below.</p> <p> </p> <p>Request an invitation to join our Slack channel <code>#owasp-scs</code></p> <p></p>","tags":[]},{"location":"contact/#owasp-scs-project-leaders","title":"OWASP SCS Project Leaders","text":"","tags":[]},{"location":"contact/#shashank","title":"Shashank","text":"<p>@cyberboyIndia </p> <p>Shashank brings over a decade of expertise in uncovering vulnerabilities, reporting them to reputable institutions, conducting pentests, and overseeing responsible disclosure and bug bounty initiatives. His contributions have earned him a place in the Security Hall of Fame for Apple (CVE-2017-7063, CVE-2017-7062, CVE-2017-2458), Twitter, Google, Facebook, Dropbox, and more than 40 other organizations, showcasing his knack for identifying significant security concerns. Apart from Bug Bounties, Shashank has worked as a security analyst for HackerOne and performed 200+ pentests with Cobalt. He was also a security engineer for Web3 Company Avalanche before starting his venture CredShields where he is building an AI-powered cloud-based Smart Contract Security Scanner called SolidityScan.com</p> <p> </p> <p></p>","tags":[]},{"location":"contact/#owasp-scs-project-maintainers","title":"OWASP SCS Project Maintainers","text":"","tags":[]},{"location":"contact/#pratik-lagaskar","title":"Pratik Lagaskar","text":"<p>@warlordsam077</p> <p> </p> <p>Pratik is a Security Researcher at CredShields, focused on postmortems of web3 rekts, TX analysis &amp; OSINT, tokenomics, and research into web3 security. Previously, Pratik has worked in traditional security with expertise in Red Teaming, code reviews (with proficiency in linters, fuzzers, CodeQL, Semgrep, CxQL), DevSecOps, hypervisor and browser security. He also holds various web2 security certifications. Pratik is very active in all types of CTFs, a major contributor to GSoC and OWASP; and has also won multiple hackathons. He has in-depth working experience with Go, Rust and good understanding of Solidity and Move. Currently, he is dabbling with web3sec and expanding his knowledge in EVM internals, various DeFi protocols, altchains (Cosmos, Solana), node reviews, hash-based snargs and Formal Verification (CVL, Coq and Dafny). When he is not working, Pratik spends majority of his free time strengthening audit skills by participating in contests and bug bounties. </p> <p> </p> <p></p>","tags":[]},{"location":"contact/#nehal-pillai","title":"Nehal Pillai","text":"<p>@nehal_10_0</p> <p></p> <p>Nehal is a Security Engineer at FINRA, with a strong foundation in offensive and application security. He previously worked as a Security Researcher at CredShields and holds a Master\u2019s degree in Cybersecurity from the University of Maryland, College Park. At CredShields, he has been a part of the team developing SolidityScan, an AI-powered cloud-based Smart Contract Security Scanner, driving innovation in smart contract security. With a deep passion for ethical hacking and as an OSCP-certified professional, Nehal specializes in uncovering vulnerabilities, conducting penetration tests, and securing digital assets. As a bug bounty hunter, Nehal has secured over 100 prominent companies through platforms like HackerOne, including major players like Apple and Google. He proudly represented India at the BlackHat MEA 2022 CTF World Finals, showcasing his expertise on a global stage.In addition, Nehal has identified over 35 vulnerabilities, which have been assigned CVEs and registered under MITRE and NIST NVD, making significant contributions to the cybersecurity community.</p> <p> </p> <p></p>","tags":[]},{"location":"contributing/","title":"Contributing to the SCS Project","text":"<p>First of all, \u2b50 Give us a Star in GitHub!</p> <p></p> <p></p> <p>The SCS project is an open source effort and we welcome all kinds of contributions and feedback.</p> <p>Help us improve &amp; join our community:</p> <ul> <li>\ud83d\udc1e Report an error (typos, grammar) or fix it on a Pull Request.</li> <li>\ud83d\udcac Give feedback (SCSTG/SCSVS).</li> <li>\ud83d\ude4f Ask questions (SCSTG/SCSVS).</li> </ul> <p>Contribute with content:</p> <ul> <li>\ud83d\udca1 Propose ideas or suggest improvements (SCSTG/SCSVS). If it qualifies we'll promote it to an Issue.</li> <li>\ud83d\udcc4 Create a Pull Request for concrete fixes (e.g. grammar/typos) or content already approved by the core team.</li> </ul> <p>Before you start contributing, please check our pages \"How Can You Contribute?\" and \"Getting Started\". If you have any doubts please contact us.</p>","tags":[]},{"location":"contributing/#what-not-to-do","title":"\ud83d\udeab What not to do","text":"<p>Although we greatly appreciate any and all contributions to the project, there are a few things that you should take into consideration:</p> <ul> <li>No advertisement: The OWASP Smart Contract Security Project cannot be used as a platform for advertisement of commercial tools, companies or individuals. Technical content such as the implementation of certain techniques or tests should be written with free and open-source tools in mind. Commercial tools are typically not accepted, but might be referenced in some specific cases.</li> <li>No unnecessary self-promotion of tools or blog posts: If you have a relation with one of the URLs or tools you are referencing, please state so in the PR so that we can verify that the reference is in line with the rest of the guide.</li> </ul> <p>Please be sure to take a careful look at our Code of Conduct for all the details and ask us in case of doubt.</p> <p></p>","tags":[]},{"location":"contributing/#our-contributors","title":"Our Contributors","text":"<p>All of our contributors are listed in GitHub repos. See OWASP SCS Authors &amp; Co-Authors, SCSTG Contributors and SCSVS Contributors.</p> <p></p>","tags":[]},{"location":"contributing/#owasp-scs-project-featured-contributions","title":"OWASP SCS Project Featured Contributions","text":"<ul> <li>Pratik Lagaskar (Automation in GitHub Actions)</li> </ul>","tags":[]},{"location":"contributing/#owasp-scsvs","title":"OWASP SCSVS","text":"<p>The latest version of the SCSVS v1 including all translations is available here: https://github.com/OWASP/www-project-smart-contract-security-verification-standard/releases/tag/v0.0.1</p> <p>Note: This contributor table is generated based on our GitHub contribution statistics. For more information on these stats, see the GitHub Repository README. We manually update the table, so be patient if you're not listed immediately.</p> Project Lead Lead Author Contributors and Reviewers Shashank Pratik Lagaskar,  Nehal Pillai <p></p> Language Translators &amp; Reviewers","tags":[]},{"location":"contributing/#owasp-scstg","title":"OWASP SCSTG","text":"<p>The latest version of the SCSTG v1.0 is available here: https://github.com/OWASP/www-project-smart-contract-security-testing-guide/releases/tag/v0.0.1</p> <p>Note: This contributor table is generated based on our GitHub contribution statistics. For more information on these stats, see the GitHub Repository README. We manually update the table, so be patient if you're not listed immediately.</p> <ul> <li>Reviewers: Reviewers have consistently provided useful feedback through GitHub issues and pull request comments.</li> <li>Top Contributors: Top contributors have consistently contributed quality content and have at least 500 additions logged in the GitHub repository.</li> <li>Contributors: Contributors have contributed quality content and have at least 50 additions logged in the GitHub repository.</li> <li>Mini Contributors: Many other contributors have committed small amounts of content, such as a single word or sentence (less than 50 additions).</li> </ul> Authors Reviewers Top Contributors Contributors Mini Contributors Editors Shashank Pratik Lagaskar Nehal Pillai","tags":[]},{"location":"donate/","title":"Donations","text":"<p>We thank our donators for providing the funds to support us on our project activities.</p> <p>The OWASP Foundation is very grateful for the support by the individuals and organizations listed. However please note, the OWASP Foundation is strictly vendor neutral and does not endorse any of its supporters. Donations do not influence the content of the SCSVS or SCSTG in any way.</p> <p> </p> <p>While both the SCSVS and the SCSTG are created and maintained by the community on a voluntary basis, sometimes a little bit of outside help is required.</p> <p>Monetary Donations: You can donate any amount you like, no matter how small, anyone can help. From 500$ up you may select a Donation Package and be listed as a donator.</p> <p>100% of the funds go to the OWASP Foundation and allow us funding our project activities such as contracting technical editors, graphic designers, software developers, purchasing test devices, creating swag, etc.</p> <p> \ud83e\udd0d Donate   Purchase the SCSTG </p> <p>Effort Based: You can instead support the project by contributing with your work and end up at our acknowledgement section.</p> <p>If you're a company, consider becoming a \"SCS Advocate\" which is the highest status that companies can achieve in the project acknowledging that they've gone above and beyond to support the project.</p> <p>  Contribute   Become a SCS Advocate </p>","tags":[]},{"location":"tags/","title":"Tags","text":"","tags":[]},{"location":"talks/","title":"\ud83c\udf99 Talks","text":"Date Event Title Video Slides 18th March 2025 Podcast OWASP Smart Contract Top 10 Podcast  Video  Slides","tags":[]},{"location":"SCSTG/","title":"OWASP SCSTG","text":"<p> GitHub Repo</p> <p> OWASP Project Page</p> <p>The OWASP Smart Contract Security Testing Guide (SCSTG) is a comprehensive manual designed to assist developers, auditors, and security professionals in evaluating the security of smart contracts. It provides detailed methodologies for identifying, verifying, and addressing vulnerabilities in smart contracts across various risk categories. The guide includes examples of common security flaws, methods for detecting these issues, and strategies for mitigating or eliminating the risks. </p> <p>It describes technical processes for verifying the controls listed in the OWASP SCSVS through the weaknesses defined by the OWASP SCWE.</p> <p></p> <p> Download the SCSTG</p> <p></p> <p>Start exploring the SCSTG:</p> <p>  Tests (v1)</p> <p>  Support the project by purchasing the OWASP SCSTG on leanpub.com. All funds raised through sales of this book go directly into the project budget and will be used to for technical editing and designing the book and fund production of future releases.</p> <p></p>","tags":[]},{"location":"SCSTG/0x01-Foreword/","title":"Foreword","text":"<p>Welcome to the OWASP Smart Contract Security Testing Guide. Feel free to explore the existing content, but do note that it may change at any time. </p> <p>This guide is a community-driven effort to provide a comprehensive resource for understanding, testing, and improving the security of smart contracts. Like the blockchain space itself, the content in this guide is dynamic and ever-evolving, reflecting the fast-paced advancements in protocols, best practices, and the discovery of new vulnerabilities.  </p> <p>Smart contracts are at the heart of decentralized ecosystems, but their complexity makes them a prime target for attacks. With every protocol upgrade, L2 innovation, or emerging standard, new challenges arise for developers and security professionals alike. This guide aims to bridge the gap, equipping you with practical techniques and insights to navigate the ever-changing landscape of smart contract security.  </p> <p>If you have feedback, suggestions, or would like to contribute, feel free to create an issue on GitHub or join the discussion on OWASP\u2019s Slack. See the README for details:  </p> <p>https://www.github.com/OWASP/www-project-smart-contract-security-testing-guide/ </p> <p>smart contract (noun): A self-executing contract with the terms of the agreement directly written into lines of code, enabling secure, automated transactions on a blockchain. </p> <p>This isn\u2019t a traditional security guide. It doesn\u2019t just explain vulnerabilities or list best practices. It\u2019s a living document shaped by the community for the community. Security testing in Web3 demands a deep understanding of blockchain fundamentals, cryptographic principles, protocol designs, and attack vectors\u2014many of which are only briefly introduced here.  </p> <p>So, don\u2019t stop at this guide. Read the code, explore the EVM, experiment with testnets, audit real-world projects, and stay curious. As you grow in your journey, consider giving back to the SCSTG. After all, the strength of this guide lies in the collective expertise of its contributors. Or, as they say in the open-source world: \"Do a pull request.\" </p> <p>We hope this guide inspires you to push the boundaries of what\u2019s possible in securing decentralized systems. Welcome aboard!  </p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/","title":"Frontispiece","text":"","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#about-the-owasp-scstg","title":"About the OWASP SCSTG","text":"<p>The OWASP Smart Contract Security Testing Guide (SCSTG), which is part of the OWASP Smart Contract Security (SCS) flagship project, is a comprehensive manual covering the processes, techniques, and tools used during smart contract security analysis, as well as an exhaustive set of test cases for verifying the requirements listed in the OWASP Smart Contract Verification Standard (SCSVS), providing a baseline for complete and consistent security tests.</p> <p>The OWASP SCSVS and SCSTG are trusted by the following platform providers and standardization, governmental and educational institutions. Learn more.</p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#authors","title":"Authors","text":"","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#changelog","title":"Changelog","text":"<p>All our Changelogs are available online at the OWASP SCSTG GitHub repository, see the Releases page:</p> <p>https://github.com/OWASP/www-project-smart-contract-security-testing-guide/releases</p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#disclaimer","title":"Disclaimer","text":"<p>Please consult the laws in your country before executing any tests against smart contracts by utilizing the SCSTG materials. Refrain from violating the laws with anything described in the SCSTG.</p> <p>Our [Code of Conduct] has further details: https://github.com/OWASP/www-project-smart-contract-security-testing-guide/blob/master/.github/CODE_OF_CONDUCT.md</p> <p>OWASP thanks the many authors, reviewers, and editors for their hard work in developing this guide. If you have any comments or suggestions, please connect with us: https://scs.owasp.org/contact</p> <p>If you find any inconsistencies or typos please open an issue in the OWASP SCSTG Github Repo: https://github.com/OWASP/www-project-smart-contract-security-testing-guide</p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#copyright-and-license","title":"Copyright and License","text":"<p>Copyright \u00a9 The OWASP Foundation. This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. For any reuse or distribution, you must make clear to others the license terms of this work.</p> <p></p>","tags":[]},{"location":"SCSTG/0x02b-SCSVS-SCSTG-Adoption/","title":"OWASP SCSVS and SCSTG Adoption","text":"<p>The OWASP SCSVS and SCSTG are trusted by the following platform providers and standardization, governmental and educational institutions.</p> <ul> <li>SolidityScan.com</li> </ul> <p></p> <ul> <li>Would you like to contribute with your case study? Connect with us!</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/","title":"Acknowledgments","text":"","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#contributors","title":"Contributors","text":"<p>All of our contributors are listed in the Contributing section of the OWASP SCS website:</p> <p>https://scs.owasp.org/contributing/</p>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#scs-advocates","title":"\ud83e\udd47 SCS Advocates","text":"<p>SCS Advocates are industry supporters of the OWASP SCSVS and SCSTG who have invested a significant and consistent amount of resources to push the project forward by providing consistent high-impact contributions and continuously spreading the word.</p> <p>\ud83e\udd47 Being a \"SCS Advocate\" is the highest status that companies can achieve in the project, acknowledging that they've gone above and beyond to support the project.</p> <p>SCS Advocates continuously support the project with time/dedicated resources with clear/high impact. To achieve this status, you'll need to demonstrate that you make consistent high-impact contributions to the project. For example:</p> <ul> <li>Content Pull Requests (e.g. adding/updating existing tests, tooling, maintaining code samples, etc.)</li> <li>Technical PR reviews</li> <li>Improving automation (GitHub Actions)</li> <li>Upgrading, extending or creating new Crackmes</li> <li>Moderating GitHub Discussions</li> <li>Providing high quality feedback to the project and for special events such as the SCSVS/SCSTG refactoring.</li> <li>etc.</li> </ul> <p>The following will be considered but it's not a requirement:</p> <ul> <li>Showing Adoption: it should be clear just from looking at the official company page that they have adopted the OWASP SCSVS and SCSTG. For example:<ul> <li>Services/products</li> <li>Resources (e.g. blog posts, press releases, public pentest reports)</li> <li>Trainings</li> <li>etc.</li> </ul> </li> <li>Spreading the word and promoting the project with many presentations each year, public trainings, high social media involvement (e.g. liking, re-sharing, doing own posting specifically to promote the project).</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#benefits","title":"\ud83c\udf81 Benefits","text":"<ul> <li>Company logo displayed in our main READMEs and main OWASP project site.</li> <li>Linked blog posts in the SCSTG will include the company name.</li> <li>Special acknowledgement on each SCSTG release containing the contributed PRs.</li> <li>Re-shares from the OWASP SCS accounts on new publications (e.g. retweets).</li> <li>Initial public \"Thank You\" and yearly after successful renewal.</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#how-to-apply","title":"\ud83d\udcdd How to Apply","text":"<p>If you'd like to apply please contact the project leaders by sending an email. Please be sure to include sufficient evidence (e.g including links to PRs) showing what you've done in the 6 months period that goes inline with the three categories described above:</p> <ul> <li>Make consistent high-impact contributions</li> <li>Showing Adoption</li> <li>Spreading the word</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#important-disclaimers","title":"\u2757 Important Disclaimers","text":"<ul> <li>If the \"SCS Advocate\" status is granted and you'd like to maintain it, the aforementioned contributions must remain consistent after the initial period as well. You should keep collecting this evidence and send us a contribution report yearly.</li> <li>Financial donations are not part of the eligibility criteria but will be listed for completion.</li> <li>Re-shared publications and blog posts linked in SCSTG text must be educational and focus on smart contract security or SCSVS/SCSTG and not endorse company products/services.</li> <li>Advocate Companies may use the logo and links to SCSVS/SCSTG resources as part of their communication but cannot use them as an endorsement by OWASP as a preferred provider of software and services.<ul> <li>Example of what's ok: list SCS Advocate status on website home page, in \"about company\" slides in sales presentations, on sales collateral.</li> <li>Example of what's not ok: a SCS Advocate cannot claim they are OWASP certified.</li> </ul> </li> <li>The quality of the application of the SCSVS/SCSTG by these companies has not been vetted by the SCS team.</li> </ul> <p>The OWASP Foundation is very grateful for the support by the individuals and organizations listed. However please note, the OWASP Foundation is strictly vendor neutral and does not endorse any of its supporters. SCS Advocates do not influence the content of the SCSVS or SCSTG in any way.</p>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#our-scs-advocates","title":"Our SCS Advocates","text":"<p>CredShields has provided consistent high-impact contributions to the project and has successfully helped spread the word.</p> <p>We'd like to thank CredShields for its exemplary contribution which sets a blueprint for other potential contributors wanting to push the project forward.</p>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#donators","title":"Donators","text":"<p>While both the SCSVS and the SCSTG are created and maintained by the community on a voluntary basis, sometimes a little bit of outside help is required. We therefore thank our donators for providing the funds to be able to hire technical editors. Note that their donation does not influence the content of the SCSVS or SCSTG in any way. The Donation Packages are described on our OWASP Project page.</p>","tags":[]},{"location":"SCSTG/0x03-Overview/","title":"Introduction to the OWASP Smart Contract Security Project","text":"<p>The rise of smart contracts has revolutionized the way agreements are executed, creating unprecedented opportunities for automation and decentralization. However, these innovations also introduce new security challenges. Ensuring the security of smart contracts is critical, as vulnerabilities can lead to significant financial and reputational losses. The OWASP Smart Contract Security Verification Standard (SCSVS) and Smart Contract Security Testing Guide (SCSTG) have been developed to help developers, auditors, and organizations address these challenges effectively.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#how-to-use-the-smart-contract-security-project","title":"How to Use the Smart Contract Security Project","text":"<p>The OWASP Smart Contract Security Project provides a structured approach to evaluating and improving the security of smart contracts. It begins with the OWASP Smart Contract Security Verification Standard (SCSVS), which outlines a comprehensive security model and provides a set of security requirements for smart contracts. These requirements are designed to be used across the entire development lifecycle, serving architects, developers, testers, and security professionals.  </p> <p>Once the SCSVS requirements have been identified for your use case, the next step is to apply the OWASP Smart Contract Security Testing Guide (SCSTG). The SCSTG maps directly to the SCSVS requirements, offering practical testing methodologies and techniques. Together, these resources form a robust framework for smart contract security.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#whats-covered-in-the-smart-contract-security-guide","title":"What's Covered in the Smart Contract Security Guide","text":"<p>This guide focuses on the security aspects of smart contracts deployed on blockchain platforms. While blockchain ecosystems vary significantly, the testing principles and techniques outlined in this guide can be applied broadly, with adjustments made for specific platforms or use cases.  </p> <p>The OWASP Smart Contract Security Project addresses the following key areas of concern:  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-arch-architecture-design-and-threat-modeling","title":"SCSVS-ARCH: Architecture, Design, and Threat Modeling","text":"<p>Secure smart contract systems start with a well-thought-out architecture. This involves threat modeling, identifying attack surfaces, and designing systems to minimize risk. Ensuring modularity and adopting principles like least privilege are crucial steps in this process.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-code-policies-procedures-and-code-management","title":"SCSVS-CODE: Policies, Procedures, and Code Management","text":"<p>Effective governance ensures that smart contract development follows secure coding practices, utilizes peer review processes, and adheres to proper code versioning and management procedures. Policies should also address incident response and vulnerability disclosure.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-gov-business-logic-and-economic-security","title":"SCSVS-GOV: Business Logic and Economic Security","text":"<p>Business logic vulnerabilities often stem from poorly defined economic models or flaws in their implementation. Ensuring that the contract\u2019s logic aligns with its intended purpose and testing for edge cases are essential.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-auth-access-control-and-authentication","title":"SCSVS-AUTH: Access Control and Authentication","text":"<p>Smart contracts must implement robust access control mechanisms to prevent unauthorized actions. This includes enforcing role-based permissions and ensuring authentication mechanisms are secure against attacks such as replay or signature forgery.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-comm-secure-interactions-and-communications","title":"SCSVS-COMM: Secure Interactions and Communications","text":"<p>Securely interacting with other contracts, off-chain systems, oracles, and external data sources is critical. Avoiding trust assumptions and ensuring proper validation of inputs and responses are key.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-crypto-cryptographic-practices","title":"SCSVS-CRYPTO: Cryptographic Practices","text":"<p>Smart contracts rely heavily on cryptography for secure communication, authentication, and data protection. Ensuring the correct implementation of cryptographic primitives, using secure random number generation, and avoiding deprecated libraries are essential.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-oracle-arithmetic-and-logic-security","title":"SCSVS-ORACLE: Arithmetic and Logic Security","text":"<p>Incorrect arithmetic operations and faulty logical implementations can lead to vulnerabilities, such as integer overflows or underflows. Ensuring precision in calculations and using safe math libraries are vital for security.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-block-denial-of-service-dos","title":"SCSVS-BLOCK: Denial of Service (DoS)","text":"<p>Smart contracts should be resilient to DoS attacks, ensuring that their functionality remains accessible even under adversarial conditions. This includes proper gas usage and avoiding reentrancy vulnerabilities.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-bridge-blockchain-data-and-state-management","title":"SCSVS-BRIDGE: Blockchain Data and State Management","text":"<p>Efficiently managing blockchain state and ensuring consistency in data storage and retrieval are crucial to avoid vulnerabilities related to data integrity or unexpected state changes. </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-defi-gas-usage-efficiency-and-limitations","title":"SCSVS-DEFI: Gas Usage, Efficiency, and Limitations","text":"<p>Gas optimization is critical in smart contract development. Inefficient code can lead to excessive costs or failed transactions. Ensuring that gas usage is minimized and falls within platform limits is a priority.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-comp-component-specific-security","title":"SCSVS-COMP: Component-Specific Security","text":"<p>Different components of a smart contract system, such as token standards (ERC-20, ERC-721) or multi-signature wallets, have unique security requirements. This guide provides recommendations tailored to specific components.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#navigating-the-owasp-scstg","title":"Navigating the OWASP SCSTG","text":"<p>The SCSTG offers practical testing methodologies for each of the SCSVS areas, allowing users to methodically evaluate and secure their smart contracts. It is organized into:  </p> <ol> <li>General Testing Guide: Covers testing techniques that apply across all EVM-based blockchains' smart contracts, including secure coding practices, network communication, and cryptographic implementations.  </li> <li>Platform-Specific Testing: Addresses unique considerations for EVM-Based Blockcahins.  </li> </ol>","tags":[]},{"location":"SCSTG/0x03-Overview/#how-security-professionals-can-use-the-guide","title":"How Security Professionals Can Use the Guide","text":"<p>Smart contract auditors and security testers can use the SCSVS as a baseline for evaluations and the SCSTG for actionable testing strategies. By combining these resources with platform-specific knowledge, they can identify vulnerabilities, suggest remediations, and contribute to the overall security of blockchain ecosystems.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#owasp-scsvs-overview-key-areas-in-smart-contract-security","title":"OWASP SCSVS Overview: Key Areas in Smart Contract Security","text":"<p>The following sections provide an overview of the SCSVS categories and their relevance to smart contract security.  </p> <ul> <li>OWASP Smart Contract Security Verification Standard </li> </ul> <p>We encourage you to dive into the guide, experiment with its methodologies, and contribute to its ongoing evolution. Together, we can make the blockchain ecosystem more secure for everyone.  </p>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/","title":"Smart Contract Taxonomy","text":"<p>This taxonomy provides a structured framework for understanding and categorizing smart contracts, specifically focusing on EVM-based blockchains and Solidity. It is intended to aid developers, auditors, and researchers in identifying key areas of functionality, associated risks, and best practices for secure development.  </p>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#1-token-contracts","title":"1. Token Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-erc-20-erc-721-erc-1155","title":"Examples: ERC-20, ERC-721, ERC-1155","text":"<ul> <li>Description:   Smart contracts representing fungible, non-fungible, or semi-fungible tokens.  </li> <li>Use Cases:  </li> <li>Cryptocurrencies and stablecoins (ERC-20).  </li> <li>NFTs for digital ownership and collectibles (ERC-721).  </li> <li>Multi-token standards (ERC-1155).  </li> <li>Key Risks:  </li> <li>Incorrect implementation of token standards.  </li> <li>Integer overflows/underflows.  </li> <li>Lack of proper access control on minting or burning functions.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#2-crowdfunding-and-fundraising-contracts","title":"2. Crowdfunding and Fundraising Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-icos-idos-ieos","title":"Examples: ICOs, IDOs, IEOs","text":"<ul> <li>Description:   Contracts that facilitate the collection of funds in exchange for tokens or other benefits.  </li> <li>Use Cases:  </li> <li>Initial Coin Offerings (ICOs).  </li> <li>Decentralized fundraising on platforms like Uniswap or Balancer.  </li> <li>Key Risks:  </li> <li>Rug-pulls or misappropriation of funds.  </li> <li>Vulnerabilities in refund mechanisms.  </li> <li>Failing to secure investor funds in escrow.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#3-governance-contracts","title":"3. Governance Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-daos-voting-mechanisms","title":"Examples: DAOs, voting mechanisms","text":"<ul> <li>Description:   Contracts enabling decentralized governance and decision-making processes.  </li> <li>Use Cases:  </li> <li>Token-based voting systems for DAOs.  </li> <li>Community-driven proposals and execution mechanisms.  </li> <li>Key Risks:  </li> <li>Voting manipulation (e.g., Sybil attacks).  </li> <li>Flawed quorum or proposal execution logic.  </li> <li>Lack of on-chain transparency in decision-making.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#4-defi-protocols","title":"4. DeFi Protocols","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-amms-lending-yield-aggregators","title":"Examples: AMMs, Lending, Yield Aggregators","text":"<ul> <li>Description:   Financial services provided via smart contracts without intermediaries.  </li> <li>Use Cases:  </li> <li>Automated Market Makers (e.g., Uniswap, SushiSwap).  </li> <li>Decentralized lending/borrowing platforms (e.g., Aave, Compound).  </li> <li>Yield farming and liquidity mining (e.g., Yearn Finance).  </li> <li>Key Risks:  </li> <li>Impermanent loss in AMMs.  </li> <li>Exploitable liquidation mechanics in lending platforms.  </li> <li>Flash loan-based attacks on arbitrage opportunities.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#5-oracle-contracts","title":"5. Oracle Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-chainlink-tellor","title":"Examples: Chainlink, Tellor","text":"<ul> <li>Description:   Contracts fetching off-chain data to use in on-chain operations.  </li> <li>Use Cases:  </li> <li>Price feeds for DeFi protocols.  </li> <li>Real-world event triggers for smart contracts.  </li> <li>Key Risks:  </li> <li>Price manipulation attacks.  </li> <li>Delayed or incorrect data delivery.  </li> <li>Centralization risks in oracle mechanisms.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#6-escrow-and-payment-contracts","title":"6. Escrow and Payment Contracts","text":"<ul> <li>Description:   Contracts managing funds between parties, releasing them based on predefined conditions.  </li> <li>Use Cases:  </li> <li>Secure peer-to-peer transactions.  </li> <li>Conditional payments for services or goods.  </li> <li>Key Risks:  </li> <li>Logic errors leading to incorrect fund releases.  </li> <li>Lack of multi-sig protection in disputes.  </li> <li>Malicious actors exploiting refund or lockup conditions.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#7-lottery-and-gambling-contracts","title":"7. Lottery and Gambling Contracts","text":"<ul> <li>Description:   Contracts providing randomness-based services, such as lotteries or casino games.  </li> <li>Use Cases:  </li> <li>Decentralized lotteries.  </li> <li>On-chain games of chance.  </li> <li>Key Risks:  </li> <li>Manipulation of randomness sources (e.g., block hashes).  </li> <li>Front-running attacks in prize distributions.  </li> <li>Regulatory compliance issues.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#8-identity-and-access-management","title":"8. Identity and Access Management","text":"<ul> <li>Description:   Contracts that verify user identities and manage access control.  </li> <li>Use Cases:  </li> <li>Decentralized identity solutions (DID).  </li> <li>Role-based access systems in DAOs.  </li> <li>Key Risks:  </li> <li>Unauthorized privilege escalation.  </li> <li>Mishandling of sensitive user data.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#9-bridge-contracts","title":"9. Bridge Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-cross-chain-bridges","title":"Examples: Cross-chain bridges","text":"<ul> <li>Description:   Contracts facilitating asset or data transfers between blockchains.  </li> <li>Use Cases:  </li> <li>Bridging tokens across L1s and L2s (e.g., Ethereum \u2194 Arbitrum).  </li> <li>Enabling interoperability between blockchains.  </li> <li>Key Risks:  </li> <li>Replay attacks.  </li> <li>Exploits in validator or relayer systems.  </li> <li>Loss of funds during cross-chain transfers.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#10-supply-chain-and-logistics-contracts","title":"10. Supply Chain and Logistics Contracts","text":"<ul> <li>Description:   Contracts managing supply chain operations or tracking logistics.  </li> <li>Use Cases:  </li> <li>Verifying product authenticity.  </li> <li>Tracking shipments across supply chains.  </li> <li>Key Risks:  </li> <li>Dependence on external data integrity.  </li> <li>Incorrect implementation of audit trails.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#11-gaming-and-metaverse-contracts","title":"11. Gaming and Metaverse Contracts","text":"<ul> <li>Description:   Contracts supporting blockchain-based games or virtual worlds.  </li> <li>Use Cases:  </li> <li>On-chain asset ownership (NFTs).  </li> <li>In-game economies using tokens.  </li> <li>Key Risks:  </li> <li>Vulnerabilities in in-game tokenomics.  </li> <li>Exploits in trade or auction mechanisms.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#12-security-tools-and-audit-enablers","title":"12. Security Tools and Audit Enablers","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-multisig-wallets-time-locks","title":"Examples: Multisig wallets, time locks","text":"<ul> <li>Description:   Contracts providing additional layers of security or facilitating audits.  </li> <li>Use Cases:  </li> <li>Multi-signature wallets for secure asset custody.  </li> <li>Timelocks for deferred execution of sensitive operations.  </li> <li>Key Risks:  </li> <li>Misconfigured access controls.  </li> <li>Logic errors in time-based operations.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#13-arbitrage-and-mev-bots","title":"13. Arbitrage and MEV Bots","text":"<ul> <li>Description:   Contracts designed for exploiting arbitrage opportunities or MEV (Maximal Extractable Value).  </li> <li>Use Cases:  </li> <li>On-chain arbitrage trading.  </li> <li>Gas optimization and priority mechanisms.  </li> <li>Key Risks:  </li> <li>Front-running or sandwich attacks on users.  </li> <li>Exploitation of network congestion.  </li> </ul> <p>This taxonomy helps categorize the diverse applications of Solidity and EVM-based contracts, ensuring that each category is analyzed for its unique security challenges and development requirements. By understanding these categories, developers can adopt best practices and mitigate risks effectively.  </p>","tags":[]},{"location":"SCSTG/tests/","title":"SCSTG Tests","text":"TEST ID Title SCSVS CG ID SCSVS SCG IDs Last Updated SCSTG-TEST-0014  Test Gas Usage in Loops SCSVS-DEFI SCSVS-DEFI-1 N/A SCSTG-TEST-0009  Blockchain Data and State Management SCSVS-BRIDGE SCSVS-BRIDGE-1 N/A SCSTG-TEST-0012  Test Token Implementations (ERC20, ERC721, ERC1155) SCSVS-COMP SCSVS-COMP-1 N/A SCSTG-TEST-0007  Modularity and Upgradability SCSVS-ARCH SCSVS-ARCH-2 N/A SCSTG-TEST-0015  Testing Business Logic and Economic Security SCSVS-GOV SCSVS-GOV-1 N/A SCSTG-TEST-0001  Testing Multi-Signature Schemes SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0004  Test Access Control on Critical Functions SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0002  Identity Verification Test SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0003  Least Privilege Principle Test SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0006  Test Access Control Using Merkle Trees SCSVS-AUTH SCSVS-AUTH-2 N/A SCSTG-TEST-0005  Test Timed Permissions SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0010  Test Compiler Version and Deprecated Functions SCSVS-CODE SCSVS-CODE-2 N/A SCSTG-TEST-0016  Testing Arithmetic and Logic Security SCSVS-ORACLE SCSVS-ORACLE-1 N/A SCSTG-TEST-0008  Efficient Loop and Function Design SCSVS-BLOCK SCSVS-BLOCK-1 N/A SCSTG-TEST-0011  Test Contract Interactions SCSVS-COMM SCSVS-COMM-1 N/A SCSTG-TEST-0013  Secure Signature Verification SCSVS-CRYPTO SCSVS-CRYPTO-2 N/A","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/","title":"SCSTG-TEST-0007: Modularity and Upgradability","text":"","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#description","title":"Description","text":"<p>Modularity and upgradability are essential principles for the long-term security and maintainability of smart contracts. Poor modularity often leads to monolithic designs that combine critical logic and storage, making it difficult to upgrade, audit, or scale the system. Without controlled upgrade mechanisms, an attacker could exploit weaknesses in the upgrade process, leading to unauthorized contract changes or the introduction of security flaws. Ensuring a well-structured contract with clear modular separation, as well as a secure upgrade process, is crucial to avoiding such vulnerabilities.</p>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#test-1-ensure-proper-separation-of-logic-and-state","title":"Test 1: Ensure Proper Separation of Logic and State","text":"","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>contract Monolithic {\n    uint256 public data;\n    address public admin;\n\n    function updateData(uint256 _data) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        data = _data;\n    }\n\n    function upgrade(address newAdmin) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        admin = newAdmin;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The monolithic design combines logic and state in a single contract, making upgrades risky.</li> <li>Changes to storage or logic could inadvertently corrupt existing data.</li> <li>The lack of separation makes it more difficult to isolate bugs or vulnerabilities in logic.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#fixed-code","title":"Fixed Code:","text":"<pre><code>contract Logic {\n    address public admin;\n    Storage public storageContract;\n\n    constructor(address _storageContract) {\n        admin = msg.sender;\n        storageContract = Storage(_storageContract);\n    }\n\n    function updateData(uint256 _data) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        storageContract.setData(_data);\n    }\n}\n\ncontract Storage {\n    uint256 public data;\n\n    function setData(uint256 _data) public {\n        data = _data;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Verify the separation of logic and storage into separate contracts.</li> <li>Storage Analysis: Ensure that the storage layout remains intact when upgrading the contract logic, and that no data corruption occurs.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#test-2-verify-secure-and-controlled-upgrade-mechanism","title":"Test 2: Verify Secure and Controlled Upgrade Mechanism","text":"","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>contract Proxy {\n    address public implementation;\n\n    function upgrade(address newImplementation) public {\n        implementation = newImplementation;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The upgrade function is not protected with any access control, allowing any user to replace the implementation contract. This opens the door for malicious actors to hijack the contract functionality.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#fixed-code_1","title":"Fixed Code:","text":"<pre><code>contract SecureProxy {\n    address public implementation;\n    address public admin;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\");\n        _;\n    }\n\n    function upgrade(address newImplementation) public onlyAdmin {\n        implementation = newImplementation;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Ensure that upgrade functions are protected by access control mechanisms (e.g., only the admin can upgrade).</li> <li>Dynamic Testing: Attempt to perform an unauthorized upgrade to verify that the access control works as intended.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/","title":"Architecture, Design, and Threat Modeling","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/#description","title":"Description","text":"<p>Flawed architecture, design, and inadequate threat modeling in smart contracts can lead to vulnerabilities that compromise the security, functionality, or usability of a decentralized application (dApp). These issues often arise due to a lack of consideration for potential attack vectors, edge cases, and dependencies during the design phase.</p> <p>Poor design and threat modeling can result in issues such as:</p> <ul> <li>Insecure storage of sensitive data</li> <li>Flawed or unoptimized logic for critical functions</li> <li>Lack of mitigation strategies for common attack vectors, such as reentrancy or flash loan attacks</li> <li>Insufficient mechanisms for governance or upgrades</li> <li>Overlooked dependencies on external systems or oracles</li> </ul> <p>Example: Poorly Designed Function Logic</p> <pre><code>function withdraw(uint256 amount) public {\n    // Does not check for balance before withdrawal\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Withdrawal failed\");\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/#impact","title":"Impact","text":"<ul> <li>Contracts may become vulnerable to exploitation, resulting in the theft or loss of funds, data corruption, or denial of service.  </li> <li>Security flaws in design can lead to cascading failures in interconnected systems or dApps.  </li> <li>Exploits often undermine user trust and the reputation of the project.  </li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/#remediation","title":"Remediation","text":"<ul> <li>Conduct a comprehensive threat model analysis during the design phase to identify potential risks and attack vectors.  </li> <li>Follow secure coding and design principles, such as least privilege, separation of duties, and fail-safe defaults.  </li> <li>Regularly perform security audits, both during development and prior to deployment.  </li> <li>Use formal verification tools to validate critical properties of your smart contracts.  </li> <li>Employ defense-in-depth strategies, including mechanisms like reentrancy guards, circuit breakers, and secure external call handling.  </li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0001/","title":"SCSTG-TEST-0001: Testing Multi-Signature Schemes","text":"<p>Ensure that multi-signature schemes are implemented for critical operations, requiring approvals from multiple authorized parties to enhance security and reduce the risk of unauthorized actions.</p> <ul> <li>Verify that the multi-signature logic ensures a configurable threshold of approvals before executing sensitive operations.  </li> <li>Confirm that all signers are authenticated and that duplicate signatures are rejected.  </li> <li>Test edge cases, such as insufficient approvals or tampered data.</li> </ul> <p><pre><code>// Example of multi-signature scheme\npragma solidity ^0.8.0;\n\ncontract MultiSigWallet {\n    address[] public owners;\n    uint public requiredApprovals;\n    mapping(address =&gt; bool) public isOwner;\n    mapping(uint =&gt; mapping(address =&gt; bool)) public approvals;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bool executed;\n    }\n\n    Transaction[] public transactions;\n\n    constructor(address[] memory _owners, uint _requiredApprovals) {\n        require(_owners.length &gt; 0, \"Owners required\");\n        require(_requiredApprovals &gt; 0 &amp;&amp; _requiredApprovals &lt;= _owners.length, \"Invalid approval count\");\n\n        for (uint i = 0; i &lt; _owners.length; i++) {\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        requiredApprovals = _requiredApprovals;\n    }\n\n    function submitTransaction(address _to, uint _value) public {\n        require(isOwner[msg.sender], \"Not an owner\");\n        transactions.push(Transaction({to: _to, value: _value, executed: false}));\n    }\n\n    function approveTransaction(uint _txIndex) public {\n        require(isOwner[msg.sender], \"Not an owner\");\n        require(!approvals[_txIndex][msg.sender], \"Already approved\");\n\n        approvals[_txIndex][msg.sender] = true;\n    }\n\n    function executeTransaction(uint _txIndex) public {\n        require(transactions[_txIndex].executed == false, \"Already executed\");\n\n        uint approvalCount = 0;\n        for (uint i = 0; i &lt; owners.length; i++) {\n            if (approvals[_txIndex][owners[i]]) {\n                approvalCount++;\n            }\n        }\n\n        require(approvalCount &gt;= requiredApprovals, \"Not enough approvals\");\n\n        transactions[_txIndex].executed = true;\n        (bool ok, ) = payable(transactions[_txIndex].to).call{value: transactions[_txIndex].value}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    receive() external payable {}\n}\n</code></pre> Review the logic to ensure all approvals are validated before execution, duplicate approvals are prevented, and transaction data integrity is maintained. Test with various approval scenarios to verify proper handling of edge cases.</p>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0002/","title":"SCSTG-TEST-0002: Identity Verification Test","text":"<p>Validate that unexpected addresses do not result in unintended behaviors, particularly when these addresses refer to contracts within the same protocol.</p> <ul> <li>Ensure that when interacting with contracts, unexpected addresses are properly validated before performing sensitive operations. <pre><code>require(address(contract) != address(0), \"Invalid address\");\n</code></pre></li> </ul> <p>Verify that functions like ecrecover handle all potential null addresses properly to avoid vulnerabilities arising from unexpected ecrecover outputs.</p> <ul> <li>Ensure that ecrecover does not process empty or null addresses. <pre><code>address recovered = ecrecover(messageHash, v, r, s);\nrequire(recovered != address(0), \"Invalid signature\");\n</code></pre></li> </ul>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0003/","title":"SCSTG-TEST-0003: Least Privilege Principle Test","text":"<p>Use msg.sender instead of tx.origin for authorization to avoid potential abuse from malicious contracts; include checks like require(tx.origin == msg.sender) to ensure the sender is an EOA.</p> <ul> <li>tx.origin can be abused by malicious contracts to trick the system into performing actions on behalf of an unsuspecting user. msg.sender is preferred since it refers to the direct sender of the message. <pre><code>require(msg.sender == owner, \"Not the owner\");\nrequire(tx.origin == msg.sender, \"Only EOA can execute\");\n</code></pre></li> </ul> <p>Certain addresses might be blocked or restricted from receiving tokens (e.g., LUSD). Ensure that address restrictions are properly managed and verified.</p> <ul> <li>If certain addresses (like LUSD) should be blocked from receiving tokens, ensure that there\u2019s a check in place to restrict these addresses. <pre><code>address restrictedAddress = 0x123...;  // Example of a restricted address\nrequire(msg.sender != restrictedAddress, \"Restricted address cannot perform this operation\");\n</code></pre></li> </ul> <p>Ensure that Guard\u2019s hooks (e.g., checkTransaction(), checkAfterExecution()) are executed to enforce critical security checks.</p> <ul> <li>If using a Guard contract, ensure that hooks like checkTransaction() or checkAfterExecution() are properly implemented to enforce security conditions. <pre><code>function checkTransaction() internal {\n    // Add conditions to verify transaction before execution\n}\n\nfunction checkAfterExecution() internal {\n    // Add conditions to verify transaction after execution\n}\n</code></pre></li> </ul>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0004/","title":"SCSTG-TEST-0004: Test Access Control on Critical Functions","text":"<p>Ensure that access controls are implemented correctly to determine who can use certain functions, and avoid unauthorized changes or withdrawals.</p> <ul> <li>Ensure that functions requiring specific roles or permissions are restricted properly using onlyOwner or role-based checks. <pre><code>    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function withdraw() external onlyOwner {\n        // Only the owner can withdraw\n    }\n</code></pre></li> </ul>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0005/","title":"SCSTG-TEST-0005: Test Timed Permissions","text":"<p>Ensure that access controls are implemented correctly to determine who can use certain functions, and avoid unauthorized changes or withdrawals.</p> <ul> <li>Ensure that functions requiring specific roles or permissions are restricted properly using onlyOwner or role-based checks.</li> </ul> <pre><code>    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function withdraw() external onlyOwner {\n        // Only the owner can withdraw\n    }\n</code></pre>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0006/","title":"SCSTG-TEST-0006: Test Access Control Using Merkle Trees","text":"<p>Ensure that <code>msg.sender</code> validation is properly implemented when using Merkle trees to maintain security and prevent unauthorized access.</p> <ul> <li>When using Merkle trees to authenticate users or grant permissions, ensure that the contract verifies that <code>msg.sender</code> matches the expected address and Merkle proof. This prevents unauthorized actors from bypassing security by submitting incorrect proofs.</li> </ul> <pre><code>    require(verifyMerkleProof(msg.sender, merkleProof), \"Invalid Merkle proof\");\n</code></pre> <ul> <li> <p>Use whitelisting to restrict interactions to a specific set of addresses, providing additional security against malicious actors.</p> </li> <li> <p>Implement a whitelisting mechanism that allows only approved addresses to interact with specific functions. Ensure that only addresses explicitly added to the whitelist are able to execute sensitive operations.</p> </li> </ul> <p><pre><code>    address[] public whitelist;\n\n    modifier onlyWhitelisted() {\n        bool isWhitelisted = false;\n        for (uint i = 0; i &lt; whitelist.length; i++) {\n            if (msg.sender == whitelist[i]) {\n                isWhitelisted = true;\n                break;\n            }\n        }\n        require(isWhitelisted, \"Address not whitelisted\");\n        _;\n    }\n\n    function addToWhitelist(address _address) external onlyOwner {\n        whitelist.push(_address);\n    }\n</code></pre> - Ensure that functions modifying the contract state or accessing sensitive operations have proper access controls implemented.</p> <ul> <li>Critical functions, such as those that modify contract state or handle sensitive information, should only be callable by authorized addresses (e.g., the owner or an admin). Use modifiers to enforce access controls for these functions.</li> </ul> <pre><code>    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    function modifyContractState() external onlyOwner {\n        // Logic to modify contract state\n    }\n</code></pre>","tags":["test","SCSVS-AUTH-2","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/","title":"Access Control and Authentication Vulnerabilties","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#description","title":"Description","text":"<p>Improper access control is a critical security vulnerability in smart contracts that occurs when unauthorized users can access or modify sensitive functions or data. This issue typically arises when the code does not enforce strict access restrictions based on user permissions.</p> <p>Access control vulnerabilities are especially significant in scenarios involving governance or critical operations, such as:</p> <ul> <li>Minting tokens</li> <li>Voting on proposals</li> <li>Withdrawing funds</li> <li>Pausing or upgrading contracts</li> <li>Changing contract ownership</li> </ul> <p>Example: Code Without Proper Access Control</p> <pre><code>function burn(address account, uint256 amount) public \n{\n    // No access control is implemented for the burn function\n    _burn(account, amount); \n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#impact","title":"Impact","text":"<ul> <li>Attackers can gain unauthorized access to critical functions and data within the contract, compromising its integrity and security.</li> <li>Vulnerabilities can lead to the theft of funds or assets controlled by the contract, causing significant financial damage to users and stakeholders.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#remediation","title":"Remediation","text":"<ul> <li>Ensure initialization functions can only be called once and exclusively by authorized entities.</li> <li>Use established access control patterns like Ownable or RBAC (Role-Based Access Control) in your contracts to manage permissions and ensure that only authorized users can access certain functions. This can be done by adding appropriate access control modifiers, such as onlyOwner or custom roles to sensitive functions.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#examples-of-smart-contracts-that-fell-victim-to-improper-access-control-attacks","title":"Examples of Smart Contracts That Fell Victim to Improper Access Control Attacks:","text":"<ul> <li>HospoWise Hack Analysis</li> <li>LAND NFT Hack Analysis</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/","title":"SCSTG-TEST-0008: Efficient Loop and Function Design","text":"","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#description","title":"Description","text":"<p>Inefficient loop and function designs in smart contracts can result in excessive gas consumption, leading to out-of-gas errors and potential denial-of-service (DoS) vulnerabilities. Smart contract security auditors must ensure that all loops and functions are optimized to operate within Ethereum's block gas limit.</p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#test-1-detecting-unbounded-loops","title":"Test 1: Detecting Unbounded Loops","text":"","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#objective","title":"Objective","text":"<p>Identify and mitigate the use of unbounded loops in contract code, as they are vulnerable to excessive gas usage.  </p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UnboundedLoopExample {\n    uint[] public data;\n\n    function processAll() public {\n        for (uint i = 0; i &lt; data.length; i++) {\n            // This operation scales with the size of the array\n            data[i] = data[i] + 1;\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<p>The loop iterates over the entire <code>data</code> array, which could grow indefinitely. - For large arrays, gas consumption may exceed the block gas limit, causing the transaction to fail. - Attackers could exploit this by filling the array, making the function unusable for legitimate users.  </p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for <code>for</code> or <code>while</code> loops operating on dynamic arrays or mappings without size constraints.  </li> <li>Dynamic Input Testing: Test the function with a large dataset to simulate its behavior near the gas limit.  </li> <li>Review Documentation: Ensure the contract specifies constraints on data growth and function usage.  </li> </ul>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#fixed-code-example","title":"Fixed Code Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract BoundedLoopExample {\n    uint[] public data;\n\n    function processBatch(uint start, uint end) public {\n        require(end &lt;= data.length, \"End index out of bounds\");\n        for (uint i = start; i &lt; end; i++) {\n            data[i] = data[i] + 1;\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#test-2-identifying-inefficient-nested-loops","title":"Test 2: Identifying Inefficient Nested Loops","text":"","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#objective_1","title":"Objective","text":"<ul> <li>Detect and address inefficient nested loops that exponentially increase gas consumption.</li> </ul>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract NestedLoopExample {\n    uint[][] public matrix;\n\n    function processMatrix() public {\n        for (uint i = 0; i &lt; matrix.length; i++) {\n            for (uint j = 0; j &lt; matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * 2;\n            }\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<p>Nested loops increase the complexity of the operation, leading to higher gas costs as input size increases. - Large datasets could render the function unusable within the gas limits, causing DoS conditions.  </p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Examine nested loops in the code and assess their gas consumption relative to the input size.  </li> <li>Gas Profiling: Use tools like <code>eth-gas-reporter</code> to analyze gas usage during testing.  </li> <li>Dynamic Testing: Simulate scenarios with large <code>matrix</code> sizes to observe the contract\u2019s behavior under stress.  </li> </ul> <pre><code>pragma solidity ^0.8.0;\n\ncontract OptimizedNestedLoopExample {\n    uint[][] public matrix;\n\n    function processMatrixBatch(uint startRow, uint endRow) public {\n        require(endRow &lt;= matrix.length, \"End row exceeds matrix size\");\n        for (uint i = startRow; i &lt; endRow; i++) {\n            for (uint j = 0; j &lt; matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * 2;\n            }\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/","title":"Denial of Service (DoS)","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#description","title":"Description","text":"<p>Denial of Service (DoS) vulnerabilities occur when a smart contract or system is made unavailable to its users by exhausting computational resources or blocking critical operations. This type of vulnerability can result from inefficient function design, excessive gas usage, or unhandled failure conditions. DoS attacks can lead to degraded performance, halted operations, and a poor user experience. To prevent DoS vulnerabilities, developers must carefully design gas-efficient operations, handle errors gracefully, and mitigate the risk of resource exhaustion.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#example-unbounded-loop-with-user-input","title":"Example:  Unbounded Loop with User Input","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasDoSVulnerable {\n    mapping(address =&gt; uint256) public balances;\n\n    // Allows a user to send tokens to many recipients in one transaction.\n    function bulkTransfer(address[] memory recipients, uint256[] memory amounts) public {\n        require(recipients.length == amounts.length, \"Invalid input\");\n\n        for (uint256 i = 0; i &lt; recipients.length; i++) {\n            require(amounts[i] &gt; 0, \"Amount must be greater than zero\");\n            balances[recipients[i]] += amounts[i];\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#impact","title":"Impact","text":"<ul> <li>Gas Limit Exhaustion: Functions that rely on loops with dynamic input sizes or unoptimized logic can lead to excessive gas consumption. This can result in transactions exceeding the block gas limit, causing out-of-gas errors or failing to complete.</li> <li>Transaction Failures: Without adequate handling of gas usage or error conditions, contracts can fail unexpectedly, preventing legitimate operations and denying service to users.</li> <li>Resource Exhaustion: Improperly managed resource consumption, such as large data queries or excessive loop iterations, can overwhelm the system, causing DoS by exhausting computational resources or making the contract unavailable for further interactions.</li> <li>Increased Transaction Costs: Inefficient gas usage may lead to higher transaction fees, discouraging users from interacting with the contract or causing network congestion.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#remediation","title":"Remediation","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#efficient-loop-and-function-design","title":"Efficient Loop and Function Design:","text":"<ul> <li>Optimize functions with loops to reduce gas consumption and prevent DoS attacks by ensuring that loops operate with fixed or minimal input sizes. Avoid using large dynamic data arrays in loops.</li> <li>Ensure critical functions, like <code>burn()</code>, handle failures gracefully, so that the contract does not enter an unrecoverable state.</li> <li>Protect against griefing attacks by managing gas consumption carefully, ensuring that operations are efficient and do not hit gas limits.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#fallback-mechanisms","title":"Fallback Mechanisms:","text":"<ul> <li>Implement try/catch blocks with sufficient gas to prevent unexpected failures from leaving the contract in an inconsistent or unresponsive state.</li> <li>Design fallback mechanisms that ensure errors are caught and handled without causing DoS vulnerabilities, such as failing silently or leaving contracts in a halted state.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#rate-limiting-and-resource-management","title":"Rate Limiting and Resource Management:","text":"<ul> <li>Avoid blocking mechanisms that could lead to DoS attacks. For example, ensure that excessive queries or operations are handled efficiently, especially when dealing with external systems or large datasets.</li> <li>Use rate limiting or batching for high-volume transactions to prevent overwhelming the system or consuming excessive resources.</li> <li>Implement efficient error handling for external function calls to ensure that the contract doesn't fail or become unresponsive due to unchecked return values or failed external interactions.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#error-handling","title":"Error Handling:","text":"<ul> <li>Ensure that assertions do not lead to DoS by carefully checking conditions and ensuring that failures are handled appropriately, rather than causing reverts that impact overall system availability.</li> <li>Protect against DoS due to unexpected reverts by considering all possible failure scenarios in the contract's logic and providing proper fallback solutions.</li> <li>Ensure functions like <code>supportsERC165InterfaceUnchecked()</code> in the ERC165Checker.sol handle large data queries efficiently, minimizing the risk of resource exhaustion.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/","title":"SCSTG-TEST-0009: Blockchain Data and State Management","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#description","title":"Description","text":"<p>Effective management of blockchain data and state is crucial for ensuring the consistency and security of decentralized applications. Poor state management can lead to data corruption, inconsistencies between contracts, and vulnerabilities that attackers can exploit. Ensuring that data changes are properly tracked, validated, and secure is key to maintaining the integrity of the system. This includes ensuring that sensitive data is not exposed, and that critical functions such as state transitions are properly handled. This test focuses on validating that smart contracts effectively manage their state and data in a secure and robust manner.</p>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#test-1-validate-proper-use-of-storage-variables","title":"Test 1: Validate Proper Use of Storage Variables","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>contract DataStorage {\n    uint256 public value;\n\n    function updateValue(uint256 newValue) public {\n        value = newValue;\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract directly updates the state variable <code>value</code> without validating or securing the transaction, exposing the contract to potential manipulation.  </li> <li>If <code>newValue</code> is provided by an untrusted user, it could lead to data corruption or loss of value.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#fixed","title":"Fixed:","text":"<pre><code>contract SecureDataStorage {\n    uint256 public value;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function updateValue(uint256 newValue) public onlyOwner {\n        value = newValue;\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Ensure that state variables are updated only through validated functions, and that access to sensitive operations is restricted through appropriate access controls.</li> <li>Testing: Test the contract by submitting values from different sources and verify that the state is only updated when appropriate conditions are met.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#test-2-ensure-proper-validation-of-external-data-inputs","title":"Test 2: Ensure Proper Validation of External Data Inputs","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#vulnerable-code_1","title":"Vulnerable Code","text":"<pre><code>contract ExternalData {\n    uint256 public externalValue;\n\n    function updateExternalData(address oracle) public {\n        // Vulnerable: call returns (bool, bytes); no success check; invalid assignment\n        (bool success, bytes memory data) = oracle.call(abi.encodeWithSignature(\"getData()\"));\n        if (data.length &gt;= 32) {\n            externalValue = abi.decode(data, (uint256));  // Proceeds without checking success\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#example-2-unsecured-external-data-sources","title":"Example 2: Unsecured External Data Sources","text":"<ul> <li>The contract calls external data sources without validating the data properly, allowing attackers to feed false or malicious data.  </li> <li>The <code>oracle.call()</code> method exposes the contract to arbitrary external calls, which could result in unintended consequences.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#fixed_1","title":"Fixed:","text":"<pre><code>interface IOracle {\n    function getData() external view returns (uint256);\n}\n\ncontract SecureExternalData {\n    uint256 public externalValue;\n    address public oracle;\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle, \"Unauthorized\");\n        _;\n    }\n\n    constructor(address _oracle) {\n        oracle = _oracle;\n    }\n\n    function updateExternalData() public onlyOracle {\n        externalValue = IOracle(oracle).getData();  // Safe interaction with oracle interface\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Look for external contract calls and ensure that proper validation mechanisms (e.g., access control and data validation) are in place.</li> <li>Dynamic Testing: Attempt to feed invalid or malicious data to the contract and verify that it rejects the input or fails gracefully.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#test-3-prevent-data-inconsistencies-through-proper-event-logging","title":"Test 3: Prevent Data Inconsistencies Through Proper Event Logging","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#vulnerable-code_2","title":"Vulnerable Code","text":"<pre><code>contract InconsistentState {\n    uint256 public data;\n\n    function setData(uint256 newData) public {\n        data = newData;\n        // No event emitted\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#why-its-vulnerable_2","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract does not emit events after updating the state, leading to a lack of transparency and difficulty tracking state changes.  </li> <li>The absence of events makes it harder to detect inconsistencies or malicious changes to the data.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#fixed_2","title":"Fixed:","text":"<pre><code>contract ConsistentState {\n    uint256 public data;\n\n    event DataUpdated(uint256 newData);\n\n    function setData(uint256 newData) public {\n        data = newData;\n        emit DataUpdated(newData);  // Emits event on state change\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#how-to-check_2","title":"How to Check","text":"<ul> <li>Code Review: Ensure that important state changes and data updates are accompanied by event emissions to track changes and ensure consistency.</li> <li>Testing: Monitor the contract\u2019s events and check that critical operations such as state changes are logged correctly.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/","title":"Blockchain Data and State Management","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#description","title":"Description","text":"<p>Blockchain data and state management involve securely handling, storing, and accessing information within smart contracts. This includes managing on-chain state, protecting sensitive data, and ensuring that logged events are accurate and tamper-proof. Mismanagement in any of these areas can lead to inefficiencies, data breaches, or vulnerabilities, undermining the contract\u2019s security and usability.</p> <p>Key concerns in this domain include:</p> <ol> <li>State Management: Ensuring that smart contracts handle state transitions efficiently and securely.</li> <li>Data Privacy: Protecting sensitive user information through encryption, zero-knowledge proofs, or private transaction mechanisms.</li> <li>Event Logging: Maintaining reliable and secure logging practices to ensure transparency without exposing sensitive information.</li> <li>Decentralized Storage: Utilizing off-chain storage solutions like IPFS or Arweave securely and efficiently.</li> </ol>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#example-inefficient-state-management","title":"Example: Inefficient State Management","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InefficientStateManagement {\n    uint256[] public largeArray;\n\n    // Adds elements to the array\n    function addElements(uint256[] memory elements) public {\n        for (uint256 i = 0; i &lt; elements.length; i++) {\n            largeArray.push(elements[i]);\n        }\n    }\n\n    // Removes elements from the array inefficiently\n    function removeElement(uint256 index) public {\n        require(index &lt; largeArray.length, \"Index out of bounds\");\n        // Inefficient removal that shifts all elements\n        for (uint256 i = index; i &lt; largeArray.length - 1; i++) {\n            largeArray[i] = largeArray[i + 1];\n        }\n        largeArray.pop();\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#analysis","title":"Analysis:","text":"<ol> <li> <p>Inefficient Loops:    The <code>addElements</code> and <code>removeElement</code> functions involve iterating over large arrays. These loops consume a significant amount of gas, particularly for large datasets, potentially causing transactions to exceed the block gas limit and fail.</p> </li> <li> <p>State Bloat:    Continuously growing the <code>largeArray</code> without mechanisms to manage its size increases on-chain storage. This leads to unnecessary state bloat and higher costs for future interactions.</p> </li> <li> <p>Error Handling:    The <code>require</code> statement for <code>index</code> is insufficient for protecting against misuse. The function does not handle scenarios where the array size changes mid-transaction due to reentrancy or other unexpected issues.</p> </li> </ol>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#example-exposed-sensitive-data","title":"Example: Exposed Sensitive Data","text":"<pre><code>// Example of sensitive data exposure\npragma solidity ^0.8.0;\n\ncontract DataPrivacy {\n    mapping(address =&gt; uint256) private balances;\n\n    event UserBalance(address indexed user, uint256 balance);\n\n    // Logs user balance\n    function logBalance() public {\n        emit UserBalance(msg.sender, balances[msg.sender]);\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#analysis_1","title":"Analysis:","text":"<ol> <li> <p>Sensitive Data Exposure:    The <code>logBalance</code> function emits an event that includes a user\u2019s balance. While useful for transparency, it exposes sensitive financial information publicly, violating user privacy.</p> </li> <li> <p>Lack of Encryption:    Sensitive data is logged in plaintext, making it readable to anyone inspecting the blockchain. This is a critical privacy concern for applications requiring confidentiality.</p> </li> </ol>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#impact","title":"Impact","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#inefficient-state-management","title":"Inefficient State Management","text":"<ul> <li>High Gas Costs: Unoptimized loops and storage usage result in excessive gas consumption.</li> <li>Transaction Failures: Increased likelihood of exceeding gas limits, causing failed transactions.</li> <li>Scalability Issues: Long-term scalability is affected by state bloat due to inefficient data handling.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#data-privacy-risks","title":"Data Privacy Risks","text":"<ul> <li>Privacy Violations: Unauthorized access to sensitive information compromises user privacy.</li> <li>Erosion of Trust: Users may lose confidence in the platform due to exposed confidential data.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#event-logging-vulnerabilities","title":"Event Logging Vulnerabilities","text":"<ul> <li>Public Exposure: Confidential data may be inadvertently exposed through events.</li> <li>Audit Challenges: Poorly designed events make debugging and auditing difficult.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#storage-risks","title":"Storage Risks","text":"<ul> <li>Data Mismanagement: Misconfigured off-chain storage solutions can lead to data loss or unauthorized access.</li> <li>Reduced Decentralization: Reliance on centralized gateways undermines the benefits of decentralization.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#remediation","title":"Remediation","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#efficient-state-management","title":"Efficient State Management","text":"<ul> <li>Optimize functions to minimize gas usage, particularly for operations involving arrays or mappings.</li> <li>Avoid unbounded loops or large dynamic arrays to reduce gas costs and state size.</li> <li>Implement batching, pagination, or off-chain computation for processing large datasets.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#data-privacy","title":"Data Privacy","text":"<ul> <li>Encrypt sensitive data before storing or transmitting it.</li> <li>Leverage privacy-preserving technologies like zero-knowledge proofs to securely verify without exposing underlying data.</li> <li>Use private transactions or confidential contracts for operations involving sensitive information.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#event-logging","title":"Event Logging","text":"<ul> <li>Avoid logging sensitive data in plaintext. Instead, use hashed or anonymized data when necessary.</li> <li>Design logging mechanisms that balance the need for transparency with privacy concerns.</li> <li>Regularly analyze logs to identify anomalies or vulnerabilities.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#decentralized-storage","title":"Decentralized Storage","text":"<ul> <li>Use secure, decentralized storage solutions such as IPFS or Arweave for handling large or off-chain data.</li> <li>Implement redundancy and access control mechanisms to safeguard against data loss or unauthorized access.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/","title":"SCSTG-TEST-0010: Test Compiler Version and Deprecated Functions","text":"","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#description","title":"Description","text":"<p>Proper management of development policies, secure coding standards, code clarity, and test coverage ensures that smart contracts are secure, maintainable, and resilient to vulnerabilities. This test focuses on ensuring adherence to best practices and guidelines for developing and reviewing smart contracts. This includes the use of current compilers, avoiding deprecated functions, thorough code reviews, and ensuring proper test coverage. Code clarity is also critical for maintaining contracts over time and ensuring they remain understandable and auditable.</p>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#test-1-verify-compiler-version-and-avoid-deprecated-functions","title":"Test 1: Verify Compiler Version and Avoid Deprecated Functions","text":"","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Example {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses an outdated compiler version (^0.4.0). Using old versions of Solidity may lead to known security vulnerabilities and lack of support for modern features.</li> <li>Older compiler versions also lack optimizations and security fixes that are available in newer versions.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#fixed","title":"Fixed:","text":"<pre><code>pragma solidity ^0.8.0;  // Update to the latest stable version\n\ncontract Example {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Ensure that the pragma directive specifies an up-to-date version of Solidity (e.g., ^0.8.x) and not outdated ones such as ^0.4.x.</li> <li>Automated Check: Use Solidity linting tools or automated CI/CD pipelines to flag usage of outdated compiler versions.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#test-2-ensure-code-review-processes-and-avoid-deprecated-functions","title":"Test 2: Ensure Code Review Processes and Avoid Deprecated Functions","text":"","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.4.24;\n\n// Example: ETH vault (sends Ether, not ERC20 tokens). Variable names simplified for clarity.\ncontract Token {\n    string public name = \"Token\";\n    uint public totalSupply = 1000000;  // Tracks remaining withdrawable ETH\n\n    // Deprecated: uses transfer() for Ether; deprecated in Solidity 0.5+\n    function transfer(address recipient, uint amount) public {\n        require(msg.sender != recipient, \"Cannot transfer to yourself\");\n        require(amount &lt;= totalSupply, \"Amount exceeds total supply\");\n\n        totalSupply -= amount;\n        // Deprecated: The transfer method below is obsolete\n        recipient.transfer(amount);\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The function transfer in the above example uses a deprecated <code>transfer()</code> method to send Ether to the recipient.</li> <li>The <code>transfer()</code> method was removed in Solidity 0.5.x, and it\u2019s recommended to use <code>call()</code> instead to prevent errors due to changes in gas limits and transfer behavior in newer Solidity versions.</li> <li>Using deprecated functions can make your contract incompatible with future versions of Solidity and leave it vulnerable to unexpected behavior.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\n// ETH vault example: sends Ether via call{value} (see SCWE-079)\ncontract Token {\n    string public name = \"Token\";\n    uint public totalSupply = 1000000;\n\n    function transfer(address payable recipient, uint amount) public {\n        require(msg.sender != recipient, \"Cannot transfer to yourself\");\n        require(amount &lt;= totalSupply, \"Amount exceeds total supply\");\n\n        totalSupply -= amount;\n        // Replaced deprecated transfer method with call to ensure proper handling\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#why-the-fix-works","title":"Why the Fix Works","text":"<ul> <li>The updated code uses the <code>call()</code> method instead of the deprecated <code>transfer()</code> method to send Ether.</li> <li>The <code>call()</code> method is more flexible and is recommended in Solidity 0.5.x and later, as it allows specifying gas and properly handling errors.</li> <li>This change ensures that the contract is compatible with newer Solidity versions (&gt;=0.5.x) and avoids potential issues with future upgrades.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Ensure the contract is not using any deprecated or obsolete functions. Look for any <code>transfer()</code>, <code>send()</code>, or other outdated methods, and replace them with the more secure <code>call()</code> method when sending Ether.</li> <li>Static Analysis Tools: Use tools like SolidityScan, MythX, Slither, or linters to detect deprecated features and provide suggestions for updating the code.</li> <li>Testing: Test the contract using the latest Solidity version and verify that no deprecated functions are used, ensuring compatibility with newer compilers.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/overview/","title":"Policies, Procedures, and Code Management","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/overview/#description","title":"Description","text":"<p>Policies, procedures, and code management play a crucial role in ensuring the security, maintainability, and scalability of smart contracts. Proper development practices, such as secure coding standards, thorough code reviews, and consistent documentation, are essential for preventing vulnerabilities and ensuring smooth development workflows. Without these practices, smart contracts may become difficult to manage, error-prone, or vulnerable to security exploits.</p> <p>This section covers best practices in secure coding standards, code review processes, code clarity, and comprehensive testing to reduce vulnerabilities and improve the quality of the codebase.</p> <p>Example: Code With Redundant or Dead Code</p> <pre><code>// Example: Code with redundant, duplicated, or dead code\nfunction transfer(address recipient, uint256 amount) public {\n    // Redundant code: balance is checked twice\n    require(balanceOf[msg.sender] &gt;= amount, \"Insufficient balance\");\n    balanceOf[msg.sender] -= amount;\n    balanceOf[recipient] += amount;\n    // Dead code: This line will never be reached\n    if (amount == 0) {\n        revert(\"Cannot transfer zero amount\");\n    }\n    emit Transfer(msg.sender, recipient, amount);\n}\n</code></pre> <p>In the above example, the check for <code>amount == 0</code> is redundant because the first <code>require</code> statement ensures that the sender has enough balance to make the transfer. Also, if <code>amount == 0</code>, the transaction would revert due to the <code>require</code> check, making the second check unnecessary. Additionally, the <code>revert(\"Cannot transfer zero amount\")</code> will never be executed because of the earlier revert.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/overview/#impact","title":"Impact","text":"<ul> <li>Code Redundancy: Redundant checks or logic lead to unnecessary computations and increased gas costs. This can also introduce confusion about the intended behavior of the contract, making it harder to maintain and audit.</li> <li>Dead Code: Unreachable or unnecessary code bloats the contract, making it more complex and increasing the risk of errors or vulnerabilities. It can also lead to wasted gas when the contract executes, as unused code still contributes to the overall execution cost.</li> <li>Security Risks: Redundant or dead code may hide actual vulnerabilities and complicate the auditing process, making it easier for attackers to find and exploit flaws.</li> <li>Maintainability Issues: The presence of redundant or dead code makes the contract harder to maintain and extend, as developers may waste time debugging or managing parts of the code that do not affect the system's functionality.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/overview/#remediation","title":"Remediation","text":"<ul> <li>Remove Redundant and Dead Code: Perform regular code reviews and refactor contracts to eliminate redundant or dead code. This reduces complexity and ensures that the contract remains efficient and understandable.</li> <li>Keep Logic Simple and Clear: Avoid unnecessary checks or repeated logic that can be handled by existing conditions or functions. Keep the contract logic as simple and clear as possible to minimize the chance of introducing errors.</li> <li>Optimize Gas Costs: Removing unnecessary logic reduces gas consumption, making the contract more cost-effective for users and improving overall network performance.</li> <li>Use Automated Tools: Implement static analysis tools and linters to detect redundant or dead code, helping to streamline the codebase and enforce best practices.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/","title":"SCSTG-TEST-0011: Test Contract Interactions","text":"","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#description","title":"Description","text":"<p>Ensuring secure interactions and communications in smart contracts is crucial for protecting against unauthorized access, manipulation, and attacks. This includes ensuring that contracts interact securely with external contracts, manage oracle integrations safely, and use secure methods for cross-chain and bridge operations. A failure to adhere to best practices for these interactions can expose the contract to vulnerabilities such as reentrancy, front-running, or incorrect data feeds. This test focuses on validating that smart contracts perform secure interactions and communications, safeguarding the system from common attack vectors.</p>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#test-1-ensure-secure-contract-interactions","title":"Test 1: Ensure Secure Contract Interactions","text":"","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract VulnerableContract {\n    address public trustedAddress;\n\n    constructor(address _trustedAddress) public {\n        trustedAddress = _trustedAddress;\n    }\n\n    function callExternalContract(address _to, uint256 _value) public {\n        _to.call{value: _value}(\"\"); // Vulnerable to reentrancy or other attacks\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses <code>.call</code> to make external calls, which is generally unsafe and susceptible to reentrancy attacks.</li> <li>The function allows anyone to trigger the call and transfer funds, exposing the contract to potential attacks.</li> </ul>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureContract {\n    address public trustedAddress;\n\n    constructor(address _trustedAddress) {\n        trustedAddress = _trustedAddress;\n    }\n\n    function callExternalContract(address _to, uint256 _value) public {\n        require(_to != address(0), \"Invalid address\");\n        (bool success, ) = _to.call{value: _value}(\"\");\n        require(success, \"External call failed\");\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for external calls in the contract and ensure that they are using safe methods such as <code>transfer</code> or <code>send</code> where appropriate, or implementing reentrancy protection.</li> <li>Static Analysis: Use static analysis tools like SolidityScan, MythX or Slither to detect unsafe calls in the code.</li> <li>Dynamic Testing: Simulate a reentrancy attack by deploying a contract that calls the vulnerable contract and tries to drain funds.</li> </ul>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/overview/","title":"Unchecked External Calls in Smart Contracts","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/overview/#description","title":"Description","text":"<p>Unchecked external calls occur when a smart contract makes an external call to another contract or address without verifying the call's outcome. In Ethereum, external calls may fail silently, and the calling contract may mistakenly proceed as if the call succeeded. This leads to state inconsistencies and potential exploitation. The issue is particularly risky in functions like delegatecall, send, or call, where the outcome must be explicitly checked.</p> <p>Example: Code Without Proper Access Control</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes memory _data) public {\n        require(callee.delegatecall(_data)); // Unchecked: no validation of callee; delegatecall executes in caller context\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/overview/#impact","title":"Impact","text":"<ul> <li>When external calls fail and their results are unchecked, the contract can proceed under incorrect assumptions, leading to potential loss of funds or other unexpected behaviors.</li> <li>Unverified external calls can lead to incorrect updates to the contract state, making it vulnerable to exploits and logical inconsistencies.</li> <li>Attackers can manipulate such vulnerabilities to execute malicious code or withdraw funds multiple times.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/overview/#remediation","title":"Remediation","text":"<ul> <li>For low-level functions like <code>call</code>, <code>delegatecall</code>, and <code>staticcall</code>, always check the return value and handle failures with <code>require(success, \"message\")</code>.</li> <li>For ETH transfers, prefer <code>call{value}(\"\")</code> with explicit success checks over <code>transfer()</code> or <code>send()</code> (see SCWE-079); <code>transfer()</code> has a 2300 gas stipend and can cause DoS when the recipient is a contract.</li> <li>Limit interactions with untrusted contracts and ensure robust validation before performing critical operations.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/","title":"SCSTG-TEST-0012: Test Token Implementations (ERC20, ERC721, ERC1155)","text":"","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#description","title":"Description","text":"<p>Component-Specific Security focuses on ensuring that each specific component of a decentralized application (dApp) or smart contract ecosystem is securely implemented. This includes a wide range of areas such as token standards (ERC20, ERC721, ERC1155), NFTs, vaults, liquidity pools, and other components. Properly securing these components is essential to avoid vulnerabilities that can lead to funds being stolen, lost, or misused. This test will focus on validating the security considerations for the components listed in the controls, ensuring that each one is implemented securely and with the appropriate mechanisms to protect users and assets.</p>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#test-ensure-proper-token-implementation-erc20-erc721-erc1155","title":"Test: Ensure Proper Token Implementation (ERC20, ERC721, ERC1155)","text":"","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#vulnerable-code","title":"**Vulnerable Code: **","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract SimpleERC20 {\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    string public name = \"Simple Token\";\n    string public symbol = \"STK\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    // Unchecked approve function (vulnerable to approval race condition)\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        return true;\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The <code>approve</code> function does not include a check for the current allowance before setting a new one, which could allow for the \"approval race condition.\" This can result in a vulnerability where an attacker could bypass the allowance mechanism and transfer more tokens than intended.  </li> <li>This issue is a well-known vulnerability in ERC20 token implementations.</li> </ul>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SafeERC20 {\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    string public name = \"Safe Token\";\n    string public symbol = \"STK\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    // Secure approve function to prevent race condition\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(amount == 0 || allowance[msg.sender][spender] == 0, \"Approve: non-zero allowance\");\n        allowance[msg.sender][spender] = amount;\n        return true;\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for the <code>approve</code> function in token contracts and ensure that it includes the necessary checks to prevent the race condition. The secure approach is to first set the allowance to zero before updating it to a new value, or to require that it is zero if being reset.</li> <li>Static Analysis: Use tools such as SolidityScan, MythX or Slither to check for the \"approval race condition\" and ensure the contract doesn't allow for this vulnerability.</li> <li>Dynamic Testing: Test token transfer functionality with edge cases where the allowance is set to non-zero values before calling <code>approve</code>. Verify that it works correctly and no unauthorized transfers are possible.</li> </ul>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/overview/","title":"Component-Specific Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#description","title":"Description","text":"<p>Component-specific security focuses on the proper implementation and management of individual components in a smart contract ecosystem, such as tokens, NFTs, vaults, staking mechanisms, and liquidity pools. Each component has unique security considerations that must be addressed to prevent vulnerabilities and ensure smooth, secure operations within the broader system. These components often interact with each other, so it's critical to ensure that each is implemented correctly and adheres to established standards to avoid risks such as inconsistent balances, unintended behavior, and attacks.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#example-erc20-token-security","title":"Example: ERC20 Token Security","text":"<pre><code>// Example: Implementing ERC20 token with minting and transfers\ncontract MyToken is ERC20 {\n    uint256 public totalSupply;\n\n    function mint(address to, uint256 amount) public {\n        totalSupply += amount;  // Ensure total supply is updated securely\n        _mint(to, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        require(amount &gt; 0, \"Cannot transfer zero amount\");\n        return super.transfer(recipient, amount);\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#component-specific-security","title":"Component-Specific Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#impact","title":"Impact","text":"<ul> <li>Token Vulnerabilities: Incorrect implementation of ERC20, ERC721, or ERC1155 tokens can lead to unexpected behavior, such as incorrect balances, inability to transfer tokens, or incompatible integrations with other dApps or services.</li> <li>NFT Security: Poorly implemented NFTs can lead to issues with metadata integrity, unauthorized minting, or unauthorized transfers, impacting the uniqueness and value of NFTs.</li> <li>Vault Risks: Issues related to asset management in vaults, such as stETH or wstETH, can cause delays in withdrawals or inconsistencies in the handling of token balances due to rebasing or other complex mechanisms.</li> <li>Liquid Staking Issues: Vulnerabilities in staking mechanisms (e.g., sfrxETH/fraxETH) could lead to discrepancies in rewards or affect the overall staking rewards distribution.</li> <li>Liquidity Pool Exploits: Automated market makers (AMMs) can be exploited if their logic is insecure, particularly regarding slippage, transaction fees, or impermanent loss calculations.</li> <li>Uniswap V4 Hook Vulnerabilities: Incorrect integration or usage of Uniswap's TickMath and FullMath libraries can introduce overflow or underflow issues, leading to unpredictable behavior or contract failures.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#remediation","title":"Remediation","text":"<ul> <li>Token Security: Ensure compliance with token standards such as ERC20, ERC721, and ERC1155. Properly manage the total supply and token addresses. Avoid zero-amount transfers causing issues and ensure compatibility with other contracts or integrations.</li> <li>NFT Best Practices: Implement strong standards for creating, managing, and transferring NFTs. Ensure metadata integrity and safeguard against unauthorized minting and transfers. Secure royalty payments and token burns to prevent exploitative behavior.</li> <li>Vault Management: Address potential withdrawal overheads and ensure efficient handling of assets such as stETH and wstETH. Take care when converting between rebasing tokens to avoid discrepancies.</li> <li>Staking Mechanisms: Regularly monitor and secure liquid staking mechanisms. Prevent discrepancies in reward transfers and ensure proper communication with users about potential changes, especially in the rate of tokens like sfrxETH.</li> <li>Liquidity Pool Security: Secure the logic in automated market makers, especially for managing slippage and ensuring fair fee distributions. Ensure that the AMM is protected against known exploits and attacks.</li> <li>Uniswap V4 Integration: Follow best practices for integrating Uniswap's TickMath and FullMath libraries, ensuring safe handling of arithmetic operations and proper validation to prevent overflow or underflow issues.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#types-of-vulnerabilities-that-can-occur-in-this-category","title":"Types of Vulnerabilities That Can Occur in This Category","text":"<ul> <li>Token Minting Inconsistencies: Incorrect updates to the totalSupply or failure to manage token addresses properly can cause inconsistencies and errors in token transactions.</li> <li>Unauthorized NFT Actions: Lack of metadata integrity or vulnerabilities in transfer mechanisms can result in unauthorized minting, transfers, or sales of NFTs.</li> <li>Vault Management Flaws: Issues like long withdrawal times or improper handling of rebasing assets can impact user experience and cause financial loss.</li> <li>Staking Discrepancies: Vulnerabilities in staking reward mechanisms or incorrect handling of rate changes can undermine user confidence and token stability.</li> <li>Liquidity Pool Exploits: Flaws in AMM contract logic, such as improper slippage management or failure to account for impermanent loss, can lead to loss of funds.</li> <li>Arithmetic Errors in Uniswap V4 Hooks: Insecure arithmetic operations using Uniswap's libraries can result in overflow/underflow vulnerabilities, affecting the stability and reliability of liquidity pools.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/","title":"SCSTG-TEST-0013: Secure Signature Verification","text":"","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#description","title":"Description","text":"<p>Cryptographic practices are essential in ensuring the confidentiality, integrity, and authenticity of interactions within decentralized systems. Weaknesses in cryptographic implementations, key management, or signature verification can lead to vulnerabilities such as unauthorized access, data manipulation, or attacks that compromise the security of transactions. This test focuses on verifying secure cryptographic practices, including key management, signature verification, and secure random number generation in smart contracts.</p>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#test-1-verify-secure-signature-verification","title":"Test 1: Verify Secure Signature Verification","text":"","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SignatureVerification {\n    function verifySignature(address _signer, bytes32 _message, bytes memory _signature) public pure returns (bool) {\n        // Directly using ecrecover, without checking for message format, leads to potential attack vectors\n        address recovered = ecrecover(_message, uint8(_signature[0]), bytes32(_signature[1]), bytes32(_signature[2]));\n        return recovered == _signer;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses <code>ecrecover</code> directly without verifying the message structure.</li> <li>Attackers could use a replay attack by reusing the signature from another message to authenticate different transactions.</li> <li>The lack of proper checks makes the contract vulnerable to attacks where the attacker can forge or replay signatures.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureSignatureVerification {\n    // Use of EIP-712 for standard signature verification with specific message formats\n    function verifySignature(address _signer, bytes32 _message, bytes memory _signature) public pure returns (bool) {\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _message));\n        address recovered = ecrecover(messageHash, uint8(_signature[0]), bytes32(_signature[1]), bytes32(_signature[2]));\n        return recovered == _signer;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Verify that signatures are being properly validated using standards like EIP-712, and that the contract uses <code>ecrecover</code> securely. Ensure that messages are hashed and prefixed correctly before recovery.</li> <li>Dynamic Testing: Test with replayed or malformed signatures to verify that the contract rejects such transactions.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract RandomNumberGenerator {\n    uint256 public randomValue;\n\n    function generateRandomNumber() public {\n        randomValue = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses block properties like <code>block.timestamp</code> and <code>block.difficulty</code> (post-merge: <code>block.prevrandao</code>) to generate random numbers, which can be manipulated by validators.</li> <li>This weak random number generation can lead to predictable values, making the contract vulnerable to attacks such as manipulation of lottery or gambling outcomes.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#fixed-code_1","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\n\ncontract SecureRandomNumberGenerator is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface immutable COORDINATOR;\n    uint64 immutable s_subscriptionId;\n    bytes32 immutable s_keyHash;\n    uint256 public randomValue;\n    uint256 public s_requestId;\n\n    constructor(\n        address vrfCoordinator,\n        uint64 subscriptionId,\n        bytes32 keyHash\n    ) VRFConsumerBaseV2(vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        s_subscriptionId = subscriptionId;\n        s_keyHash = keyHash;\n    }\n\n    function requestRandomNumber() external {\n        s_requestId = COORDINATOR.requestRandomWords(\n            s_keyHash,\n            s_subscriptionId,\n            3,      // requestConfirmations\n            100000, // callbackGasLimit\n            1      // numWords\n        );\n    }\n\n    function fulfillRandomWords(uint256, uint256[] memory randomWords) internal override {\n        randomValue = randomWords[0];\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Ensure that random numbers are not derived from predictable values like block properties. Check if external secure sources like <code>Chainlink VRF</code> are being used for randomness.</li> <li>Dynamic Testing: Test contract behavior under adversarial conditions to ensure the randomness cannot be predicted or manipulated.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/","title":"Cryptographic Practices","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#description","title":"Description","text":"<p>Cryptographic practices in smart contracts ensure that sensitive operations, such as authentication, data integrity, and randomness, are protected from malicious manipulation. Secure key management, signature verification, and proper random number generation are essential to prevent vulnerabilities like unauthorized access, replay attacks, and exploitation of weaknesses in cryptographic operations.</p> <p>Improper cryptographic practices can lead to severe consequences, including unauthorized transactions, predictable outcomes, and security breaches.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#example-improper-signature-verification","title":"Example: Improper Signature Verification","text":"<pre><code>function verifySignature(address signer, bytes32 message, bytes memory signature) public pure returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(message));\n    address recoveredSigner = ecrecover(messageHash, uint8(signature[64]), bytes32(signature[0]), bytes32(signature[32]));\n    return recoveredSigner == signer;\n}\n</code></pre> <p>In this example, the <code>ecrecover</code> function is used without ensuring that the signature is valid, which may lead to vulnerabilities like signature malleability or invalid data recovery.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#impact","title":"Impact","text":"<ul> <li>Unauthorized Access: Weak cryptographic practices can allow attackers to forge signatures or impersonate users, leading to unauthorized actions within the contract.</li> <li>Reentrancy Attacks: If cryptographic functions are used to validate external calls, attackers could exploit weak or improperly implemented logic to re-enter the contract.</li> <li>Manipulation of Outcomes: Predictable or weak random number generation could allow attackers to manipulate outcomes in systems relying on randomness, such as lotteries or gaming dApps.</li> <li>Replay Attacks: Insufficient signature validation can result in replay attacks where signed messages are reused across different contexts, allowing attackers to perform unintended actions.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#remediation","title":"Remediation","text":"<ul> <li>Key Management: Ensure that private keys are securely stored, never hardcoded in contracts, and use hardware solutions for key management.</li> <li>Signature Verification: Implement proper checks for signature validity, including handling signature malleability by using nonces or hashed messages.</li> <li>Randomness: Use secure sources of entropy, such as Chainlink VRF (Verifiable Random Function), to ensure the randomness cannot be manipulated.</li> <li>Compliance with Standards: Ensure compliance with cryptographic standards like EIP-712 to prevent signature malleability and other vulnerabilities.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/","title":"SCSTG-TEST-0014: Test Gas Usage in Loops","text":"","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#description","title":"Description","text":"<p>Efficient gas usage is critical in smart contract development to ensure transactions are cost-effective and do not exceed block gas limits. Poorly optimized contracts can result in high transaction costs, failed transactions, and potential denial of service (DoS) attacks. Optimizing gas usage helps ensure that smart contracts are scalable, cost-effective, and maintain the overall security of decentralized applications (dApps). This test focuses on ensuring that gas usage is properly optimized, and contracts are designed to operate efficiently within the constraints of Ethereum's gas limits.</p>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#test-1-validate-gas-usage-in-loops","title":"Test 1: Validate Gas Usage in Loops","text":"","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasInefficient {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        for (uint i = 0; i &lt; newData.length; i++) {\n            data.push(newData[i]);  // Inefficient loop causing high gas costs\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>This contract uses a loop to iterate over an input array and push data into a dynamic array.  </li> <li>The gas cost increases linearly with the size of the input array. For large datasets, this can lead to excessive gas usage, potentially causing the transaction to exceed the block gas limit.  </li> <li>Smart contracts with inefficient loops that grow dynamically can become unmanageable when interacting with large datasets.</li> </ul>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract OptimizedGas {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        uint256 length = newData.length;\n        for (uint i = 0; i &lt; length; i++) {\n            data.push(newData[i]);  // Optimized by storing array length outside the loop\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Ensure that loops and functions which deal with dynamic data structures are optimized for gas usage. Look for unnecessary state changes or excessive iterations within a single transaction.  </li> <li>Gas Estimation: Use tools like eth-gas-reporter or Remix IDE to estimate gas usage before and after optimizations.  </li> <li>Dynamic Testing: Test the contract with various input sizes and check that it performs within reasonable gas limits, ensuring it doesn't exceed the block gas limit.</li> </ul>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/","title":"Gas Usage, Efficiency, and Limitations","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#description","title":"Description","text":"<p>Gas usage optimization in smart contracts is crucial for maintaining cost-effective, efficient, and scalable decentralized applications (dApps) on the Ethereum network. Gas represents the computational cost of executing operations in smart contracts, and minimizing gas consumption ensures that transactions are processed smoothly without hitting gas limits or incurring unnecessary costs. Understanding how to optimize gas usage and effectively design contracts is essential for reducing overhead, ensuring transaction reliability, and preventing network congestion.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#example-code-without-gas-optimization","title":"Example: Code Without Gas Optimization","text":"<pre><code>// Example: Non-optimized contract with expensive operations\nfunction transfer(address recipient, uint256 amount) public {\n    require(balanceOf[msg.sender] &gt;= amount, \"Insufficient balance\");\n\n    balanceOf[msg.sender] -= amount;\n    balanceOf[recipient] += amount;\n\n    // Potentially costly operations (not optimized)\n    emit Transfer(msg.sender, recipient, amount);\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#impact","title":"Impact","text":"<ul> <li>High Gas Costs: Inefficient smart contracts lead to higher gas costs for users, resulting in increased transaction fees and potentially deterring interaction with the contract.</li> <li>Transaction Failures: Exceeding gas limits or inefficient use of gas can cause transactions to fail, resulting in reverted transactions and user dissatisfaction.</li> <li>Network Congestion: Unoptimized contracts can cause network congestion, especially during high traffic periods, leading to delays and higher fees.</li> <li>Scalability Limitations: As gas costs increase, the ability of the contract to handle a large number of transactions or users without hitting the gas limit is severely impacted.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#remediation","title":"Remediation","text":"<ul> <li>Gas Usage Optimization: Use efficient algorithms and reduce the number of computations performed on-chain. Avoid unnecessary state changes, and combine multiple operations where possible. Optimize loops, storage reads/writes, and event emissions to reduce costs.</li> <li>Gas Estimation Tools: Use tools like eth_gasPrice and gasStation to estimate gas prices and set appropriate gas limits for transactions. Implement gas estimation functions within the contract to predict and optimize gas usage.</li> <li>Layer 2 Solutions: Consider integrating Layer 2 scaling solutions such as rollups or state channels to offload computation and reduce gas costs while improving transaction throughput. Validate the security and reliability of the chosen Layer 2 solutions to ensure seamless integration.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/","title":"SCSTG-TEST-0015: Testing Business Logic and Economic Security","text":"","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#description","title":"Description","text":"<p>Business logic and economic security are crucial for ensuring that smart contracts function as intended and that the economic incentives align with the intended use cases. If vulnerabilities in the logic or economic models are present, attackers may exploit them for financial gain. This test focuses on reviewing economic models, incentive structures, and tokenomics to ensure that smart contracts are designed to prevent logic flaws, reentrancy attacks, and malicious economic manipulation.</p>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#test-1-ensure-economic-model-integrity-and-prevent-logic-flaws","title":"Test 1: Ensure Economic Model Integrity and Prevent Logic Flaws","text":"","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract IncentiveModel {\n    uint256 public rewardPool;\n\n    function distributeRewards(address[] memory users) public {\n        uint256 reward = rewardPool / users.length;  // Dividing the total reward pool among users\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            (bool ok, ) = payable(users[i]).call{value: reward}(\"\");\n            require(ok, \"Transfer failed\");\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>If the <code>users</code> array is empty, the division by zero will occur, leading to a runtime exception.</li> <li>Additionally, if the reward pool is too small or the number of users is too large, it could cause unexpected behavior, leading to attackers exploiting the system by flooding the contract with too many addresses.</li> </ul>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureIncentiveModel {\n    uint256 public rewardPool;\n\n    modifier nonZeroUsers(address[] memory users) {\n        require(users.length &gt; 0, \"No users provided\");\n        _;\n    }\n\n    function distributeRewards(address[] memory users) public nonZeroUsers(users) {\n        uint256 reward = rewardPool / users.length;\n        require(reward &gt; 0, \"Reward amount is too low\");\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            (bool ok, ) = payable(users[i]).call{value: reward}(\"\");\n            require(ok, \"Transfer failed\");\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for scenarios where division or mathematical operations could result in errors like division by zero or unintended behavior due to extreme input values.</li> <li>Dynamic Testing: Test the function with edge cases such as empty user lists, very large user arrays, and reward pool sizes. Ensure that the system handles these cases gracefully and does not allow unexpected errors or exploits.</li> </ul>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/overview/","title":"Business Logic and Economic Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#description","title":"Description","text":"<p>Business logic and economic security in smart contracts ensure that the contract's operational rules and the associated economic incentives are properly designed to avoid exploitation and inefficiencies. This includes defining incentive structures, ensuring the stability of token values, preventing reentrancy attacks, and making sure that the tokenomics aligns with the expected behavior of the system. Contracts must be designed to avoid logical flaws, ensure that token rewards and penalties are correctly implemented, and prevent attacks that could undermine the contract's economic model.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#example-improper-incentive-structure","title":"Example: Improper Incentive Structure","text":"<pre><code>// Push-based withdrawal process (vulnerable)\nfunction withdraw(uint256 amount) public {\n    require(balance[msg.sender] &gt;= amount, \"Insufficient balance\");\n    (bool ok, ) = msg.sender.call{value: amount}(\"\");\n    require(ok, \"Transfer failed\"); // Push-based transfer (prefer pull-based; see SCWE-079)\n    balance[msg.sender] -= amount;\n}\n</code></pre> <p>In the example above, a push-based withdrawal system may allow for unexpected behaviors, such as reentrancy attacks or failure to properly track balances due to uncontrolled fund transfers. A better approach would be to use a pull-based system.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#impact","title":"Impact","text":"<ul> <li>Incentive Misalignment: Incorrect economic models can lead to unbalanced incentives, where users may be encouraged to behave in ways that harm the ecosystem or undermine contract objectives.</li> <li>Volatility and Losses: Fluctuating token values, such as the conversion rates between assets like cbETH and ETH, can result in user losses if not properly handled. Similarly, staking rewards, such as with rETH, can create unpredictable value changes that impact users.</li> <li>Reentrancy Attacks: Poor handling of transaction flow and state changes can allow attackers to re-enter the contract during a transaction, causing unintended consequences like double withdrawals.</li> <li>Token Vulnerabilities: Incorrect tokenomics, such as faulty fee application or flawed reward systems, can cause users to lose funds or receive incorrect rewards.</li> <li>Double-Spending and Fraud: Weak mechanisms like duplicate Merkle proofs can expose the system to double-spending attacks and other fraud mechanisms.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#remediation","title":"Remediation","text":"<ul> <li>Incentive Structures: Implement a pull-based withdrawal system rather than push-based transfers to allow for proper tracking and reduce the risk of reentrancy attacks. Ensure that all economic incentives are clearly defined and aligned with desired behaviors.</li> <li>Tokenomics and Reward Systems: Ensure that all token behaviors, including rebase mechanisms and reward claims, are properly handled. Prevent unexpected behaviors in tokens and validate that all claimable addresses are included in hashing processes to prevent unauthorized claims.</li> <li>Fluctuation Management: Develop systems that can account for fluctuations in asset values (e.g., cbETH to ETH, rETH staking rewards) and adjust accordingly to mitigate risks for users.</li> <li>Transaction Flow Security: Use patterns like check-effect-interaction to prevent reentrancy attacks, ensuring that state changes occur before external calls. Apply the NonReentrant modifier where applicable to prevent unintended recursive calls.</li> <li>Function Integrity: Ensure that functions are designed to handle edge cases, such as same sender/recipient scenarios, and that they are not callable multiple times unnecessarily, avoiding potential inconsistencies or logic flaws.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/","title":"SCSTG-TEST-0016: Testing Arithmetic and Logic Security","text":"","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#description","title":"Description","text":"<p>Preventing arithmetic overflow and underflow is critical for maintaining the integrity and security of smart contracts. If a contract performs arithmetic operations without proper safeguards, it is vulnerable to overflow and underflow issues, which can be exploited by attackers to manipulate contract behavior, causing unexpected results or loss of funds.</p>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#test-1-ensure-safe-math-operations-are-used","title":"Test 1: Ensure Safe Math Operations are Used","text":"","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UnsafeMath {\n    uint256 public balance;\n\n    function addFunds(uint256 _amount) public {\n        balance += _amount;  // Possible overflow if balance + _amount exceeds max uint256 value\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<p>The contract does not use a safe math library to perform arithmetic operations. If the balance exceeds uint256's maximum value (2^256 - 1), an overflow occurs. This can result in unexpected contract behavior or a reset of the balance value, allowing attackers to manipulate the contract.</p>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SafeMath {\n    using SafeMath for uint256;\n    uint256 public balance;\n\n    function addFunds(uint256 _amount) public {\n        balance = balance.add(_amount);  // Safe addition using SafeMath to prevent overflow\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Check that all arithmetic operations use libraries such as SafeMath (for older versions) or rely on Solidity 0.8\u2019s built-in overflow checks.  </li> <li>Testing: Use edge cases such as adding large values to check if the contract prevents overflow.</li> </ul>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#test-2-verify-correct-use-of-fixed-point-arithmetic","title":"Test 2: Verify Correct Use of Fixed-Point Arithmetic","text":"","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract FixedPointExample {\n    uint256 public totalSupply;\n\n    function calculateReward(uint256 _rewardPercentage) public view returns (uint256) {\n        return totalSupply * _rewardPercentage / 100;  // Simple calculation without considering fixed-point precision\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<p>The function performs division without accounting for fixed-point precision. This could result in rounding errors, especially for small percentage values. Using integer division directly leads to truncation, causing inaccuracies in reward calculations.</p>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#fixed-code_1","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract FixedPointExample {\n    uint256 public totalSupply;\n    uint256 constant FIXED_POINT = 1e18;  // Set a scaling factor for fixed-point precision\n\n    function calculateReward(uint256 _rewardPercentage) public view returns (uint256) {\n        return (totalSupply * _rewardPercentage * FIXED_POINT) / 100 / FIXED_POINT;  // Proper fixed-point arithmetic\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Verify that fixed-point arithmetic is implemented using appropriate scaling factors (e.g., 1e18) to avoid precision loss.  </li> <li>Dynamic Testing: Test the function with small values for <code>_rewardPercentage</code> and check that the result is accurate, verifying that there is no unexpected rounding behavior.</li> </ul>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/","title":"Arithmetic and Logic Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#description","title":"Description","text":"<p>Arithmetic and logic security in smart contracts ensures that mathematical operations are performed safely and with integrity. These operations must be protected against overflows, underflows, precision loss, and other logical errors that could lead to unexpected behaviors, vulnerabilities, or financial losses. Proper handling of arithmetic operations, particularly for asset balances, time units, and fixed-point calculations, is critical for ensuring the stability and security of smart contracts. This also includes managing preconditions and postconditions to ensure correct function execution and preventing vulnerabilities such as division by zero or off-by-one errors.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#example-preventing-overflow-and-underflow","title":"Example: Preventing Overflow and Underflow","text":"<pre><code>// SafeMath library example to prevent overflow/underflow\nusing SafeMath for uint256;\n\nfunction transfer(uint256 amount) public {\n    require(balance[msg.sender] &gt;= amount, \"Insufficient balance\");\n    balance[msg.sender] = balance[msg.sender].sub(amount); // Safe subtraction\n    balance[recipient] = balance[recipient].add(amount);  // Safe addition\n}\n</code></pre> <p>In this example, <code>SafeMath</code> is used to protect against integer overflow and underflow, ensuring that operations on token balances are secure.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#impact","title":"Impact","text":"<ul> <li>Overflow/Underflow Vulnerabilities: If arithmetic operations are not properly checked, they can result in overflows or underflows, causing unexpected behavior such as funds being transferred incorrectly, variables being set to incorrect values, or transactions failing.</li> <li>Precision Loss: In fixed-point arithmetic or when performing calculations with time units, rounding errors or precision loss can lead to inaccuracies, especially when working with fractional values in tokenomics or financial systems.</li> <li>Data Corruption: Incorrect handling of data types, arrays, or structs can cause data corruption or incorrect values, potentially leading to logic flaws or vulnerabilities.</li> <li>Manipulated Calculations: If critical calculations (e.g., price or rate calculations) are not secure, attackers could exploit vulnerabilities (e.g., through flash loans) to manipulate values and disrupt the contract\u2019s logic.</li> <li>Transaction Failures: Incorrectly handled division by zero or exceeding variable bounds can lead to transaction reverts or failures, disrupting contract operations and causing loss of user funds.</li> <li>Logical Errors: Incorrect use of logical operators or off-by-one errors in loops can cause unintended contract behavior, which might open doors for exploits or cause incorrect results in financial operations.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#remediation","title":"Remediation","text":"<ul> <li>Overflow/Underflow Protection: Always use SafeMath or similar libraries for arithmetic operations to prevent overflow and underflow issues. Explicit type casting and operations within <code>unchecked{}</code> blocks should be carefully managed.</li> <li>Fixed-Point Arithmetic: Ensure that fixed-point arithmetic operations are conducted safely to avoid overflow, underflow, or loss of precision. Validate calculations involving fixed-point numbers to maintain accuracy.</li> <li>Secure Calculations: Ensure that price, rate, or financial calculations are protected against manipulation, especially from attacks like flash loans. Handle asset balance calculations securely to prevent vulnerabilities.</li> <li>Logical Consistency: Enforce proper rounding rules in calculations, validate inequalities and comparisons, and handle edge cases properly in logical operations.</li> <li>Pre/Post-condition Checks: Apply precondition checks to avoid invalid calculations and ensure that multiplication is performed before division to maintain precision. Validate edge cases such as minimum transaction amounts and off-by-one errors in loops.</li> <li>Correct Data Handling: Avoid unintended data type conversions or precision loss. Ensure that <code>abi.decode</code> is used within type limits to prevent overflows.</li> </ul>","tags":[]},{"location":"SCSVS/01-Frontispiece/","title":"Frontispiece","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#about-the-standard","title":"About the Standard","text":"<p>The Smart Contract Security Verification Standard (SCSVS) is a list of specific security requirements or tests for smart contracts, primarily written in Solidity and deployed on EVM-based blockchains. These requirements are intended to be used by architects, developers, testers, security professionals, tool vendors, and consumers to define, build, test, and verify secure smart contracts, decentralized applications (dApps) and blockchain protocols. The standard promotes best practices for ensuring the security and integrity of smart contracts and decentralized finance (DeFi) systems.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#copyright-and-license","title":"Copyright and License","text":"<p>Version 0.0.1 (Bleeding Edge version), 2024</p> <p></p> <p>Copyright \u00a9 2008-2026 The OWASP Foundation. This document is released under the Creative Commons Attribution-ShareAlike 4.0 International License. For any reuse or distribution, you must make clear to others the license terms of this work.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#project-leads","title":"Project Leads","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#shashank-credshields","title":"Shashank (CredShields)","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#major-contributors-and-reviewers","title":"Major Contributors and Reviewers","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#pratik-lagaskar","title":"Pratik Lagaskar","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#nehal-pillai","title":"Nehal Pillai","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#aditya-dixit","title":"Aditya Dixit","text":"<p>If a credit is missing from the 0.0.1 credit list above, please log a ticket at GitHub to be recognized in future 0.x updates.</p> <p>The Smart Contract Security Verification Standard (SCSVS) is built upon the initial research performed into smart contract security by various blockchain security experts. Much of the concept, structure, boilerplate, and tooling for the SCSVS has been adapted from the OWASP ASVS project. We extend our gratitude to all those previously involved in the OWASP ASVS for their contributions.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#major-supporter-and-sponsor","title":"Major Supporter and Sponsor","text":"<p>This initiative would not have been possible without the support of our sponsor and the resources they have provided. We would like to express our gratitude to the following for their support.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#credshields","title":"CredShields","text":"<p>The OWASP SCSVS project was initiated to share the knowledge gained from the CredShields Security Team's research into Smart Contract security while developing SolidityScan.com, an AI-powered vulnerability scanner for Smart Contracts. We extend our gratitude to CredShields for their efforts in defining the initial requirements and founding this project.</p>","tags":[]},{"location":"SCSVS/02-Preface/","title":"Preface","text":"<p>Welcome to the alpha release of the OWASP Smart Contract Security Verification Standard (SCSVS), which serves as a framework for assessing the security of smart contracts built on Ethereum Virtual Machine (EVM)-based blockchains, specifically those developed using Solidity.</p> <p>Smart contracts are autonomous programs that execute on decentralized blockchain networks, facilitating a wide range of applications, including decentralized finance (DeFi), governance systems, and tokenized assets. However, the immutability and high-value nature of blockchain ecosystems introduce unique risks and challenges. This makes security in smart contract development not only critical but also highly specialized.</p> <p>The SCSVS aims to provide comprehensive, actionable guidelines that support developers, auditors, security professionals, and architects in building and maintaining secure smart contracts, particularly within the Solidity ecosystem on EVM-based blockchains. It seeks to address common and emerging vulnerabilities, such as reentrancy attacks, integer overflows/underflows, gas optimization issues, and economic attacks\u2014all of which pose significant risks to smart contract security and user trust.</p> <p>This alpha release is the result of a collaborative effort by professionals and experts across various sectors, including blockchain security, financial technology, and decentralized application (dApp) development. The SCSVS is designed to offer flexible and evolving guidance for securing smart contracts, addressing both functional and non-functional security aspects.</p>","tags":[]},{"location":"SCSVS/02-Preface/#scope-and-purpose","title":"Scope and Purpose","text":"<p>The SCSVS provides detailed verification requirements that focus on the design, implementation, and testing phases of smart contract development. It seeks to guide stakeholders through:</p> <ul> <li>Designing with security in mind: Ensuring that security is a core principle during the planning stages of smart contract development.</li> <li>Implementing secure coding practices: Emphasizing Solidity-specific security measures to mitigate risks inherent to the EVM environment.</li> <li>Auditing and Testing: Offering best practices for conducting rigorous security audits, penetration testing, and ongoing monitoring of smart contracts once deployed.</li> </ul> <p>This standard is particularly relevant for developers who work on DeFi protocols, token contracts, decentralized exchanges (DEXs), and any application that interacts with assets or governance in a decentralized manner. Its guidelines are aligned with the broader needs of the Ethereum and EVM-based blockchain ecosystems, though many principles apply to other smart contract platforms as well.</p>","tags":[]},{"location":"SCSVS/02-Preface/#a-collaborative-effort","title":"A Collaborative Effort","text":"<p>The security challenges facing smart contract developers are constantly evolving, as adversaries seek new ways to exploit weaknesses in decentralized systems. The SCSVS alpha release is designed to be a starting point, and we openly invite contributions from the community to help expand, refine, and adapt these guidelines.</p> <p>We understand that no security standard can be entirely comprehensive, especially in the dynamic field of blockchain technology, which is rapidly advancing. The aim is to foster collaboration and continuous improvement. Your feedback and active participation will be invaluable in ensuring that the SCSVS remains practical, effective, and up to date with emerging threats and technologies.</p>","tags":[]},{"location":"SCSVS/02-Preface/#looking-ahead","title":"Looking Ahead","text":"<p>The OWASP Smart Contract Security Verification Standard is not a final document. This alpha release is the foundation for a living standard that will grow and adapt with the needs of the community and advances in smart contract development. We encourage the community to engage actively with this project\u2014whether by contributing ideas, identifying gaps, or proposing enhancements.</p> <p>In the spirit of OWASP\u2019s mission, this standard seeks to improve the security posture of the smart contract ecosystem, safeguarding both developers and users alike. We sincerely thank all contributors, and we look forward to your continued support in shaping the future of secure smart contract development.</p> <p>Together, we can build a safer decentralized future.</p>","tags":[]},{"location":"SCSVS/03-Using-SCSVS/","title":"Utilizing the SCSVS","text":"<p>The OWASP Smart Contract Security Verification Standard (SCSVS) serves several key purposes:</p> <ul> <li> <p>Assisting Development Teams: Guide smart contract developers in designing, implementing, and maintaining secure decentralized applications (dApps) and contracts, particularly on EVM-based blockchains.</p> </li> <li> <p>Framework for Security Teams: Assist security professionals in setting requirements, conducting security audits, and performing penetration tests against smart contract systems to ensure they meet robust security standards.</p> </li> <li> <p>Aligning Security Benchmarks: Establish a common security framework that can be adopted by blockchain platforms, vendors, developers, and clients regarding security expectations in smart contracts and decentralized applications.</p> </li> </ul>","tags":[]},{"location":"SCSVS/03-Using-SCSVS/#security-verification-layers","title":"Security Verification Layers","text":"<p>The SCSVS categorizes security verification into three distinct levels, each aimed at different levels of security assurance in smart contract development and deployment:</p> <ol> <li> <p>SCSVS Level 1 - Basic Security: This level is designed for smart contracts with lower security risks. It focuses on fundamental security controls, ensuring baseline protection for any decentralized application.</p> </li> <li> <p>SCSVS Level 2 - Moderate Security: Ideal for smart contracts that handle sensitive data, financial transactions, or are part of a DeFi ecosystem. Level 2 provides a more balanced approach to security, addressing common vulnerabilities like reentrancy attacks, gas inefficiencies, and access control weaknesses.</p> </li> <li> <p>SCSVS Level 3 - High Assurance Security: This level is tailored for mission-critical smart contracts where significant financial assets, governance, or high-value transactions are at stake. Level 3 ensures extensive security measures and covers advanced protections such as formal verification, multi-signature wallets, and decentralized governance.</p> </li> </ol> <p>Each level of the SCSVS provides a detailed set of security requirements, mapping these to essential security features and practices needed to build secure smart contracts. Whether developing, auditing, or deploying smart contracts, the SCSVS offers a clear roadmap to help teams at every stage.</p>","tags":[]},{"location":"SCSVS/03-Using-SCSVS/#assumptions","title":"Assumptions","text":"<p>When utilizing the SCSVS, it's important to consider the following assumptions:</p> <ul> <li> <p>The SCSVS is not a replacement for standard secure development practices such as secure coding or following a Secure Software Development Life Cycle (SSDLC). It should complement these practices by addressing specific security needs for EVM-based smart contracts and decentralized applications.</p> </li> <li> <p>The SCSVS is not intended to replace comprehensive threat modeling or security reviews. It serves as a specialized guide to help identify and mitigate vulnerabilities unique to smart contracts. Employing the SCSVS should enhance, not replace, traditional security risk assessments and penetration tests.</p> </li> </ul> <p>While the SCSVS offers a solid framework for improving the security of smart contracts, it cannot ensure complete security on its own. It should be considered a foundational security standard, with additional protective measures added as necessary to address specific vulnerabilities and evolving threats in decentralized environments.</p>","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/","title":"Assessment and Certification","text":"","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/#owasps-stance-on-scsvs-certifications-and-trust-marks","title":"OWASP's Stance on SCSVS Certifications and Trust Marks","text":"<p>OWASP, as a vendor-neutral not-for-profit organization, does not currently certify any vendors, verifiers, or smart contracts.</p> <p>All such assurance assertions, trust marks, or certifications are not officially vetted, registered, or certified by OWASP. Therefore, organizations relying on third-party verification or certifications must carefully evaluate the trust placed in any external entity or trust mark claiming Smart Contract Security Verification Standard (SCSVS) certification.</p> <p>This should not discourage organizations from offering security verification or audit services, as long as they do not claim to provide official OWASP certification.</p>","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/#guidance-for-certifying-organizations","title":"Guidance for Certifying Organizations","text":"<p>For Smart Contract Security Verification Standard (SCSVS) compliance, an \"open book\" review is recommended, where assessors are granted access to essential resources such as smart contract developers, project documentation, source code, and authenticated blockchain interfaces (including access to the blockchain explorer, transaction logs, and testing environments). It's essential that assessors gain access to at least one account for each user role, particularly if the contract supports permissioned or role-based access.</p> <p>It is important to note that the SCSVS only covers the security requirements specific to EVM-based smart contracts and does not extend to general application security controls (e.g., web interfaces, databases, or other non-blockchain components). Any additional systems or non-blockchain elements should be verified against appropriate security standards, such as the OWASP ASVS.</p>","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/#certification-reports","title":"Certification Reports","text":"<p>Certification reports should clearly define the scope of the verification, specifying which smart contracts, components, or decentralized applications (dApps) were reviewed, and should list any excluded items from the review. The report should summarize the findings, detailing both passed and failed security controls, alongside guidance on how to remediate any failures.</p> <p>Industry-standard practices for security certification require thorough documentation of the verification process. This should include:</p> <ul> <li>Work papers: Notes and records on each step of the verification process.</li> <li>Screenshots: Evidence of security control tests, such as transaction hashes or audit results.</li> <li>Scripts: Used for testing and replication of discovered issues.</li> <li>Blockchain logs: Detailed records of the verification process including contract interactions, transactions, and gas usage.</li> </ul> <p>Automated tools alone are insufficient to verify SCSVS compliance. All verification reports must provide conclusive, manually validated evidence that demonstrates the thorough and accurate testing of all required controls. In case of disputes, documentation should include adequate evidence to confirm that each control has been appropriately tested and validated.</p>","tags":[]},{"location":"SCSVS/05-SCSVS-ARCH/","title":"S1. Architecture, Design, and Threat Modeling","text":"","tags":[]},{"location":"SCSVS/05-SCSVS-ARCH/#control-objective","title":"Control Objective","text":"<p>Establish a robust architectural foundation and design framework that incorporates threat modeling and security best practices. The goal is to proactively identify and mitigate potential vulnerabilities during the early stages of smart contract development. This ensures the system's scalability, security, and efficiency, while adhering to the principles of secure Solidity coding and deployment.</p>","tags":[]},{"location":"SCSVS/06-SCSVS-CODE/","title":"S2. Policies, Procedures, and Code Management","text":"","tags":[]},{"location":"SCSVS/06-SCSVS-CODE/#control-objective","title":"Control Objective","text":"<p>Ensure that development policies and procedures are in place to promote secure coding practices, thorough code reviews, and comprehensive testing. The aim is to prevent vulnerabilities and enhance the maintainability and clarity of smart contract code.</p>","tags":[]},{"location":"SCSVS/07-SCSVS-GOV/","title":"S3. Business Logic and Economic Security","text":"","tags":[]},{"location":"SCSVS/07-SCSVS-GOV/#control-objective","title":"Control Objective","text":"<p>Ensure that the smart contract's business logic and economic security are resilient against threats related to incentive structures, tokenomics, and logic vulnerabilities. Contracts should prevent abuse, misbehavior, or unexpected behaviors by implementing secure economic models, token handling, and transaction integrity.</p>","tags":[]},{"location":"SCSVS/08-SCSVS-AUTH/","title":"S4. Access Control and Authentication","text":"","tags":[]},{"location":"SCSVS/08-SCSVS-AUTH/#control-objective","title":"Control Objective","text":"<p>Establish robust access control and authentication mechanisms to ensure that only authorized entities can perform sensitive operations within the smart contract. This includes implementing role-based access control (RBAC), secure authorization mechanisms, and decentralized identity management.</p>","tags":[]},{"location":"SCSVS/09-SCSVS-COMM/","title":"S5. Secure Interactions and Communications","text":"","tags":[]},{"location":"SCSVS/09-SCSVS-COMM/#control-objective","title":"Control Objective","text":"<p>Establish secure interaction protocols for smart contracts to ensure safe communication between contracts, external oracles, and cross-chain integrations. This includes managing contract interactions, securing oracle integrations, handling cross-chain interactions, and ensuring the security of bridges.</p>","tags":[]},{"location":"SCSVS/10-SCSVS-CRYPTO/","title":"S6. Cryptographic Practices","text":"","tags":[]},{"location":"SCSVS/10-SCSVS-CRYPTO/#control-objective","title":"Control Objective","text":"<p>Establish secure cryptographic practices for managing keys, verifying signatures, and generating random numbers to protect the integrity and authenticity of transactions and data within smart contracts.</p>","tags":[]},{"location":"SCSVS/11-SCSVS-ORACLE/","title":"S7. Arithmetic and Logic Security","text":"","tags":[]},{"location":"SCSVS/11-SCSVS-ORACLE/#control-objective","title":"Control Objective","text":"<p>Establish secure arithmetic and logic practices to prevent vulnerabilities such as overflow/underflow and ensure the integrity of calculations within smart contracts.</p>","tags":[]},{"location":"SCSVS/12-SCSVS-BLOCK/","title":"S8. Denial of Service (DoS)","text":"","tags":[]},{"location":"SCSVS/12-SCSVS-BLOCK/#control-objective","title":"Control Objective","text":"<p>Establish practices and mechanisms to prevent Denial of Service (DoS) attacks that can disrupt contract functionality and availability.</p>","tags":[]},{"location":"SCSVS/13-SCSVS-BRIDGE/","title":"S9. Blockchain Data and State Management","text":"","tags":[]},{"location":"SCSVS/13-SCSVS-BRIDGE/#control-objective","title":"Control Objective","text":"<p>Establish practices for effective management of blockchain data and state to ensure security, efficiency, and integrity of contract interactions.</p>","tags":[]},{"location":"SCSVS/14-SCSVS-DEFI/","title":"S10. Gas Usage, Efficiency, and Limitations","text":"","tags":[]},{"location":"SCSVS/14-SCSVS-DEFI/#control-objective","title":"Control Objective","text":"<p>Establish practices for optimizing gas usage and efficiency in smart contracts to minimize costs and enhance performance.</p>","tags":[]},{"location":"SCSVS/15-SCSVS-COMP/","title":"S11. Component-Specific Security","text":"","tags":[]},{"location":"SCSVS/15-SCSVS-COMP/#control-objective","title":"Control Objective","text":"<p>Establish security practices and standards for various blockchain components to mitigate specific vulnerabilities associated with tokens, NFTs, vaults, and liquidity pools.</p>","tags":[]},{"location":"SCSVS/16-Appendix-A_Glossary/","title":"Appendix A: Glossary","text":"<ul> <li> <p>Access Control \u2013 Mechanisms that restrict access to a system, application, or data to authorized users or entities. In smart contracts, access control is crucial for ensuring that only permitted users can perform sensitive actions.</p> </li> <li> <p>Arithmetic Operations \u2013 Basic mathematical operations (addition, subtraction, multiplication, division) performed in smart contracts. Proper handling of these operations is vital to prevent overflow and underflow vulnerabilities.</p> </li> <li> <p>Audit \u2013 A systematic examination of smart contracts to evaluate their security, functionality, and compliance with specified requirements. Audits help identify vulnerabilities and ensure adherence to best practices.</p> </li> <li> <p>Bytecode \u2013 The low-level code generated from Solidity (or other high-level languages) that is executed on the Ethereum Virtual Machine (EVM). Understanding bytecode is essential for analyzing contract behavior.</p> </li> <li> <p>Denial of Service (DoS) \u2013 An attack aimed at making a smart contract or service unavailable to its intended users, often by consuming excessive resources or exploiting vulnerabilities to cause failures in execution.</p> </li> <li> <p>Fallback Function \u2013 A default function in a smart contract that is executed when a contract receives Ether without any accompanying data or when a function that doesn\u2019t exist is called. Proper design of fallback functions is important to prevent security issues.</p> </li> <li> <p>Gas \u2013 A unit that measures the computational work required to execute operations on the Ethereum blockchain. Gas fees incentivize miners and limit the complexity of transactions.</p> </li> <li> <p>Gas Limit \u2013 The maximum amount of gas a user is willing to pay for a transaction, impacting the transaction's likelihood of being included in a block.</p> </li> <li> <p>Layer 2 Solutions \u2013 Technologies built on top of existing blockchains to enhance scalability and reduce transaction costs. Examples include state channels and rollups, which alleviate congestion on the main chain.</p> </li> <li> <p>Minting \u2013 The process of creating new tokens or assets and assigning them to a specified address. This operation must be carefully managed to ensure compliance with token standards.</p> </li> <li> <p>Non-Fungible Token (NFT) \u2013 A unique digital asset that represents ownership of a specific item or piece of content, distinguished by its distinct characteristics, making it irreplaceable.</p> </li> <li> <p>Overflows and Underflows \u2013 Vulnerabilities that occur when arithmetic operations exceed the maximum or minimum value of a data type, leading to unexpected behavior. Safe math libraries help prevent these issues.</p> </li> <li> <p>Reentrancy \u2013 A vulnerability where a function makes an external call to another contract before completing its execution, potentially allowing the second contract to manipulate the state of the first contract before it finishes processing.</p> </li> <li> <p>Security Audit \u2013 A comprehensive review and evaluation of a smart contract\u2019s code to identify vulnerabilities, inefficiencies, and compliance with best practices.</p> </li> <li> <p>Smart Contract \u2013 A self-executing contract with the terms of the agreement directly written into code and deployed on a blockchain. Smart contracts automate execution without the need for intermediaries.</p> </li> <li> <p>Token Standard \u2013 Specifications that define how tokens should function on a blockchain. Common standards include ERC20 for fungible tokens, ERC721 for non-fungible tokens, and ERC1155 for multi-token standards.</p> </li> <li> <p>Transaction Confirmation \u2013 The process by which a transaction is validated and recorded on the blockchain. A transaction must be confirmed by validators (or miners on PoW chains) to be considered final and irreversible.</p> </li> <li> <p>Vulnerability \u2013 A weakness in a smart contract that can be exploited by an attacker, leading to unauthorized access, data breaches, or financial loss.</p> </li> <li> <p>Whitelisting \u2013 A security practice where specific addresses or entities are granted permission to interact with a contract, enhancing access control and mitigating potential attacks.</p> </li> <li> <p>Zero-Knowledge Proofs \u2013 Cryptographic methods that allow one party to prove to another that they know a value without revealing the value itself. This is used to enhance privacy in blockchain transactions.</p> </li> <li> <p>Audit Trail \u2013 A chronological record that tracks the sequence of activities and changes made to a smart contract, providing transparency and accountability.</p> </li> <li> <p>ERC Standards \u2013 Ethereum Request for Comments; a series of technical documents that provide guidelines and specifications for the development of smart contracts and tokens on the Ethereum blockchain.</p> </li> <li> <p>Decentralized Finance (DeFi) \u2013 A financial ecosystem that operates without central authorities, using smart contracts on blockchains to provide financial services like lending, borrowing, and trading.</p> </li> <li> <p>Oracle \u2013 A third-party service that provides external data to smart contracts, enabling them to interact with real-world information such as prices, events, or weather data.</p> </li> <li> <p>Tokenomics \u2013 The study of the economic model and incentive structures behind cryptocurrencies and tokens, including supply, demand, and the distribution of tokens.</p> </li> <li> <p>Gas Optimization \u2013 Techniques and practices aimed at reducing the gas consumption of smart contracts, thereby lowering transaction costs and improving efficiency.</p> </li> <li> <p>Atomic Swap \u2013 A smart contract technology that enables the exchange of one cryptocurrency for another without the need for a trusted third party, ensuring security and trustlessness.</p> </li> <li> <p>Cryptographic Hash Function \u2013 A mathematical algorithm that transforms input data into a fixed-size string of characters, which is unique to each unique input. This function is crucial for ensuring data integrity in blockchain.</p> </li> <li> <p>State Machine \u2013 A model that represents the state of a smart contract and its transitions, allowing for tracking of the current state and the possible changes based on events and actions.</p> </li> <li> <p>Gas Refund \u2013 A mechanism that allows users to recover some of the gas fees spent on certain operations, particularly those that free up storage space on the blockchain.</p> </li> <li> <p>Contract Upgradeability \u2013 The ability to modify or replace a smart contract after its deployment to fix bugs or add new features, often implemented through proxy patterns.</p> </li> <li> <p>Security Vulnerability Disclosure \u2013 A responsible disclosure process where security researchers report vulnerabilities found in smart contracts to the developers, allowing them to address the issues before public knowledge.</p> </li> <li> <p>Interoperability \u2013 The capability of different blockchain networks and smart contracts to communicate and interact with each other, enabling seamless integration of services and assets across platforms.</p> </li> </ul>","tags":[]},{"location":"SCSVS/17-Appendix-B_References/","title":"Appendix B: References","text":"<p>The following OWASP projects are most likely to be useful to users/adopters of this standard:</p>","tags":[]},{"location":"SCSVS/17-Appendix-B_References/#owasp-core-projects","title":"OWASP Core Projects","text":"<ol> <li>OWASP Top 10 Project</li> <li>OWASP Smart Contract Top 10 Project</li> </ol>","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/","title":"SCSVS-ARCH-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12-proxy-patterns","title":"S1.2 Proxy Patterns","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#control-objective","title":"Control Objective","text":"<p>Ensure that proxy patterns and upgrade mechanisms are implemented securely and managed properly, to mitigate risks during contract upgrades, deprecations, and transitions between contract versions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#security-verification-requirements","title":"Security Verification Requirements","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12a-upgrade-mechanisms","title":"S1.2.A Upgrade Mechanisms","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 R SWE S1.2.A1 Verify that an upgrade mechanism (e.g., proxy pattern) is implemented for the contract. \u2713 \u2713 S1.2.A2 Ensure that the upgrade process includes safeguards against unauthorized upgrades. \u2713 \u2713 S1.2.A3 Check that the upgrade mechanism is documented and reviewed for security. \u2713 \u2713 S1.2.A4 Verify that immutable variables are consistent across implementations during proxy upgrades to prevent misuse. \u2713 S1.2.A5 Verify that <code>selfdestruct</code> and <code>delegatecall</code> in implementation contracts do not introduce vulnerabilities or unexpected behaviors in a proxy setup. \u2713 S1.2.A6 Verify that UUPSUpgradeable contracts are protected against vulnerabilities that may affect uninitialized implementation contracts, ensuring secure upgrade mechanisms. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12b-managing-deprecation","title":"S1.2.B Managing Deprecation","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 R SWE S1.2.B1 Verify that deprecated contract versions are correctly marked and handled. \u2713 S1.2.B2 Ensure that access to deprecated versions is restricted or disabled. \u2713 S1.2.B3 Check that migration paths from deprecated versions to new versions are secure. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12c-transparent-vs-opaque-proxies","title":"S1.2.C Transparent vs. Opaque Proxies","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 R SWE S1.2.C1 Verify whether a transparent or opaque proxy pattern is used and its suitability for the contract. \u2713 \u2713 S1.2.C2 Ensure that the proxy pattern is correctly implemented and does not introduce vulnerabilities. \u2713 \u2713 S1.2.C3 Check that the proxy pattern\u2019s choice is documented and justified. \u2713 \u2713 S1.2.C4 Ensure that uninitialized contracts cannot be taken over by attackers and that initialization functions are secured with the correct modifiers. \u2713 S1.2.C5 Verify that <code>TransparentUpgradeableProxy</code> and similar proxy patterns handle selector clashes and non-decodable calldata correctly to maintain transparency. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/","title":"SCSVS-ARCH-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13-threat-modeling","title":"S1.3 Threat Modeling","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#control-objective","title":"Control Objective","text":"<p>Identify, assess, and mitigate security threats for smart contract systems by implementing a thorough threat modeling process, ensuring that risks are minimized and protections are in place for critical contract features.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#security-verification-requirements","title":"Security Verification Requirements","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13a-identifying-threats","title":"S1.3.A Identifying Threats","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S1.3.A1 Verify that potential threats are identified and documented. \u2713 \u2713 \u2713 S1.3.A2 Ensure that the threat identification process includes input from security experts. \u2713 \u2713 S1.3.A3 Check that threats are categorized based on their impact and likelihood. \u2713 \u2713 S1.3.A4 Implement protections against front-running in governor proposal creation to prevent attackers from blocking proposals or gaining undue advantages. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13b-assessing-risks","title":"S1.3.B Assessing Risks","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S1.3.B1 Verify that risk assessments are performed for identified threats. \u2713 \u2713 S1.3.B2 Ensure that risks are prioritized based on their potential impact and likelihood. \u2713 \u2713 S1.3.B3 Check that risk assessment results are documented and reviewed. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13c-implementing-mitigations","title":"S1.3.C Implementing Mitigations","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S1.3.C1 Verify that mitigations are implemented for high-priority risks. \u2713 \u2713 S1.3.C2 Ensure that mitigation strategies are documented and tested. \u2713 \u2713 S1.3.C3 Check that the effectiveness of implemented mitigations is reviewed and validated. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/","title":"SCSVS-AUTH-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41-role-based-access-control-rbac","title":"S4.1 Role-Based Access Control (RBAC)","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#control-objective","title":"Control Objective","text":"<p>Implement role-based access control to manage permissions and ensure that only authorized users can access specific functions. This includes validating identities, applying the least privilege principle, and ensuring appropriate access controls are in place.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41a-multi-signature-schemes","title":"S4.1.A Multi-Signature Schemes","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.1.A1 Ensure that the visibility modifier for all functions is appropriate, preventing unnecessary exposure of internal functions. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41b-identity-verification","title":"S4.1.B Identity Verification","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.1.B1 Validate that unexpected addresses do not result in unintended behaviors, particularly when these addresses refer to contracts within the same protocol. \u2713 \u2713 S4.1.B2 Verify that functions like ecrecover handle all potential null addresses properly to avoid vulnerabilities arising from unexpected ecrecover outputs. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41c-least-privilege-principle","title":"S4.1.C Least Privilege Principle","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.1.C1 Use msg.sender (not tx.origin) for authorization to avoid phishing via malicious intermediary contracts. Optionally, require(tx.origin == msg.sender) restricts callers to EOAs only \u2014 use only when EOA-only access is explicitly required. \u2713 \u2713 S4.1.C2 Certain addresses might be blocked or restricted from receiving tokens (e.g., LUSD). Ensure that address restrictions are properly managed and verified. \u2713 \u2713 S4.1.C3 Ensure that Guard\u2019s hooks (e.g., checkTransaction(), checkAfterExecution()) are executed to enforce critical security checks. \u2713 \u2713 S4.1.C4 Ensure that access controls are implemented correctly to determine who can use certain functions, and avoid unauthorized changes or withdrawals. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/","title":"SCSVS-AUTH-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#s42-authorization-mechanisms","title":"S4.2 Authorization Mechanisms","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#control-objective","title":"Control Objective","text":"<p>Implement secure authorization mechanisms to safeguard critical functions and sensitive operations, ensuring only authorized entities can perform these actions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#s42a-secure-access-to-critical-functions","title":"S4.2.A Secure Access to Critical Functions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.2.A1 Verify that the contract uses msg.sender for authorization instead of tx.origin to avoid vulnerabilities related to contracts that forward calls from legitimate users. \u2713 \u2713 S4.2.A2 Implement and verify appropriate access controls for functions that modify contract state or perform sensitive operations to prevent unauthorized access. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#s42b-timed-permissions","title":"S4.2.B Timed Permissions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.2.B1 Ensure that msg.sender validation is properly implemented when using Merkle trees to maintain security and prevent unauthorized access. \u2713 \u2713 S4.2.B2 Use whitelisting to restrict interactions to a specific set of addresses, providing additional security against malicious actors. \u2713 \u2713 S4.2.B3 Ensure that functions modifying the contract state or accessing sensitive operations have proper access controls implemented. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/","title":"SCSVS-AUTH-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#s43-decentralized-identity","title":"S4.3 Decentralized Identity","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#control-objective","title":"Control Objective","text":"<p>Implement decentralized identity solutions to ensure secure and reliable identity verification and management while maintaining user privacy.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#s43a-decentralized-identifiers-dids","title":"S4.3.A Decentralized Identifiers (DIDs)","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.3.A1 Verify that the smart contract for handling DIDs adheres to the latest standards and best practices for decentralized identity management. \u2713 \u2713 S4.3.A2 Ensure that the DID management contract includes mechanisms to prevent unauthorized modifications and ensure the integrity of DID records. \u2713 \u2713 S4.3.A3 Check that DID documents managed by the smart contract are securely stored and can be retrieved in a decentralized manner. \u2713 \u2713 S4.3.A4 Verify that the smart contract supports reliable DID resolution and includes mechanisms for handling conflicts and updates. \u2713 \u2713 S4.3.A5 Ensure that the smart contract maintains the privacy and confidentiality of DID-related information throughout its lifecycle. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#s43b-verifiable-credentials","title":"S4.3.B Verifiable Credentials","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.3.B1 Verify that the smart contract manages verifiable credentials in a way that ensures their authenticity and integrity through cryptographic proofs. \u2713 \u2713 S4.3.B2 Ensure that the issuance process of verifiable credentials by the smart contract includes proper identity verification and validation procedures. \u2713 \u2713 S4.3.B3 Check that the smart contract supports cryptographic proofs to verify the validity of credentials without disclosing sensitive information. \u2713 \u2713 S4.3.B4 Verify that the smart contract includes a secure process for revoking verifiable credentials when necessary. \u2713 \u2713 S4.3.B5 Ensure that the smart contract\u2019s handling of verifiable credentials complies with relevant standards and best practices for secure credential management. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/","title":"SCSVS-BLOCK-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#s81-gas-limits","title":"S8.1 Gas Limits","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#control-objective","title":"Control Objective","text":"<p>Ensure that contract design and function implementations are efficient in gas usage to mitigate risks associated with out-of-gas errors and related vulnerabilities.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#s81a-efficient-loop-and-function-design","title":"S8.1.A Efficient Loop and Function Design","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S8.1.A1 Ensure that contracts are protected against insufficient gas griefing attacks by carefully managing gas consumption in critical functions. \u2713 \u2713 S8.1.A2 Ensure that systems like the RocketDepositPool contract handle failures in functions like burn() gracefully. \u2713 \u2713 S8.1.A3 Verify that gas usage in functions and loops is efficient to avoid out-of-gas errors. \u2713 \u2713 S8.1.A4 Implement mechanisms to prevent denial of service attacks due to block gas limits, ensuring that transactions or operations do not exceed the gas limit constraints. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#s81b-fallback-mechanisms","title":"S8.1.B Fallback Mechanisms","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S8.1.B1 Ensure that try/catch blocks are provided with adequate gas to avoid failures and unexpected behavior in case of errors. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/","title":"SCSVS-BLOCK-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/#s82-resilience-against-resource-exhaustion","title":"S8.2 Resilience Against Resource Exhaustion","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/#control-objective","title":"Control Objective","text":"<p>Implement strategies to protect contracts from resource exhaustion attacks that can lead to DoS scenarios.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/#s82a-rate-limiting","title":"S8.2.A Rate Limiting","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S8.2.A1 Avoid using blocking mechanisms that could lead to a Denial-of-Service (DoS) attack. \u2713 \u2713 S8.2.A2 Protect against potential DoS in functions like supportsERC165InterfaceUnchecked() by handling excessive data queries efficiently. \u2713 \u2713 S8.2.A3 Ensure that assertions do not lead to denial of service or unexpected contract reverts, especially in scenarios where conditions are not met. \u2713 \u2713 S8.2.A4 Verify that return values from external function calls are checked to prevent issues related to unchecked return values, which could lead to unexpected behavior. \u2713 \u2713 S8.2.A5 Ensure that contract functions are protected against denial of service due to unexpected reverts by handling all possible error conditions appropriately. \u2713 \u2713 S8.2.A6 Ensure that functions such as supportsERC165InterfaceUnchecked() in ERC165Checker.sol handle large data queries efficiently to avoid excessive resource consumption. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/","title":"SCSVS-BRIDGE-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#s91-state-management","title":"S9.1 State Management","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#control-objective","title":"Control Objective","text":"<p>Ensure efficient and secure handling of state within smart contracts to prevent data corruption and unexpected behavior.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#s91a-efficient-and-secure-state-handling","title":"S9.1.A Efficient and Secure State Handling","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.1.A1 Ensure that payable functions in contracts handle all ETH passed in msg.value and provide a mechanism for withdrawal to avoid ETH being locked in the contract. \u2713 \u2713 S9.1.A2 Verify that deleting a variable of a nested structure correctly resets all nested level fields to default values to avoid unexpected behavior. \u2713 \u2713 S9.1.A3 Verify that storage structs and arrays with types shorter than 32 bytes are handled correctly, avoiding data corruption when encoded directly from storage using the experimental ABIEncoderV2. \u2713 \u2713 S9.1.A4 Verify that storage arrays containing structs or other statically-sized arrays are properly read and encoded in external function calls to prevent data corruption. \u2713 \u2713 S9.1.A5 Ensure that copying bytes arrays from memory or calldata to storage handles empty arrays correctly, avoiding data corruption when the target array's length is increased subsequently without storing new data. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#s91b-state-channels","title":"S9.1.B State Channels","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.1.B1 Verify that global state updates are correctly handled when working with memory copies to ensure accurate state management. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/","title":"SCSVS-BRIDGE-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92-data-privacy","title":"S9.2 Data Privacy","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#control-objective","title":"Control Objective","text":"<p>Ensure that sensitive data within contracts is secured and that privacy measures are effectively implemented.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92a-ensuring-sensitive-data-is-secure","title":"S9.2.A Ensuring Sensitive Data is Secure","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.A1 Ensure that private data marked in contracts is protected from unauthorized access through blockchain analysis. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92b-zero-knowledge-proofs","title":"S9.2.B Zero-Knowledge Proofs","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.B1 Verify that zero-knowledge proofs are implemented to ensure privacy without revealing any underlying data. \u2713 \u2713 S9.2.B2 Validate the correctness of proof generation and verification processes to prevent any potential leaks or exploits. \u2713 \u2713 S9.2.B3 Ensure that zero-knowledge proofs are integrated seamlessly with the blockchain to maintain performance and security. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92c-private-transactions","title":"S9.2.C Private Transactions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.C1 Verify that private transaction mechanisms (e.g., zk-SNARKs, zk-STARKs) are correctly implemented to ensure confidentiality of transaction details. \u2713 \u2713 S9.2.C2 Ensure that private transactions maintain the integrity and validity of the blockchain. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92d-confidential-contracts","title":"S9.2.D Confidential Contracts","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.D1 Verify that confidential contracts use cryptographic techniques to hide contract state and execution details from unauthorized parties. \u2713 \u2713 S9.2.D2 Ensure that only parties with appropriate permissions can access data within confidential contracts. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/","title":"SCSVS-BRIDGE-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#s93-event-logging","title":"S9.3 Event Logging","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#control-objective","title":"Control Objective","text":"<p>Implement transparent and secure logging practices to ensure traceability and detect unauthorized changes.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#s93a-transparent-and-secure-logging-practices","title":"S9.3.A Transparent and Secure Logging Practices","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.3.A1 Verify that events are emitted properly, especially for critical changes to ensure traceability and transparency. \u2713 \u2713 S9.3.A2 Verify that the contract\u2019s event logging correctly reflects critical changes to ensure transparency and traceability. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#s93b-log-analysis","title":"S9.3.B Log Analysis","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.3.B1 Implement tools and processes for analyzing event logs to detect anomalies or unauthorized changes. \u2713 \u2713 S9.3.B2 Set up alerts for unusual patterns or discrepancies in logged events. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/","title":"SCSVS-BRIDGE-4","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/#s94-decentralized-storage","title":"S9.4 Decentralized Storage","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/#control-objective","title":"Control Objective","text":"<p>Ensure data integrity, security, and availability for data stored in decentralized storage solutions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/#s94a-ipfs-arweave","title":"S9.4.A IPFS, Arweave","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.4.A1 Ensure that data stored on decentralized platforms like IPFS or Arweave is encrypted and access-controlled. \u2713 \u2713 S9.4.A2 Implement mechanisms for data redundancy and backup to ensure data availability. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/","title":"SCSVS-CODE-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#s21-development-policies","title":"S2.1 Development Policies","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#control-objective","title":"Control Objective","text":"<p>Establish and enforce secure coding standards and review processes to minimize vulnerabilities and ensure best practices are followed throughout the development lifecycle.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#s21a-secure-coding-standards","title":"S2.1.A Secure Coding Standards","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.1.A1 Ensure that developers do not use outdated compiler versions and adhere to the latest compiler recommendations. \u2713 \u2713 S2.1.A2 Verify that deprecated functions are not used in the code. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#s21b-code-review-processes","title":"S2.1.B Code Review Processes","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.1.B1 Verify that all smart contract code changes are reviewed by at least two independent developers with expertise in smart contract security before merging to the main branch. \u2713 \u2713 S2.1.B2 Ensure that code reviews of smart contracts involve automated static analysis tools specifically designed for smart contracts, and that all flagged issues are addressed or documented prior to merging. \u2713 \u2713 S2.1.B3 Check that the code review process for smart contracts includes a thorough analysis for vulnerabilities such as reentrancy attacks, integer overflows, and improper access control. \u2713 \u2713 S2.1.B4 Verify that code reviews include adherence to smart contract development standards, such as the use of safe math libraries and secure design patterns. \u2713 \u2713 S2.1.B5 Ensure that code reviews incorporate a checklist of common smart contract vulnerabilities, and that each item on the list is addressed before code is approved. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/","title":"SCSVS-CODE-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#s22-code-clarity","title":"S2.2 Code Clarity","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#control-objective","title":"Control Objective","text":"<p>Promote code clarity and maintainability through thorough documentation, logical structure, and adherence to consistent coding standards, enabling easier understanding and modification by developers.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#s22a-readability-and-documentation","title":"S2.2.A Readability and Documentation","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.2.A1 Ensure that all smart contract functions and critical code blocks are documented with clear comments that explain their purpose and logic. \u2713 \u2713 S2.2.A2 Verify that the structure of the smart contract is logical and organized to facilitate understanding and modification by other developers. \u2713 \u2713 S2.2.A3 Check that the smart contract documentation includes a high-level overview of its functionality, usage instructions, and any dependencies on other contracts or systems. \u2713 \u2713 S2.2.A4 Ensure that smart contract code follows consistent naming conventions for variables, functions, and contract names to improve readability and maintainability. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#s22b-code-linting-and-formatting-tools","title":"S2.2.B Code Linting and Formatting Tools","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.2.B1 Ensure that a code linting tool specific to smart contracts is integrated into the development workflow to enforce coding standards and style guidelines. \u2713 \u2713 S2.2.B2 Verify that all smart contract code passes linting checks without errors or warnings before being committed to the repository. \u2713 \u2713 S2.2.B3 Check that code formatting tools are applied to maintain consistent indentation, spacing, and line breaks in smart contract code. \u2713 \u2713 S2.2.B4 Ensure that the linting and formatting configurations are reviewed and updated regularly to reflect new best practices and emerging issues in smart contract development. \u2713 \u2713 S2.2.B5 Verify that the linting and formatting tools are compatible with the development environment and do not introduce unintended changes to the smart contract code. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/","title":"SCSVS-CODE-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#s23-test-coverage","title":"S2.3 Test Coverage","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#control-objective","title":"Control Objective","text":"<p>Ensure comprehensive test coverage for smart contracts, encompassing unit tests, integration tests, and security-specific tests, to identify vulnerabilities and maintain code quality throughout development.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#s23a-unit-tests-integration-tests-automated-testing","title":"S2.3.A Unit Tests, Integration Tests, Automated Testing","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.3.A1 Verify that all critical functions in the smart contract have comprehensive unit tests that cover both typical and edge cases. \u2713 \u2713 S2.3.A2 Ensure that integration tests are implemented to validate the interactions between the smart contract and other contracts or external systems. \u2713 \u2713 S2.3.A3 Check that automated tests are set up to run on each code commit to detect regressions and maintain continuous quality of the smart contract. \u2713 \u2713 S2.3.A4 Verify that test coverage tools are used to monitor and achieve a high percentage of coverage for the smart contract code. \u2713 \u2713 S2.3.A5 Ensure that the testing framework supports mocking and simulating external dependencies to effectively isolate and test specific functionalities of the smart contract. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#s23b-security-specific-tests","title":"S2.3.B Security-Specific Tests","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.3.B1 Verify that the test suite for the smart contract includes security-specific tests designed to identify vulnerabilities such as reentrancy, integer overflows, and improper access controls. \u2713 \u2713 S2.3.B2 Ensure that the security tests validate proper implementation of access controls and permissions within the smart contract. \u2713 \u2713 S2.3.B3 Check that fuzz testing is conducted to uncover unexpected behaviors and potential security issues under various input scenarios. \u2713 \u2713 S2.3.B4 Verify that the smart contract's response to invalid inputs and edge cases is thoroughly tested to ensure robust security measures are in place. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/","title":"SCSVS-COMM-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#s51-contract-interactions","title":"S5.1 Contract Interactions","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#control-objective","title":"Control Objective","text":"<p>Ensure that all interactions between contracts are secure, minimizing risks associated with external calls, maintaining a minimal trusted surface, and handling errors appropriately.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#s51a-secure-message-passing","title":"S5.1.A Secure Message Passing","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.1.A1 Ensure that calls to inherited functions from LzApp use recommended approaches (e.g., _lzSend) to avoid vulnerabilities associated with direct calls to lzEndpoint.send. \u2713 \u2713 S5.1.A2 Ensure that when interacting with external contracts, the msg.sender remains consistent to avoid security issues related to unexpected changes in sender context. \u2713 \u2713 S5.1.A3 Manage untrusted external contract calls to prevent unexpected results such as multiple withdrawals or out-of-order events. \u2713 \u2713 S5.1.A4 Missing verification of interacting pools can introduce risks. Ensure that all pools are properly verified before interaction to prevent potential security issues. \u2713 \u2713 S5.1.A5 Verify that the low-level .delegatecall() is properly managed, acknowledging that it converts the return value to a Boolean without providing the execution outcome. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#s51b-minimal-trusted-surface","title":"S5.1.B Minimal Trusted Surface","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.1.B1 Verify that the smart contract minimizes its trusted surface by only interacting with other contracts and systems through well-defined and limited interfaces. \u2713 \u2713 S5.1.B2 Ensure that the smart contract includes checks to validate the trustworthiness and authenticity of interacting parties before executing sensitive operations. \u2713 \u2713 S5.1.B3 Check that the smart contract's interactions are designed to avoid dependencies on external data or contracts that could compromise security. \u2713 \u2713 S5.1.B4 Verify that the contract handles failures or unexpected behaviors from external interactions gracefully to avoid cascading failures. \u2713 \u2713 S5.1.B5 Ensure that interactions with other contracts are monitored and audited to detect and address any unusual or unauthorized activities. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/","title":"SCSVS-COMM-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#s52-oracle-integrations","title":"S5.2 Oracle Integrations","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#control-objective","title":"Control Objective","text":"<p>Ensure that oracle integrations provide secure, reliable, and tamper-proof data feeds while maintaining data integrity and handling failures appropriately.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#s52a-secure-data-feeds","title":"S5.2.A Secure Data Feeds","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.2.A1 Verify that the smart contract uses oracles that provide secure and tamper-proof data feeds, including checks for data integrity and authenticity. \u2713 \u2713 S5.2.A2 Ensure that the smart contract validates the data received from oracles to prevent malicious or incorrect data from affecting contract operations. \u2713 \u2713 S5.2.A3 Check that the smart contract includes fallback mechanisms in case of oracle failure or unreliable data. \u2713 \u2713 S5.2.A4 Verify that the integration with oracles follows best practices for data security, including encryption and secure communication channels. \u2713 \u2713 S5.2.A5 Ensure that the smart contract's oracle integration is designed to handle any potential discrepancies or conflicts in data from multiple sources. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#s52b-decentralized-oracles","title":"S5.2.B Decentralized Oracles","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.2.B1 Verify that the smart contract uses decentralized oracles to enhance data reliability and prevent single points of failure or manipulation. \u2713 \u2713 S5.2.B2 Ensure that the smart contract includes mechanisms to validate the consensus or majority opinion of decentralized oracles before taking actions based on their data. \u2713 \u2713 S5.2.B3 Check that the smart contract accounts for potential latency or delays in data from decentralized oracles to maintain operational reliability. \u2713 \u2713 S5.2.B4 Verify that the smart contract includes checks to prevent manipulation or collusion among decentralized oracles. \u2713 \u2713 S5.2.B5 Ensure that the decentralized oracle integration adheres to standards for security and reliability in multi-oracle environments. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/","title":"SCSVS-COMM-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#s53-cross-chain-interactions","title":"S5.3 Cross-Chain Interactions","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#control-objective","title":"Control Objective","text":"<p>Ensure secure handling of external calls and atomic swaps during cross-chain interactions to maintain operational reliability and prevent fraud.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#s53a-handling-external-calls-securely","title":"S5.3.A Handling External Calls Securely","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.3.A1 Ensure that parameters for Chainlink VRF (Verifiable Random Function) are thoroughly validated to prevent the fulfillRandomWord function from returning incorrect values instead of reverting. \u2713 \u2713 S5.3.A2 Implement robust security checks for cross-chain messaging to ensure correct permissions and intended functionality. \u2713 \u2713 S5.3.A3 Verify that contracts created using the CREATE opcode handle block reorganizations securely to prevent unexpected eliminations. \u2713 \u2713 S5.3.A4 Ensure robust cross-chain messaging security checks to prevent replay attacks where signatures valid on one chain might be exploited on another. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#s53b-atomic-swaps","title":"S5.3.B Atomic Swaps","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.3.B1 Verify that the smart contract supports atomic swaps with robust mechanisms to ensure that swaps are completed successfully or not executed at all. \u2713 \u2713 S5.3.B2 Ensure that the smart contract includes checks to validate the atomic swap conditions and prevent partial or fraudulent swaps. \u2713 \u2713 S5.3.B3 Check that the smart contract handles potential failures or disputes in atomic swaps securely and fairly. \u2713 \u2713 S5.3.B4 Verify that the atomic swap functionality is tested thoroughly to cover various scenarios and edge cases. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/","title":"SCSVS-COMM-4","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/#s54-bridges","title":"S5.4 Bridges","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/#control-objective","title":"Control Objective","text":"<p>Ensure the security of cross-chain transactions by implementing robust validation and verification mechanisms to prevent fraud and maintain data integrity.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/#s54a-cross-chain-transaction-security","title":"S5.4.A Cross-Chain Transaction Security","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.4.A1 Verify that the smart contract for cross-chain transactions includes robust mechanisms for verifying and validating transactions across different chains. \u2713 \u2713 S5.4.A2 Ensure that the smart contract prevents double-spending and replay attacks in cross-chain transactions by implementing appropriate security checks. \u2713 \u2713 S5.4.A3 Check that the cross-chain transaction contract handles communication and data integrity securely between different blockchain networks. \u2713 \u2713 S5.4.A4 Verify that the smart contract includes fallback and recovery mechanisms for handling failures or inconsistencies in cross-chain transactions. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/","title":"SCSVS-COMP-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/#s111-tokens-erc20-erc721-erc1155","title":"S11.1 Tokens (ERC20, ERC721, ERC1155)","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/#control-objective","title":"Control Objective","text":"<p>Ensure secure implementation and management of token standards to prevent vulnerabilities.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/#s111a-secure-implementation-and-management","title":"S11.1.A Secure Implementation and Management","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.1.A1 Verify that the totalSupply value is consistent during token minting operations, ensuring that callbacks do not result in incorrect values. \u2713 \u2713 S11.1.A2 Some tokens have multiple addresses associated with them, which can introduce vulnerabilities. Ensure all token addresses are managed and verified securely to avoid related risks. \u2713 \u2713 S11.1.A3 Verify that tokens handle zero amount transfers properly to prevent issues in integrations and operations. \u2713 \u2713 S11.1.A4 Verify that tokens handle zero amount transfers properly to prevent issues in integrations and operations. \u2713 \u2713 S11.1.A5 Some tokens revert on the transfer of a zero amount, which can cause issues in certain integrations and operations. Ensure compatibility with such tokens to avoid integration problems. \u2713 \u2713 S11.1.A6 Not all ERC20 tokens comply with the EIP20 standard; some may not return a boolean flag or revert on failure. Verify compliance with the ERC20 standard to avoid compatibility issues. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/","title":"SCSVS-COMP-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/#s112-nft-security","title":"S11.2 NFT Security","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/#control-objective","title":"Control Objective","text":"<p>Implement best practices for non-fungible tokens to safeguard against vulnerabilities.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/#s112a-best-practices-for-non-fungible-tokens","title":"S11.2.A Best Practices for Non-Fungible Tokens","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.2.A1 Implement standards and best practices for NFT creation, management, and transfer to prevent common vulnerabilities. \u2713 \u2713 S11.2.A2 Ensure proper metadata integrity and prevent unauthorized minting or transfers. \u2713 \u2713 S11.2.A3 Safeguard against potential exploits related to royalty payments or token burns. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/","title":"SCSVS-COMP-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/#s113-vaults","title":"S11.3 Vaults","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/#control-objective","title":"Control Objective","text":"<p>Ensure secure asset storage and management within vault systems.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/#s113a-secure-asset-storage-and-management","title":"S11.3.A Secure Asset Storage and Management","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.3.A1 Address potential overhead issues associated with withdrawing stETH or wstETH, including queue times and withdrawal limits, to ensure smooth operations. \u2713 \u2713 S11.3.A2 Handle conversions between stETH and wstETH carefully to avoid potential issues due to the rebasing nature of stETH. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/","title":"SCSVS-COMP-4","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/#s114-liquid-staking","title":"S11.4 Liquid Staking","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/#control-objective","title":"Control Objective","text":"<p>Ensure secure staking mechanisms to protect users' assets.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/#s114a-secure-staking-mechanisms","title":"S11.4.A Secure Staking Mechanisms","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.4.A1 Verify that mechanisms for detaching sfrxETH from frxETH are robust to prevent discrepancies and ensure accurate reward transfers, particularly when controlled by centralized entities. \u2713 \u2713 S11.4.A2 Monitor potential future changes in the sfrxETH/ETH rate and ensure users are adequately forewarned to mitigate risks associated with rate fluctuations. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/","title":"SCSVS-COMP-5","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/#s115-liquidity-pools-amms","title":"S11.5 Liquidity Pools (AMMs)","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/#control-objective","title":"Control Objective","text":"<p>Establish security measures in automated market makers.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/#s115a-security-in-automated-market-makers","title":"S11.5.A Security in Automated Market Makers","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.5.A1 [WIP/Will be removed]","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/","title":"SCSVS-COMP-6","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/#s116-uniswap-v4-hook","title":"S11.6 Uniswap V4 Hook","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/#control-objective","title":"Control Objective","text":"<p>Ensure secure integration and customization of Uniswap components.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/#s116a-secure-integration-and-customization","title":"S11.6.A Secure Integration and Customization","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.6.A1 Verify the correct usage of Uniswap\u2019s TickMath and FullMath libraries to ensure proper handling of unchecked arithmetic operations, adhering to version-specific Solidity considerations. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/","title":"SCSVS-CRYPTO-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#s61-key-management","title":"S6.1 Key Management","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#control-objective","title":"Control Objective","text":"<p>Ensure secure handling and storage of private keys and implement robust signature verification processes to prevent unauthorized access and actions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#s61a-secure-handling-and-storage-of-private-keys","title":"S6.1.A Secure Handling and Storage of Private Keys","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.1.A1 Verify that the ecrecover() function handles malformed inputs correctly and does not return invalid data. \u2713 \u2713 S6.1.A2 Ensure that signature verification mechanisms are robust against signature malleability and replay attacks, particularly by using nonces or hashed messages rather than relying solely on the signature itself. \u2713 \u2713 S6.1.A3 Verify that SignatureChecker.isValidSignatureNow handles edge cases properly and does not revert unexpectedly, considering the ABI decoding issues introduced in Solidity 0.8. \u2713 \u2713 S6.1.A4 Ensure that all signatures are checked thoroughly to prevent unauthorized transactions or actions due to weak or improperly managed signature validation. \u2713 \u2713 S6.1.A5 Validate that signature protection mechanisms are up-to-date and resistant to signature malleability attacks by avoiding outdated libraries and practices. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#s61b-multi-signature-wallets","title":"S6.1.B Multi-Signature Wallets","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.1.B1 Verify that multi-signature wallets require a predefined number of signatures before executing any transaction. \u2713 \u2713 S6.1.B2 Ensure that the multi-signature wallet logic is resistant to replay attacks. \u2713 \u2713 S6.1.B3 Verify that the process of adding or removing signatories from the multi-signature wallet is secure and controlled. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/","title":"SCSVS-CRYPTO-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#s62-signature-verification","title":"S6.2 Signature Verification","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#control-objective","title":"Control Objective","text":"<p>Implement cryptographic techniques that ensure the secure verification of signatures and compliance with standards to maintain the integrity of authenticated transactions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#s62a-cryptographic-techniques-for-authentication","title":"S6.2.A Cryptographic Techniques for Authentication","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.2.A1 Ensure that cryptographic algorithms used for signature verification are secure and follow best practices. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#s62b-standard-compliance-eg-eip-712","title":"S6.2.B Standard Compliance (e.g., EIP-712)","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.2.B1 Verify that ECDSA signature handling functions, such as ECDSA.recover and ECDSA.tryRecover, properly manage signature formats to prevent signature malleability, especially when handling both traditional 65-byte and EIP-2098 compact signatures. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/","title":"SCSVS-CRYPTO-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/#s63-secure-random-number-generation","title":"S6.3 Secure Random Number Generation","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/#control-objective","title":"Control Objective","text":"<p>Implement best practices for secure random number generation to ensure unpredictability and resistance against manipulation.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/#s63a-best-practices-for-randomness","title":"S6.3.A Best Practices for Randomness","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.3.A1 Ensure that random number generation follows best practices and uses secure sources of entropy. \u2713 \u2713 S6.3.A2 Verify that any random number generation is resistant to manipulation and prediction. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/","title":"SCSVS-DEFI-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#s101-optimizing-gas-usage","title":"S10.1 Optimizing Gas Usage","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#control-objective","title":"Control Objective","text":"<p>Ensure gas consumption is minimized to promote cost-effective execution of smart contracts.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#s101a-understanding-gas-costs-and-limits","title":"S10.1.A Understanding Gas Costs and Limits","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S10.1.A1 Implement best practices for optimizing gas consumption to ensure cost-effective and efficient contract execution. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#s101b-gas-estimation-tools","title":"S10.1.B Gas Estimation Tools","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S10.1.B1 Verify that transaction confirmation numbers are chosen appropriately to mitigate risks related to chain re-orgs and ensure reliable contract operation. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/","title":"SCSVS-DEFI-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/#s102-efficient-contract-design","title":"S10.2 Efficient Contract Design","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/#control-objective","title":"Control Objective","text":"<p>Design contracts efficiently to enhance performance and reduce gas costs through optimal architecture.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/#s102a-layer-2-solutions","title":"S10.2.A Layer 2 Solutions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S10.2.A1 Explore and integrate Layer 2 scaling solutions (e.g., rollups, state channels) to improve transaction throughput and reduce gas costs. \u2713 \u2713 S10.2.A2 Verify the security and reliability of Layer 2 solutions before integration. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/","title":"SCSVS-GOV-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/#s31-economic-models","title":"S3.1 Economic Models","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/#control-objective","title":"Control Objective","text":"<p>Ensure that economic models, including incentive structures and tokenomics, are designed and implemented in a way that secures value and incentivizes proper behavior within the ecosystem. Contracts should handle fluctuating token values and avoid creating opportunities for exploitation.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/#s31a-incentive-structures","title":"S3.1.A Incentive Structures","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.1.A1 Ensure that the withdrawal process implements a pull-based approach rather than a push-based one to track accounting and allow users to pull payments. \u2713 \u2713 \u2713 S3.1.A2 The rate of cbETH to ETH can decrease, impacting users who hold or interact with cbETH. Ensure mechanisms are in place to handle fluctuations in conversion rates. \u2713 \u2713 S3.1.A3 Validators on the Ethereum 2.0 Beacon Chain can be penalized or slashed for misbehavior, which can affect the value of rETH. Ensure that these dynamics are considered in value assessments and interactions. \u2713 \u2713 S3.1.A4 The conversion rate between ETH and rETH might change over time based on the rewards accrued from staking. Ensure that these fluctuations are properly managed and captured. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/","title":"SCSVS-GOV-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/#s32-tokenomics","title":"S3.2 Tokenomics","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/#control-objective","title":"Control Objective","text":"<p>Ensure that tokens used within the smart contract ecosystem are securely implemented, including aspects such as value management, rebasing mechanisms, and reward systems. Contracts should prevent token vulnerabilities like double-spending, incorrect rewards, and improper fee handling.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/#s32a-economic-security-of-tokens-and-their-use-cases","title":"S3.2.A Economic Security of Tokens and Their Use Cases","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.2.A1 Ensure that Merkle trees do not contain duplicate proofs, as this can lead to vulnerabilities like double-spending. \u2713 \u2713 S3.2.A2 Verify that DeFi protocols account for tokens with negative rebase mechanisms, ensuring that value changes and potential miscalculations are properly handled and mitigated. \u2713 \u2713 S3.2.A3 Verify that reward claims are correctly implemented to ensure users receive their correct rewards. \u2713 \u2713 S3.2.A4 Verify that tokens do not have vulnerabilities such as incorrect fee application or unexpected behavior due to token transfer issues. \u2713 \u2713 S3.2.A5 Verify that all claimable addresses are included in the hashing process for Merkle tree leaves to prevent attackers from claiming funds they should not. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/","title":"SCSVS-GOV-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#s33-preventing-reentrancy-and-logic-flaws","title":"S3.3 Preventing Reentrancy and Logic Flaws","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#control-objective","title":"Control Objective","text":"<p>Ensure the smart contract's transaction flow and logic integrity are protected from reentrancy attacks and logic flaws. Contracts should implement robust control structures and security patterns to prevent reentrancy, handle complex flows, and ensure that state transitions are secure and symmetrical.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#s33a-transaction-flow-security","title":"S3.3.A Transaction Flow Security","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.3.A1 Check for edge cases in loop control structures to prevent unexpected behaviors due to break or continue statements. \u2713 \u2713 S3.3.A2 Ensure that scenarios where sender and recipient are the same are considered to prevent unintended issues in smart contracts. \u2713 \u2713 S3.3.A3 Ensure that the <code>NonReentrant</code> modifier is applied before other modifiers in functions to prevent reentrancy attacks. \u2713 \u2713 S3.3.A4 Verify that the check-effect-interaction pattern is implemented to prevent reentrancy attacks. \u2713 \u2713 S3.3.A5 Ensure that function calls with arbitrary user input and low-level calls are handled securely to avoid introducing risks. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#s33b-function-integrity","title":"S3.3.B Function Integrity","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.3.B1 Ensure that functions intended to be unique per parameter set are not callable multiple times to prevent potential issues. \u2713 \u2713 S3.3.B2 Verify that state changes in functions, such as withdraw and deposit, are symmetrically handled to avoid undesired behavior due to inconsistencies. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/","title":"SCSVS-ORACLE-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#s71-preventing-overflowunderflow","title":"S7.1 Preventing Overflow/Underflow","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#control-objective","title":"Control Objective","text":"<p>Implement safe arithmetic practices to prevent overflow and underflow vulnerabilities that can compromise contract functionality and security.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#s71a-use-of-safe-math-libraries","title":"S7.1.A Use of Safe Math Libraries","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.1.A1 Verify that explicit type casting does not lead to overflow or underflow issues. \u2713 \u2713 S7.1.A2 Verify that integer arithmetic operations do not exceed their bounds to prevent integer overflow or underflow vulnerabilities. \u2713 \u2713 S7.1.A3 Ensure that operations involving time units and other expressions handle potential overflows correctly. \u2713 \u2713 S7.1.A4 Verify that division by zero is correctly handled and causes a transaction revert to prevent unexpected behavior. \u2713 \u2713 S7.1.A5 Ensure that variables are managed within their bounds to prevent reverts due to exceeding limits. \u2713 \u2713 S7.1.A6 Ensure that arithmetic operations within the unchecked{} block are carefully managed to prevent unintentional overflow or underflow. \u2713 \u2713 S7.1.A7 Confirm that inline assembly operations handle division by zero and overflow/underflow according to desired behavior and revert appropriately. \u2713 \u2713 S7.1.A8 Implement checks to handle cases where operations might introduce unintended precision issues or rounding errors. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#s71b-fixed-point-arithmetic","title":"S7.1.B Fixed-Point Arithmetic","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.1.B1 Verify that fixed-point arithmetic operations are performed safely to prevent overflow, underflow, and precision loss. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/","title":"SCSVS-ORACLE-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#s72-arithmetic-integrity","title":"S7.2 Arithmetic Integrity","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#control-objective","title":"Control Objective","text":"<p>Ensure that all calculations and logical operations within the smart contract are performed correctly to maintain data integrity and prevent manipulation.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#s72a-secure-calculations-and-logic","title":"S7.2.A Secure Calculations and Logic","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.2.A1 Ensure that price or rate calculations derived from asset balances are protected from manipulation, considering attack vectors like flash loans and donations. \u2713 \u2713 S7.2.A2 Ensure that the use of structs and arrays does not lead to data corruption or incorrect values due to storage encoding issues. \u2713 \u2713 S7.2.A3 Avoid operations that could lead to unintended data type conversions or precision loss by ensuring arithmetic operations are performed correctly. \u2713 \u2713 S7.2.A4 Enforce a minimum transaction amount to prevent attackers from clogging the network with zero amount or dust transactions. \u2713 \u2713 S7.2.A5 Validate that financial operations respect associative properties, ensuring consistent outcomes whether operations are performed in aggregate or iteratively. \u2713 \u2713 S7.2.A6 Implement proper rounding direction for calculations where accounting relies on user shares to avoid inaccuracies. \u2713 \u2713 S7.2.A7 Validate that inequalities and comparisons are correctly implemented to handle edge values appropriately. \u2713 \u2713 S7.2.A8 Ensure that abi.decode adheres to the type limits to avoid reverts due to overflow of target types. \u2713 \u2713 S7.2.A9 Ensure that logical operators such as <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are used correctly, especially when test coverage may be limited. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#s72b-precondition-and-postcondition-checks","title":"S7.2.B Precondition and Postcondition Checks","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.2.B1 Ensure that multiplication is performed before division to maintain precision in calculations. \u2713 \u2713 S7.2.B2 Ensure that the request confirmation number is high enough to mitigate risks associated with chain re-orgs. \u2713 \u2713 S7.2.B3 Verify that off-by-one errors are avoided in loops and iterations, ensuring correct handling of list lengths and indexing. \u2713 \u2713 S7.2.B4 Verify that unsigned integers are not used to represent negative values, as this can lead to erroneous behavior. \u2713 \u2713 S7.2.B5 Verify that calculations with multiple terms handle all possible edge cases for min/max values to avoid errors. \u2713 \u2713","tags":[]},{"location":"SCWE/","title":"Smart Contract Security Weakness Enumeration (SCWE)","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p> <p> GitHub Repo</p> <p> OWASP Project Page</p> About the SCWE <p>The Smart Contract Security Weakness Enumeration (SCWE) is a list of common security and privacy weaknesses in smart contracts. It is intended to be used as a reference for developers, security researchers, and security professionals. It acts as the bridge between the SCSVS and the SCSTG.</p> <p> </p> <p>For its definition we draw inspiration from the Common Weakness Enumeration (CWE), which is a community-developed list of common software security weaknesses. The SCWE is intended to be a complementary list to the CWE, focusing specifically on security weaknesses in smart contracts.</p> <p>A weakness is a security or privacy issue that can be introduced into a smart contracts. Weaknesses are categorized by the SCSVS categories and controls. For example, a weakness related to the use of insecure random number generators is categorized under the <code>SCSVS-CODE-1</code> control.</p> <p>Each weakness contains the following information:</p> <ul> <li>Overview: A brief description of the weakness.</li> <li>Impact: The potential impact of the weakness on the security or privacy of the application.</li> <li>Modes of Introduction: The ways in which the weakness can be introduced into an application.</li> <li>Mitigations: Recommendations for mitigating the weakness.</li> </ul> <p>\"Weakness vs Vulnerability\": It is important to note that a weakness is not a vulnerability, but it can lead to the introduction of vulnerabilities. According to the CWE, a weakness is a condition in a software, firmware, hardware, or service component that, under certain circumstances, could contribute to the introduction of vulnerabilities. Whereas a vulnerability is a flaw in a software, firmware, hardware, or service component resulting from a weakness that can be exploited, causing a negative impact to the confidentiality, integrity, or availability of an impacted component or components.</p> Open Call for New SCWE Submissions <p>Want to contribute a new SCWE entry?</p> <ul> <li>Open an issue in our GitHub repository with your proposed SCWE-XXX identifier and a brief description.</li> <li>After approval and metadata assignment, submit a Pull Request with your new SCWE entry.</li> <li>See the full contribution process here.</li> <li>See this sample issue and this sample PR for examples of a valid submission.</li> </ul> <p>Thank you for helping us improve the security of smart contracts!</p> SCWE ID Title SCSVS CG ID SCSVS SCG IDs Status SCWE-059  Insufficient Gas Griefing SCSVS-DEFI SCSVS-DEFI-2 newstatus:new SCWE-116  Missing Supply Cap Enforcement SCSVS-DEFI SCSVS-DEFI-2 newstatus:new SCWE-151  Add/Remove Liquidity Without Minimum Output Validation SCSVS-DEFI SCSVS-DEFI-2 newstatus:new SCWE-077  Lack of Rate Limiting SCSVS-DEFI SCSVS-DEFI-2 newstatus:new SCWE-148  Gas Exhaustion via Unbounded Loops with External Calls SCSVS-DEFI SCSVS-DEFI-1 newstatus:new SCWE-058  DoS with Block Gas Limit SCSVS-DEFI SCSVS-DEFI-1 newstatus:new SCWE-036  Inadequate Gas Limit Handling SCSVS-DEFI SCSVS-DEFI-1 newstatus:new SCWE-109  Unbounded Loops on Untrusted Input SCSVS-DEFI SCSVS-DEFI-1 newstatus:new SCWE-082  Lack of Proper Gas Management SCSVS-DEFI SCSVS-DEFI-1 newstatus:new SCWE-126  Unbounded Withdrawal Queue Growth SCSVS-DEFI SCSVS-DEFI-2 newstatus:new SCWE-125  Missing Post-Operation Health Check SCSVS-DEFI SCSVS-DEFI-1 newstatus:new SCWE-033  Chain Split Risks SCSVS-BRIDGE SCSVS-BRIDGE-1 newstatus:new SCWE-094  Insufficient Gas Limit Validation in LayerZero Message Sending SCSVS-BRIDGE SCSVS-BRIDGE-2 newstatus:new SCWE-032  Dependency on Block Gas Limit SCSVS-BRIDGE SCSVS-BRIDGE-2 newstatus:new SCWE-034  Insecure Cross-Chain Messaging SCSVS-BRIDGE SCSVS-BRIDGE-2 newstatus:new SCWE-087  Missing Payload Size Validation in Cross-Chain Messaging (Denial of Service/Stuck Funds) SCSVS-BRIDGE SCSVS-BRIDGE-2 newstatus:new SCWE-132  Mismatched Token Decimals in Bridge Mint/Burn SCSVS-BRIDGE SCSVS-BRIDGE-1 newstatus:new SCWE-133  Missing Replay Nonce per Bridge Lane SCSVS-BRIDGE SCSVS-BRIDGE-1 newstatus:new SCWE-096  Missing Token Burn During Cross-Chain NFT Withdrawal SCSVS-BRIDGE SCSVS-BRIDGE-1 newstatus:new SCWE-057  Write to Arbitrary Storage Location SCSVS-COMP SCSVS-COMP-2 newstatus:new SCWE-110  Fee-On-Transfer Token Misaccounting SCSVS-COMP SCSVS-COMP-1 newstatus:new SCWE-135  ERC4626 Share Inflation via Donations SCSVS-COMP SCSVS-COMP-1 newstatus:new SCWE-111  Rebase Token Balance Drift SCSVS-COMP SCSVS-COMP-1 newstatus:new SCWE-083  Failure to Handle Edge Cases SCSVS-COMP SCSVS-COMP-2 newstatus:new SCWE-145  Unvalidated Constructor Parameters SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-064  Incorrect Inheritance Order SCSVS-ARCH SCSVS-ARCH-2 newstatus:new SCWE-071  Uninitialized Storage Pointer SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-119  Shared Proxy Admin and Logic Owner Key SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-006  Inconsistent Inheritance Hierarchy SCSVS-ARCH SCSVS-ARCH-3 newstatus:new SCWE-001  Improper Contract Architecture SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-150  Storage Slot Collision When Upgrading Implementation SCSVS-ARCH SCSVS-ARCH-2 newstatus:new SCWE-051  Improper Use of CREATE2 for Contract Deployment SCSVS-ARCH SCSVS-ARCH-2 newstatus:new SCWE-070  Incorrect Constructor Name SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-005  Insecure Upgradeable Proxy Design SCSVS-ARCH SCSVS-ARCH-2 newstatus:new SCWE-099  Storage Layout Collision on Upgrade SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-117  Proxy Implementation Selfdestruct Exposure SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-004  Uncaught Exceptions SCSVS-ARCH SCSVS-ARCH-2 newstatus:new SCWE-080  Incorrect Type Conversion SCSVS-ARCH SCSVS-ARCH-2 newstatus:new SCWE-052  Transaction Order Dependence SCSVS-ARCH SCSVS-ARCH-3 newstatus:new SCWE-003  Lack of Modularity SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-118  Unauthenticated Beacon Upgrade SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-002  Excessive Contract Complexity SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-098  Initialization Front-Running in Upgradeable Contracts SCSVS-ARCH SCSVS-ARCH-1 newstatus:new SCWE-037  Insufficient Protection Against Front-Running SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-044  Insecure Use of Storage SCSVS-GOV SCSVS-GOV-1 newstatus:new SCWE-142  Extractable Value from Predictable Transaction Ordering SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-136  Unbounded Proposal Execution Gas SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-012  Lack of Multisig Governance SCSVS-GOV SCSVS-GOV-1 newstatus:new SCWE-015  Poor Governance Documentation SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-078  Improper Handling of Ether Transfers SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-075  Incorrect Ether Balance Tracking SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-140  Ether Locked Due to Missing Withdrawal Path SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-102  Missing Checks-Effects-Interactions Pattern SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-043  Insecure Use of Fallback Functions SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-079  Insecure Use of Transfer and Send SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-101  Flash-Loan-Fueled Governance Manipulation SCSVS-GOV SCSVS-GOV-1 newstatus:new SCWE-100  Missing Quorum Validation in Governance Execution SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-156  Missing Emergency Circuit Breaker for Critical Operations SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-081  Improper Handling of Nonce SCSVS-GOV SCSVS-GOV-2 newstatus:new SCWE-038  Insecure Use of Selfdestruct SCSVS-AUTH SCSVS-AUTH-1 newstatus:new SCWE-129  Single EOA Admin Without Rotation SCSVS-AUTH SCSVS-AUTH-1 newstatus:new SCWE-017  Privileged Role Mismanagement SCSVS-AUTH SCSVS-AUTH-1 newstatus:new SCWE-147  Permit or Meta-Transaction Signatures Without Expiration SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-019  Insecure Signature Verification SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-106  Unauthenticated Meta-Transactions SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-139  Single-Step Ownership Transfer Without Confirmation SCSVS-AUTH SCSVS-AUTH-1 newstatus:new SCWE-049  Unprotected Ether Withdrawal SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-020  Absence of Time-Locked Functions SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-018  Use of tx.origin for Authorization SCSVS-AUTH SCSVS-AUTH-1 newstatus:new SCWE-105  Permit Signature Replay via Missing Domain Separator or Nonce SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-045  Insecure Use of Modifiers SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-016  Insufficient Authorization Checks SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-155  Single Point of Failure in Administrative Key Management SCSVS-AUTH SCSVS-AUTH-1 newstatus:new SCWE-050  Unprotected SELFDESTRUCT Instruction SCSVS-AUTH SCSVS-AUTH-2 newstatus:new SCWE-093  Unnamed Function Parameters SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-154  Calldata Decode Without Length Check SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-144  Bypassable Contract Existence Check via extcodesize SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-039  Insecure Use of Inline Assembly SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-076  Right-To-Left-Override Control Character (U+202E) SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-072  Use of Deprecated Solidity Functions SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-097  Missing Explicit Function Visibility SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-061  Outdated Compiler Version SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-062  Dead Code SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-141  Lack of Deadline Validation in Time-Sensitive External Calls SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-041  Unsafe Downcasting SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-007  Presence of Unused Variables SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-069  Shadowing State Variables SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-121  Swallowed Revert Reasons SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-146  Improper Use of try/catch Leading to Silent Failures SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-122  Calldata Length Not Validated Before Decode SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-010  Shadowing Variables and Functions SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-048  Unchecked Call Return Value SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-095  Missing Destination Address Size Check SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-014  Lack of Emergency Stop Mechanism SCSVS-GOV SCSVS-GOV-3 newstatus:new SCWE-152  Misuse of Custom Errors Leading to Information Leakage or Wrong Revert Behavior SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-124  Inconsistent Rounding Direction in Financial Math SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-053  Improper Deletion of Mappings SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-013  Unauthorized Parameter Changes SCSVS-GOV SCSVS-GOV-2 newstatus:new SCWE-091  Lack of Zero Value Check in Token Transfers SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-120  Missing Return Data Length Validation SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-060  Floating Pragma SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-123  Corrupt Free Memory Pointer in Assembly SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-011  Insecure ABI Encoding and Decoding SCSVS-ARCH SCSVS-ARCH-3 newstatus:new SCWE-067  Assert Violation SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-143  Critical Address Parameters Not Validated for Zero Address SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-040  Incorrect Storage Packing SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-046  Reentrancy Attacks SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-009  Deprecated Variable and Function Usage SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-092  Missing Disable Initializer in Constructor for Proxy Contracts SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-068  State Variable Default Visibility SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-066  Incorrect Handling of Bitwise Operations SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-008  Hardcoded Constants SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-089  Vulnerable &amp; Outdated Libraries SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-090  Missing Slippage Protection in Automated Token Swaps SCSVS-CODE SCSVS-CODE-1 newstatus:new SCWE-047  Integer Overflows and Underflows SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-137  Read-Only Reentrancy via View Function State Staleness SCSVS-CODE SCSVS-CODE-2 newstatus:new SCWE-030  Insecure Oracle Data Updates SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-085  Misuse of Oracle Min/Max Price Band Without Validation SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-029  Lack of Decentralized Oracle Sources SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-112  Reliance on Low-Liquidity Spot Prices SCSVS-ORACLE SCSVS-ORACLE-2 newstatus:new SCWE-088  Improper Decimal Normalization in Price-Based Calculations SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-113  Insufficient TWAP Window or Single Observation SCSVS-ORACLE SCSVS-ORACLE-2 newstatus:new SCWE-028  Price Oracle Manipulation SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-086  Missing Validation of Oracle Response Fields (Stale or Incomplete Data) SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-130  Admin-Write Oracle Without Delay SCSVS-ORACLE SCSVS-ORACLE-1 newstatus:new SCWE-153  Reliance on block.prevrandao for High-Value Randomness SCSVS-BLOCK SCSVS-BLOCK-1 newstatus:new SCWE-031  Insecure use of Block Variables SCSVS-BLOCK SCSVS-BLOCK-2 newstatus:new SCWE-024  Weak Randomness Sources SCSVS-BLOCK SCSVS-BLOCK-1 newstatus:new SCWE-073  Message Call with Hardcoded Gas Amount SCSVS-BLOCK SCSVS-BLOCK-1 newstatus:new SCWE-127  EIP-1559 Basefee Assumptions SCSVS-BLOCK SCSVS-BLOCK-2 newstatus:new SCWE-065  Block Values as a Proxy for Time SCSVS-BLOCK SCSVS-BLOCK-2 newstatus:new SCWE-149  Transfers to Addresses That Cannot Receive Funds SCSVS-COMM SCSVS-COMM-2 newstatus:new SCWE-104  Unprotected ERC777 Token Hooks SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-134  Low-Level Call to Non-Contract Address SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-063  Insecure Event Emission SCSVS-COMM SCSVS-COMM-2 newstatus:new SCWE-022  Message Replay Vulnerabilities SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-023  Lack of Communication Authenticity SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-035  Insecure Delegatecall Usage SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-138  Reentrancy via ERC721/ERC1155 Safe Transfer Callbacks SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-128  Insecure Multicall Context Forwarding SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-042  Insecure Use of External Calls SCSVS-COMM SCSVS-COMM-2 newstatus:new SCWE-107  Missing Chain ID Validation in Cross-Chain Messages SCSVS-COMM SCSVS-COMM-3 newstatus:new SCWE-021  Unsecured Data Transmission SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-108  Unverified Cross-Chain Message Proofs SCSVS-COMM SCSVS-COMM-3 newstatus:new SCWE-103  ERC20 Approval Double-Spend (Allowance Race) SCSVS-COMM SCSVS-COMM-1 newstatus:new SCWE-131  Missing Domain Separation in Aggregate Signatures SCSVS-CRYPTO SCSVS-CRYPTO-2 newstatus:new SCWE-025  Improper Cryptographic Key Management SCSVS-CRYPTO SCSVS-CRYPTO-1 newstatus:new SCWE-115  Weak VRF Parameterization or Callback Validation SCSVS-CRYPTO SCSVS-CRYPTO-1 newstatus:new SCWE-027  Vulnerable Cryptographic Algorithms SCSVS-CRYPTO SCSVS-CRYPTO-2 newstatus:new SCWE-054  Signature Malleability SCSVS-CRYPTO SCSVS-CRYPTO-2 newstatus:new SCWE-026  Insufficient Hash Verification SCSVS-CRYPTO SCSVS-CRYPTO-2 newstatus:new SCWE-074  Hash Collisions with Multiple Variable Length Arguments SCSVS-CRYPTO SCSVS-CRYPTO-2 newstatus:new SCWE-056  Lack of Proper Signature Verification SCSVS-CRYPTO SCSVS-CRYPTO-1 newstatus:new SCWE-084  Insecure Use of blockhash SCSVS-CRYPTO SCSVS-CRYPTO-2 newstatus:new SCWE-055  Missing Protection against Signature Replay Attacks SCSVS-CRYPTO SCSVS-CRYPTO-1 newstatus:new SCWE-114  ECDSA Nonce Reuse SCSVS-CRYPTO SCSVS-CRYPTO-1 newstatus:new <p></p>","tags":[]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/","title":"SCWE-001: Improper Contract Architecture","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#relationships","title":"Relationships","text":"<ul> <li>CWE-1008: Architectural Concepts   https://cwe.mitre.org/data/definitions/1008.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#description","title":"Description","text":"<p>Improper contract architecture refers to the flawed design of a smart contract\u2019s structure, which compromises its security, scalability, and maintainability. This often occurs due to monolithic designs, inefficient inheritance structures, and poor separation of concerns. Such flaws create challenges in managing, upgrading, and auditing the contract. Key issues associated with improper architecture include:</p> <ul> <li>Difficulty in upgrading the contract without introducing risks.</li> <li>Increased complexity leading to hidden attack surfaces.</li> <li>Lack of flexibility in contract logic, making it hard to isolate bugs or exploits.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#remediation","title":"Remediation","text":"<ul> <li>Modular design: Break down contracts into smaller, more manageable modules to ensure a clean separation of concerns.</li> <li>Proxy pattern implementation: Use proxies to allow contract upgrades while preserving contract state.</li> <li>Separate logic and state: Keep business logic and data storage separate to improve scalability and maintainability.</li> <li>Periodic code review and refactoring: Regularly assess the architecture and refactor to maintain efficiency and security.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#improper-contract-architecture","title":"Improper Contract Architecture","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract MonolithicContract {\n    uint public balance;\n    address public owner;\n\n    mapping(address =&gt; uint) public allowances;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit(uint value) public {\n        balance += value;\n    }\n\n    function withdraw(uint value) public {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n        (bool ok, ) = msg.sender.call{value: value}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    function transfer(address to, uint value) public {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n        (bool ok1, ) = payable(to).call{value: value}(\"\");\n        require(ok1, \"Transfer failed\");\n    }\n\n    function approve(address spender, uint value) public {\n        allowances[spender] = value;\n    }\n\n    function transferFrom(address from, address to, uint value) public {\n        require(allowances[from] &gt;= value, \"Allowance exceeded\");\n        allowances[from] -= value;\n        (bool ok2, ) = payable(to).call{value: value}(\"\");\n        require(ok2, \"Transfer failed\");\n    }\n\n    function upgradeLogic() public {\n        require(msg.sender == owner, \"Not authorized\");\n        // Upgrading logic is impossible without deploying a new contract.\n    }\n}\n</code></pre> <p>Problem: The contract has a monolithic design, tightly coupling storage, business logic, and access control. This makes upgrading or fixing specific parts difficult.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#improved-modular-contract-architecture","title":"Improved Modular Contract Architecture","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract ModularVault {\n    uint public balance;\n    address public owner;\n\n    modifier onlyOwner() { require(msg.sender == owner, \"Not authorized\"); _; }\n\n    constructor() { owner = msg.sender; }\n\n    function deposit(uint value) external { _deposit(value); }\n    function withdraw(uint value) external { _withdraw(value); }\n\n    function _deposit(uint value) internal { balance += value; }\n    function _withdraw(uint value) internal {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n        (bool ok, ) = msg.sender.call{value: value}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> <p>Solution: Use modular internal functions (<code>_deposit</code>, <code>_withdraw</code>) to separate concerns. For full upgradeability with preserved state, implement a proxy pattern (see SCWE-005).</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/","title":"SCWE-002: Excessive Contract Complexity","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#relationships","title":"Relationships","text":"<ul> <li>CWE-710: Improper Adherence to Coding Standards https://cwe.mitre.org/data/definitions/710.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#description","title":"Description","text":"<p>Excessive contract complexity refers to situations where the design or implementation of a smart contract becomes overly complicated, making it difficult to understand, audit, and maintain. Such complexity increases the likelihood of introducing bugs and vulnerabilities that may not be apparent during development or testing. It often arises from:</p> <ul> <li>Overuse of complex inheritance structures or external libraries.</li> <li>Too many functions, interdependencies, and conditions within the contract.</li> <li>Unnecessarily convoluted logic that could be simplified.</li> </ul> <p>The more complex the code, the higher the chance that mistakes are made, especially if future developers or auditors need to interact with the contract. Complexity can lead to hidden vulnerabilities that may be exploited over time.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#remediation","title":"Remediation","text":"<ul> <li>Refactor and simplify the code: Break down complex functions into smaller, easier-to-understand components.</li> <li>Limit inheritance depth: Use inheritance judiciously and prefer composition over deep inheritance chains.</li> <li>Use clear and descriptive names: Functions, variables, and events should have self-explanatory names that indicate their purpose.</li> <li>Avoid redundant logic: Consolidate repeated logic into reusable functions or libraries.</li> <li>Ensure modularity: Split the contract into manageable modules that focus on specific tasks, improving readability and maintainability.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#excessive-complexity","title":"Excessive Complexity","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract ComplexContract {\n    uint public balance;\n    address public owner;\n\n    function ComplexFunction1(uint value) public {\n        // Complex logic with many conditions\n        if (value &gt; 10) {\n            // do something\n        }\n        // Multiple nested functions and too many conditions\n        for (uint i = 0; i &lt; value; i++) {\n            if (i % 2 == 0) {\n                // nested loop\n            }\n        }\n    }\n\n    function ComplexFunction2(address addr) public {\n        // Complex logic with external dependencies\n        SomeLibrary.someFunction(addr);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#simplified-version","title":"Simplified Version","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SimpleContract {\n    uint public balance;\n    address public owner;\n\n    function deposit(uint value) public {\n        balance += value;\n    }\n\n    function withdraw(uint value) public {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n        // Note: Simplified example \u2014 internal accounting only. For ETH vaults, add payable(msg.sender).call{value: value}(\"\") and require(success).\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/","title":"SCWE-003: Lack of Modularity","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#relationships","title":"Relationships","text":"<ul> <li>CWE-1047: Modules with Circular Dependencies   https://cwe.mitre.org/data/definitions/1047.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#description","title":"Description","text":"<p>Lack of modularity refers to a design flaw where a system's components are not sufficiently separated into independent, reusable modules. This deficiency leads to tightly coupled code, making the system difficult to understand, maintain, and extend. In the context of smart contracts, this manifests as monolithic contracts where all functionalities are bundled together, increasing complexity and the potential for errors.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#remediation","title":"Remediation","text":"<ul> <li>Modular Design: Break down the contract into smaller, focused modules that handle specific responsibilities.</li> <li>Use of Libraries: Leverage existing, well-tested libraries to handle common functionalities, reducing the need for custom code.</li> <li>Simplify Logic: Avoid unnecessary complexity by streamlining the contract's logic and removing redundant code.</li> <li>Regular Audits: Conduct periodic code reviews and audits to identify and address areas of excessive complexity.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#example-of-lack-of-modularity","title":"Example of Lack of Modularity:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract TightlyCoupledContract {\n    mapping(address =&gt; uint) public balances;\n    mapping(address =&gt; mapping(address =&gt; uint)) public allowances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient funds\");\n        balances[msg.sender] -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    function transfer(address to, uint amount) public {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient funds\");\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n\n    function approve(address spender, uint amount) public {\n        allowances[msg.sender][spender] = amount;\n    }\n\n    function transferFrom(address from, address to, uint amount) public {\n        require(allowances[from][msg.sender] &gt;= amount, \"Allowance exceeded\");\n        allowances[from][msg.sender] -= amount;\n        balances[from] -= amount;\n        balances[to] += amount;\n    }\n}\n</code></pre> <p>Problem: Instead of separating concerns into independent, reusable modules, everything is handled within one contract.</p> <p>Why is this lack of modularity?</p> <ul> <li>Single contract handling multiple responsibilities (balance management, approvals, transfers).</li> <li>Code is not reusable: If another contract needs balance functions, it must copy-paste this logic.</li> <li>Testing is harder: Changing transfer() might break withdraw(), as they're tightly coupled.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#refactored-with-modular-design","title":"Refactored with Modular Design:","text":"<pre><code>pragma solidity ^0.8.0;\n\nlibrary BalanceLibrary {\n    struct Data {\n        mapping(address =&gt; uint) balances;\n    }\n\n    function deposit(Data storage self, address user, uint amount) internal {\n        self.balances[user] += amount;\n    }\n\n    function withdraw(Data storage self, address user, uint amount) internal {\n        require(self.balances[user] &gt;= amount, \"Insufficient funds\");\n        self.balances[user] -= amount;\n        (bool ok, ) = payable(user).call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n\nlibrary AllowanceLibrary {\n    struct Data {\n        mapping(address =&gt; mapping(address =&gt; uint)) allowances;\n    }\n\n    function approve(Data storage self, address owner, address spender, uint amount) internal {\n        self.allowances[owner][spender] = amount;\n    }\n\n    function transferFrom(\n        Data storage self,\n        BalanceLibrary.Data storage balances,\n        address from,\n        address to,\n        uint amount\n    ) internal {\n        require(self.allowances[from][msg.sender] &gt;= amount, \"Allowance exceeded\");\n        require(balances.balances[from] &gt;= amount, \"Insufficient funds\");\n\n        self.allowances[from][msg.sender] -= amount;\n        balances.balances[from] -= amount;\n        balances.balances[to] += amount;\n    }\n}\n\ncontract ModularContract {\n    using BalanceLibrary for BalanceLibrary.Data;\n    using AllowanceLibrary for AllowanceLibrary.Data;\n\n    BalanceLibrary.Data private balances;\n    AllowanceLibrary.Data private allowances;\n\n    function deposit() public payable {\n        balances.deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint amount) public {\n        balances.withdraw(msg.sender, amount);\n    }\n\n    function approve(address spender, uint amount) public {\n        allowances.approve(msg.sender, spender, amount);\n    }\n\n    function transferFrom(address from, address to, uint amount) public {\n        allowances.transferFrom(balances, from, to, amount);\n    }\n}\n</code></pre> <p>Solution: Use libraries for shared functionality and separate contract concerns. Now, storage is separated, reusable libraries are used, and responsibilities are divided!</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/","title":"SCWE-004: Uncaught Exceptions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#relationships","title":"Relationships","text":"<ul> <li>CWE-703: Improper Check or Handling of Exceptional Conditions https://cwe.mitre.org/data/definitions/703.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#description","title":"Description","text":"<p>Uncaught exceptions occur when a smart contract fails to properly handle errors, leading to unintended behaviors, lost funds, or denial of service (DoS). In Solidity, low-level calls such as <code>call()</code>, <code>delegatecall()</code>, and <code>send()</code> return a boolean instead of reverting automatically, requiring explicit checks. Ignoring return values or using <code>assert()</code> instead of <code>require()</code> can result in vulnerabilities that attackers can exploit.</p> <p>Common issues with uncaught exceptions: - Ignoring return values of <code>call()</code>, <code>delegatecall()</code>, <code>send()</code> - Unchecked external contract calls - Incorrect use of <code>assert()</code> instead of <code>require()</code> - Failure to catch errors in <code>try/catch</code> blocks</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#remediation","title":"Remediation","text":"<ul> <li>Check Return Values: Always verify the return values of low-level calls to ensure execution succeeded.</li> <li>Use <code>require()</code> for Input Validation: <code>require()</code> should be used for checking user input, while <code>assert()</code> should only be used for invariants.</li> <li>Implement Try/Catch: Use <code>try/catch</code> when interacting with external contracts to prevent silent failures.</li> <li>Use Safe Libraries: Utilize OpenZeppelin\u2019s <code>SafeERC20</code> for secure token transfers.</li> <li>Minimize External Dependencies: Avoid relying on external contract behavior unless necessary.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#example-1-uncaught-exception","title":"Example 1: Uncaught Exception:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UncheckedCall {\n    function execute(address target, bytes memory data) public payable {\n        target.call{value: msg.value}(data); // \u274c No success check\n    }\n}\n</code></pre> <p>In the above example, <code>call()</code> returns a boolean indicating success, but it is ignored, which can lead to silent failures.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#refactored-to-handle-exceptions-properly","title":"Refactored to Handle Exceptions Properly:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SafeCall {\n    function execute(address target, bytes memory data) public payable {\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n        require(success, \"Call execution failed\"); // \u2705 Handle failure\n    }\n}\n</code></pre> <p>In this improved version, the contract checks whether <code>call()</code> was successful, preventing execution from continuing on failure.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#example-2-bad-practice-using-assert-instead-of-require","title":"Example 2: Bad Practice (Using assert() Instead of require())","text":"<ul> <li>Problem: Using assert() for input validation instead of require().</li> </ul> <pre><code>pragma solidity ^0.8.0;\n\ncontract WrongAssertion {\n    function withdraw(uint256 amount) public {\n        assert(amount &gt; 0); // \u274c Assert should not be used for input validation\n        // Withdraw logic here\n    }\n}\n</code></pre> <p>Why is this vulnerable? - <code>assert()</code> is meant for invariants, not input validation. - If <code>assert()</code> fails, it consumes all remaining gas and does not return gas to the caller.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#better-practice-fixing-input-validation","title":"Better Practice (Fixing Input Validation)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract CorrectValidation {\n    function withdraw(uint256 amount) public {\n        require(amount &gt; 0, \"Invalid amount\"); // \u2705 Proper validation\n        // Withdraw logic here\n    }\n}\n</code></pre> - Now, a proper <code>require()</code> statement prevents execution if amount is invalid.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#example-3-bad-practice-failure-to-catch-errors-in-trycatch","title":"Example 3: Bad Practice (Failure to Catch Errors in Try/Catch)","text":"<ul> <li>Problem: Not using try/catch for external contract calls.</li> </ul> <pre><code>pragma solidity ^0.8.0;\n\ninterface ExternalContract {\n    function riskyFunction() external;\n}\n\ncontract NoErrorHandling {\n    function callExternal(address contractAddr) public {\n        ExternalContract(contractAddr).riskyFunction(); // \u274c No error handling\n    }\n}\n</code></pre> <p>Why is this vulnerable? - If riskyFunction() fails, the transaction completely reverts. - There is no way to recover or take alternative action.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#better-practice-using-trycatch-for-external-calls","title":"Better Practice (Using Try/Catch for External Calls)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ninterface ExternalContract {\n    function riskyFunction() external;\n}\n\ncontract SafeExternalCall {\n    function callExternal(address contractAddr) public {\n        try ExternalContract(contractAddr).riskyFunction() {\n            // \u2705 Success case\n        } catch {\n            revert(\"External call failed\"); // \u2705 Catch and handle failure\n        }\n    }\n}\n</code></pre> - Now, errors are properly caught, and alternative actions can be taken.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/","title":"SCWE-005: Insecure Upgradeable Proxy Design","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#relationships","title":"Relationships","text":"<ul> <li>CWE-668: Exposure of Resource to Wrong Sphere   https://cwe.mitre.org/data/definitions/668.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#description","title":"Description","text":"<p>Insecure upgradeable proxy designs occur when a smart contract implements an upgradeable proxy pattern without properly securing or validating upgrades. This may allow unauthorized actors to change the contract\u2019s logic, possibly introducing malicious behavior. It often happens when the upgrade functionality lacks proper access controls or when there is no timelock to delay the upgrade, giving malicious actors an opportunity to exploit the contract.</p> <p>This vulnerability can lead to critical failures, including the redirection of contract calls to malicious logic or unauthorized updates that compromise the integrity of the contract.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#remediation","title":"Remediation","text":"<ul> <li>Access Control: Ensure only trusted parties (e.g., contract owners, multisig wallets) can perform upgrades.</li> <li>Timelock Mechanism: Implement a timelock to delay upgrades and provide transparency.</li> <li>Transparent Proxy Pattern: Use patterns that prevent unauthorized contract logic changes, such as the Transparent Proxy Pattern.</li> <li>Audit Proxy Logic Regularly: Conduct regular audits to ensure that the upgrade mechanism is secure and follows best practices.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#vulnerable-proxy-contract","title":"Vulnerable Proxy Contract","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract VulnerableProxy {\n    address public implementation;\n    address public owner;\n\n    function setImplementation(address _implementation) public {\n        require(msg.sender == owner, \"Only owner can set implementation\");\n        implementation = _implementation;\n    }\n\n    function () public payable {\n        address _impl = implementation;\n        require(_impl != address(0), \"Implementation address is zero\");\n        assembly {\n            let result := delegatecall(gas, _impl, add(msg.data, 0x20), mload(msg.data), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            return(ptr, size)\n        }\n    }\n}\n</code></pre> In this example, the <code>VulnerableProxy</code> contract allows the owner to update the implementation contract. If the owner is compromised, they can point the proxy to a malicious implementation, allowing the attacker to control the contract's logic.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#fixed-proxy-contract-with-secure-upgrade-mechanism","title":"Fixed Proxy Contract with Secure Upgrade Mechanism","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract SecureProxy {\n    address public implementation;\n    address public owner;\n    uint public lastUpgradeTime;\n    uint public upgradeDelay = 1 days;  // 24 hours delay before upgrade\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can perform this action\");\n        _;\n    }\n\n    modifier upgradeable() {\n        require(block.timestamp &gt;= lastUpgradeTime + upgradeDelay, \"Upgrade not allowed yet\");\n        _;\n    }\n\n    function setImplementation(address _implementation) public onlyOwner upgradeable {\n        implementation = _implementation;\n        lastUpgradeTime = block.timestamp; // Update the last upgrade time\n    }\n\n    function () public payable {\n        address _impl = implementation;\n        require(_impl != address(0), \"Implementation address is zero\");\n        assembly {\n            let result := delegatecall(gas, _impl, add(msg.data, 0x20), mload(msg.data), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            return(ptr, size)\n        }\n    }\n}\n</code></pre> <p>In the fixed <code>SecureProxy</code> contract, the following changes have been made:</p> <ul> <li>Access Control: The <code>onlyOwner</code> modifier ensures that only the contract owner can update the proxy\u2019s implementation.</li> <li>Timelock Mechanism: The <code>upgradeable</code> modifier adds a delay (set to 1 day in this example) to prevent rapid contract upgrades. The contract cannot be upgraded until the specified time has passed since the last upgrade.</li> <li>Secure Upgrade Logic: The proxy logic is updated only after passing the necessary access control and timelock checks.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/","title":"SCWE-006: Inconsistent Inheritance Hierarchy","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#relationships","title":"Relationships","text":"<ul> <li>CWE-710: Improper Adherence to Coding Standards   https://cwe.mitre.org/data/definitions/710.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#description","title":"Description","text":"<p>Inconsistent inheritance hierarchies occur when a contract inherits from multiple contracts or libraries in an inconsistent or contradictory way. This leads to unexpected behavior or errors due to conflicting function implementations, state variables, or access controls. A proper and consistent inheritance structure is essential for clear logic and predictable contract execution.</p> <p>Some common issues in inheritance hierarchies include: - Ambiguous function overrides. - Conflicting variable definitions. - Misuse of multiple inheritance, which can lead to the diamond problem.</p> <p>Inconsistent inheritance can significantly compromise a contract\u2019s functionality and security, especially when multiple contracts or libraries with similar function names are used.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#remediation","title":"Remediation","text":"<ul> <li>Clear Inheritance Structure: Ensure that the inheritance hierarchy is logically structured and does not have overlapping functionalities or conflicting state variables.</li> <li>Use Explicit Overrides: Clearly override functions when necessary to avoid ambiguity, and ensure there is no unintentional function masking.</li> <li>Favor Single Inheritance or Controlled Multiple Inheritance: Avoid overly complex inheritance structures; if multiple inheritance is necessary, consider using design patterns like the Diamond Problem Resolver (i.e., using interfaces or abstract contracts).</li> <li>Regular Audits: Periodically audit the inheritance structure to identify any inconsistencies early on.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#vulnerable-contract-with-inconsistent-inheritance","title":"Vulnerable Contract with Inconsistent Inheritance","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract ParentA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract ParentB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value * 2;\n    }\n}\n\ncontract Child is ParentA, ParentB {\n    function setValue(uint _value) public {\n        // Ambiguity: which `setValue` should be called?\n        ParentA.setValue(_value);\n    }\n}\n</code></pre> In the above example, the <code>Child</code> contract inherits from both <code>ParentA</code> and <code>ParentB</code>. Both parent contracts define the <code>setValue</code> function. There is no clear indication of which function should be called, leading to ambiguity and potential bugs or undesired behavior.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#fixed-contract-with-consistent-inheritance","title":"Fixed Contract with Consistent Inheritance","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract ParentA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract ParentB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value * 2;\n    }\n}\n\ncontract Child is ParentA {\n    // Clear function override, only inherits from one parent\n    function setValue(uint _value) public {\n        ParentA.setValue(_value);\n    }\n}\n</code></pre> In the fixed version of the contract, the <code>Child</code> contract only inherits from one parent (<code>ParentA</code>), which resolves the ambiguity. If both <code>ParentA</code> and <code>ParentB</code> were needed, explicit overriding or more careful contract design would be required to ensure the correct functionality.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/","title":"SCWE-051: Improper Use of CREATE2 for Contract Deployment","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#relationships","title":"Relationships","text":"<ul> <li>CWE-706: Use of Incorrectly-Resolved Name or Reference https://cwe.mitre.org/data/definitions/706.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#description","title":"Description","text":"<p>The <code>CREATE2</code> opcode allows for deterministic contract deployment, meaning the contract's address can be precomputed before deployment. However, improper handling of the salt parameter, constructor arguments, or contract bytecode can lead to vulnerabilities such as address predictability, re-deployment attacks, and malicious contract substitution. If an attacker can influence the salt or code, they may deploy a contract at a known address before the legitimate one, leading to security risks.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#remediation","title":"Remediation","text":"<p>To prevent misuse of <code>CREATE2</code>: - Use unpredictable and unique salt values (e.g., incorporating nonces, sender addresses, or randomness). - Ensure the deployed contract logic remains consistent to prevent re-deployment attacks. - Hash important contract parameters into the salt to prevent unintended address collisions.  </p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Factory {\n    function deploy(bytes32 salt, bytes memory bytecode) public {\n        address deployed;\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n    }\n}\n</code></pre> <p>Why is this vulnerable?</p> <ul> <li>If <code>salt</code> is predictable (e.g., user-supplied or a static value), an attacker can precompute and front-run the deployment.</li> <li>The same contract address can be re-used by deploying different bytecode, leading to logic changes at a fixed address.</li> <li>No validation ensures that the deployed contract is safe or expected.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureFactory {\n    function deploy(bytes32 salt, bytes memory bytecode) public returns (address) {\n        require(bytecode.length &gt; 0, \"Bytecode cannot be empty\");\n\n        // Ensure the salt includes sender information to prevent front-running\n        bytes32 secureSalt = keccak256(abi.encodePacked(msg.sender, salt));\n\n        address deployed;\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), secureSalt)\n        }\n\n        require(deployed != address(0), \"Deployment failed\");\n        return deployed;\n    }\n}\n</code></pre> <p>Why is this safe? - Uses <code>keccak256(abi.encodePacked(msg.sender, salt))</code> to make the salt unique per sender. - Ensures the contract bytecode is non-empty before deploying. - Validates that the deployed contract is nonzero, ensuring a successful deployment.</p> <p>By securing CREATE2 deployments, developers can prevent predictable contract addresses, front-running risks, and contract replacement vulnerabilities.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/","title":"SCWE-052: Transaction Order Dependence","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#description","title":"Description","text":"<p>Transaction Order Dependence (TOD) occurs when the outcome of a contract's execution depends on the order of transactions. Attackers can exploit this issue by submitting transactions in a specific order, manipulating the contract's state and gaining an unfair advantage, such as front-running or back-running other transactions. This can lead to unexpected behavior and resource consumption.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#remediation","title":"Remediation","text":"<p>To mitigate TOD vulnerabilities, ensure that the contract's logic does not depend on transaction order. Use techniques like commit-reveal schemes or randomization to prevent attackers from predicting the transaction order and exploiting it.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract TODExample {\n    address public winner;\n\n    function bid() public payable {\n        require(msg.value &gt; 1 ether, \"Bid too low\");\n        winner = msg.sender;  // Dependent on transaction order\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract FixedTODExample {\n    address public winner;\n    uint public highestBid;\n\n    function bid() public payable {\n        require(msg.value &gt; highestBid, \"Bid too low\");\n        highestBid = msg.value;\n        winner = msg.sender;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/","title":"SCWE-064: Incorrect Inheritance Order","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#relationships","title":"Relationships","text":"<ul> <li>CWE-1001: Variable Shadowing https://cwe.mitre.org/data/definitions/1001.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#description","title":"Description","text":"<p>Incorrect inheritance order in Solidity can lead to unintended behavior, especially when multiple base contracts define similar variables or functions. Solidity\u2019s linearization of the inheritance order can result in one contract unintentionally overriding or shadowing variables or functions defined in a parent contract, leading to confusion, errors, and potential vulnerabilities.</p> <p>In Solidity, the order of inheritance matters. If the inheritance hierarchy is not properly structured, the wrong version of a variable or function may be called, causing bugs or security issues.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, carefully review and order the inheritance structure. Ensure that parent contracts are inherited in a logical sequence and that any variables or functions are not unintentionally shadowed or overridden. Consider following a clear and consistent inheritance pattern.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract BaseA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract BaseB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value + 1;  // Different implementation\n    }\n}\n\ncontract Child is BaseB, BaseA {\n    function setValue(uint _value) public {\n        value = _value + 2;  // Shadows value from BaseA or BaseB\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract BaseA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract BaseB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value + 1;  // Different implementation\n    }\n}\n\ncontract Child is BaseA, BaseB {\n    function setValue(uint _value) public {\n        value = _value + 2;  // Calls setValue from BaseA or BaseB intentionally\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/","title":"SCWE-070: Incorrect Constructor Name","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#relationships","title":"Relationships","text":"<ul> <li>CWE-1001: Variable Shadowing https://cwe.mitre.org/data/definitions/1001.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#description","title":"Description","text":"<p>In Solidity, the constructor is a special function used to initialize a contract's state variables when it is deployed. If a constructor is incorrectly named, it will not function as expected, leading to issues such as failing to initialize state variables or triggering unexpected behavior. The constructor must have the exact name of the contract and no return type.</p> <p>If the constructor name is not correct, it will not be executed as intended, and the contract may not behave as expected, potentially leaving it in an uninitialized or inconsistent state.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#remediation","title":"Remediation","text":"<p>Ensure that the constructor has the correct name, which must match the contract name and contain no return type. In newer versions of Solidity (0.4.22 and later), the constructor keyword is used instead of the contract name for constructor functions.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Example {\n    uint public value;\n\n    // In Solidity &lt;0.4.22, constructor had to match contract name. In 0.5+, this is a regular function, not a constructor.\n    function Example() public {\n        value = 10;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    uint public value;\n\n    // Correct constructor definition (Solidity &gt;=0.4.22)\n    constructor() {  // Use \"constructor\" instead of the contract name\n        value = 10;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/","title":"SCWE-071: Uninitialized Storage Pointer","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#relationships","title":"Relationships","text":"<ul> <li>CWE-457: Use of Uninitialized Variable https://cwe.mitre.org/data/definitions/457.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#description","title":"Description","text":"<p>An uninitialized storage pointer in Solidity refers to a variable that has been declared but not assigned a value before being used. This can result in unpredictable behavior, as the variable might point to unintended locations in the contract's storage, potentially exposing sensitive data or allowing attackers to exploit the uninitialized pointer. This is a critical issue because Solidity does not automatically initialize storage variables, leaving them with default values that may be unsafe.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#remediation","title":"Remediation","text":"<p>Always initialize storage pointers to avoid potential vulnerabilities. Ensure that all variables, especially storage pointers, are properly assigned a value before being used. This prevents accessing uninitialized or garbage data from the contract\u2019s storage.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    uint[] public data;\n\n    // Uninitialized storage pointer, could lead to unexpected behavior\n    function addData(uint _value) public {\n        data.push(_value);\n        uint[] storage uninitializedPointer;  // Pointer is uninitialized\n        uninitializedPointer.push(10);  // Accessing uninitialized storage pointer\n    }\n}\n</code></pre> <p>Why is this vulnerable? - <code>uninitializedPointer</code> is a storage pointer but is not assigned a reference to valid storage. - Writing to <code>uninitializedPointer.push(10);</code> could overwrite unintended storage locations.</p> <p>Potential outcomes: - Corrupting storage layout (e.g., overwriting contract variables). - Unexpected behaviors due to storage reallocation.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n      uint[] public data;\n\n      function addData(uint _value) public {\n          data.push(_value);\n          uint[] storage initializedPointer = data;  // \u2705 Properly initialized storage pointer\n          initializedPointer.push(10);  // \u2705 Safely interacts with the intended storage\n      }\n  }\n</code></pre> <p>Why is this safe? - <code>initializedPointer</code> explicitly references <code>data</code>, ensuring that it does not point to an arbitrary storage slot. - Prevents unintended overwrites of contract state. - Ensures expected behavior and protects contract integrity.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/","title":"SCWE-080: Incorrect Type Conversion","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#relationships","title":"Relationships","text":"<ul> <li>CWE-704: Incorrect Type Conversion or Cast https://cwe.mitre.org/data/definitions/704.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#description","title":"Description","text":"<p>Incorrect type conversion occurs when a value is cast or implicitly converted between incompatible types, potentially leading to precision loss, unexpected behavior, or security vulnerabilities. Solidity allows certain implicit conversions (e.g., from <code>uint256</code> to <code>uint8</code>), which can lead to silent truncation of data. Additionally, casting between types like <code>address</code> and <code>uint</code> can lead to unexpected security risks.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#remediation","title":"Remediation","text":"<ul> <li>Avoid unsafe downcasts from larger to smaller types unless explicitly required.  </li> <li>Always validate the range before converting between numerical types.  </li> <li>Use explicit conversion functions where applicable, ensuring proper handling of edge cases.  </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function unsafeDowncast(uint256 value) public pure returns (uint8) {\n        return uint8(value);  // \u274c Truncates value if &gt; 255\n    }\n\n    function unsafeAddressToUint(address addr) public pure returns (uint256) {\n        return uint256(uint160(addr));  // \u274c May lead to unexpected behaviors\n    }\n}\n</code></pre> Why is this vulnerable?</p> <ul> <li><code>uint8(value)</code> will silently truncate values above 255, leading to unintended loss of data.</li> <li><code>uint256(uint160(addr))</code> might be used incorrectly in arithmetic operations, potentially allowing address manipulation.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureExample {\n    function safeDowncast(uint256 value) public pure returns (uint8) {\n        require(value &lt;= type(uint8).max, \"Value exceeds uint8 range\");  // \u2705 Ensure valid range\n        return uint8(value);\n    }\n\n    function safeAddressToUint(address addr) public pure returns (uint160) {\n        return uint160(addr);  // \u2705 Restrict conversion to valid 160-bit range\n    }\n}\n</code></pre> Why is this safe?</p> <ul> <li>Ensures that values do not exceed the allowed range before downcasting.</li> <li>Restricts type conversion to avoid security risks from improper arithmetic operations.</li> <li>Prevents silent data loss that could lead to unintended contract behavior.</li> </ul> <p>By enforcing safe type conversions, developers can ensure contract logic remains reliable and free from unexpected truncation issues.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/","title":"SCWE-098: Initialization Front-Running in Upgradeable Contracts","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/#relationships","title":"Relationships","text":"<ul> <li>CWE-284: Improper Access Control https://cwe.mitre.org/data/definitions/284.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/#description","title":"Description","text":"<p>Proxy-based contracts ship without constructors; if the initializer is callable by anyone, an attacker can front-run deployment and seize ownership, set trusted roles, or lock upgrades. This permanently compromises the implementation behind the proxy.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/#remediation","title":"Remediation","text":"<ul> <li>Protect initializer functions with access control and <code>initializer</code>/<code>reinitializer</code> guards.</li> <li>Invoke initialization atomically during deployment or via a deploy-time call data payload.</li> <li>Use <code>disableInitializers()</code> on the implementation contract to prevent accidental takeover.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract UpgradeableVault is Initializable {\n    address public owner;\n\n    function initialize(address _owner) public initializer {\n        owner = _owner; // anyone can front-run and become owner\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-098/#fixed","title":"Fixed","text":"<p><pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract UpgradeableVault is Initializable {\n    address public owner;\n\n    function initialize(address _owner, address deployer) public initializer {\n        require(msg.sender == deployer, \"only deployer\");\n        owner = _owner;\n    }\n}\n</code></pre> Deployer (or factory) deploys the proxy and calls <code>initialize(owner, address(this))</code> in the same transaction \u2014 no window for front-running.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/","title":"SCWE-099: Storage Layout Collision on Upgrade","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/#relationships","title":"Relationships","text":"<ul> <li>CWE-664: Improper Control of a Resource Through its Lifetime https://cwe.mitre.org/data/definitions/664.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/#description","title":"Description","text":"<p>Upgradeable contracts rely on stable storage slots. Reordering, removing, or inserting state variables (or changing inheritance order) between versions causes storage collisions when the proxy reuses the same slots, corrupting balances, roles, or configuration.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/#remediation","title":"Remediation","text":"<ul> <li>Freeze variable ordering; only append new variables.</li> <li>Reserve gaps (<code>uint256[50] private __gap;</code>) to allow future expansion.</li> <li>Use automated storage layout diffing and follow upgrade-safe patterns (e.g., OZ Upgradeable tooling).</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract V1 {\n    address public owner;   // slot 0\n    uint256 public balance; // slot 1\n}\n\ncontract V2 is V1 {\n    uint256 public balance; // reuses slot 1, corrupts state\n    address public treasury;\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-099/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract V1 {\n    address public owner;   // slot 0\n    uint256 public balance; // slot 1\n    uint256[48] private __gap;\n}\n\ncontract V2 is V1 {\n    uint256 public treasuryFee; // slot 2 (after gap)\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/","title":"SCWE-117: Proxy Implementation Selfdestruct Exposure","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/#relationships","title":"Relationships","text":"<ul> <li>CWE-284: Improper Access Control https://cwe.mitre.org/data/definitions/284.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/#description","title":"Description","text":"<p>If the proxy\u2019s implementation contract exposes <code>selfdestruct</code> (or <code>SELFDESTRUCT</code> reachable through a function), an attacker or careless admin can destroy the implementation. The proxy then points to a non-existent code address, bricking upgrades or locking funds.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/#remediation","title":"Remediation","text":"<ul> <li>Remove or disable <code>selfdestruct</code> in implementations; use <code>disableInitializers()</code> patterns.</li> <li>Gate any destruct-like functionality behind timelock + multisig and migration plans.</li> <li>Monitor implementation addresses and block upgrades that reduce code size to zero.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Impl {\n    function kill() external {\n        selfdestruct(payable(msg.sender));\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-117/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Impl {\n    // no selfdestruct path; migrations use new proxy with state copy\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/","title":"SCWE-118: Unauthenticated Beacon Upgrade","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/#relationships","title":"Relationships","text":"<ul> <li>CWE-306: Missing Authentication for Critical Function https://cwe.mitre.org/data/definitions/306.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/#description","title":"Description","text":"<p>Beacon proxies rely on a beacon address that determines implementation. If the beacon upgrade function lacks proper access control or timelock, an attacker can point all proxies to malicious code, taking over state and funds.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/#remediation","title":"Remediation","text":"<ul> <li>Restrict beacon upgrades to multisig+timelock and emit events on change.</li> <li>Validate new implementation bytecode (e.g., initializer disabled, interfaces intact).</li> <li>Monitor beacon address changes on-chain with alerts.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Beacon {\n    address public impl;\n    function upgradeTo(address newImpl) external { // no auth\n        impl = newImpl;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-118/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Beacon {\n    address public impl;\n    address public admin;\n    function upgradeTo(address newImpl) external {\n        require(msg.sender == admin, \"not admin\");\n        impl = newImpl;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/","title":"SCWE-119: Shared Proxy Admin and Logic Owner Key","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/#relationships","title":"Relationships","text":"<ul> <li>CWE-284: Improper Access Control https://cwe.mitre.org/data/definitions/284.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/#description","title":"Description","text":"<p>Using the same key to control both the proxy admin (upgrade rights) and logic contract owner concentrates power. A single key compromise allows hostile upgrades and privileged function abuse with no separation of duties.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/#remediation","title":"Remediation","text":"<ul> <li>Separate roles: proxy admin under multisig+timelock; logic owner under different multisig.</li> <li>Use role-based access (e.g., OZ AccessControl) and distinct keys for operational vs. upgrade actions.</li> <li>Document and monitor role boundaries; rotate keys periodically.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Proxy {\n    address public admin; // same key for upgrades and logic owner\n    address public implementation;\n\n    modifier onlyAdmin() { require(msg.sender == admin, \"not admin\"); _; }\n\n    function upgrade(address impl) external onlyAdmin { implementation = impl; }\n    function setParam(uint256 x) external onlyAdmin { /* ... */ }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-119/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Proxy {\n    address public proxyAdmin;   // timelock + multisig; upgrade rights only\n    address public logicOwner;  // separate multisig; operational params only\n    address public implementation;\n\n    modifier onlyProxyAdmin() { require(msg.sender == proxyAdmin, \"not proxy admin\"); _; }\n    modifier onlyLogicOwner() { require(msg.sender == logicOwner, \"not logic owner\"); _; }\n\n    function upgrade(address impl) external onlyProxyAdmin { implementation = impl; }\n    function setParam(uint256 x) external onlyLogicOwner { /* ... */ }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/","title":"SCWE-145: Unvalidated Constructor Parameters","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/#description","title":"Description","text":"<p>Constructors that accept critical parameters (owner, oracle, fee recipient, token addresses) without validation can deploy a contract in a broken or insecure state. Zero addresses, invalid values, or inconsistent configuration (e.g., fee &gt; 100%) may be impossible to fix after deployment if there is no setter or upgrade path.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/#remediation","title":"Remediation","text":"<ul> <li>Validate all constructor parameters: zero address checks, range checks (e.g., fee &lt;= 100%), and consistency checks.</li> <li>Use <code>require</code> or custom errors to revert deployment with a clear message when validation fails.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Staking {\n    address public owner;\n    address public rewardToken;\n    uint256 public feeBps;\n\n    constructor(address _owner, address _rewardToken, uint256 _feeBps) {\n        owner = _owner;           // No validation\n        rewardToken = _rewardToken;\n        feeBps = _feeBps;         // Could be &gt; 10000\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-145/#fixed","title":"Fixed","text":"<pre><code>constructor(address _owner, address _rewardToken, uint256 _feeBps) {\n    require(_owner != address(0), \"Invalid owner\");\n    require(_rewardToken != address(0), \"Invalid token\");\n    require(_feeBps &lt;= 10000, \"Fee too high\");\n    owner = _owner;\n    rewardToken = _rewardToken;\n    feeBps = _feeBps;\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/","title":"SCWE-150: Storage Slot Collision When Upgrading Implementation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/#description","title":"Description","text":"<p>When upgrading a proxy's implementation, the new implementation's storage layout must be compatible with the proxy's storage. Appending variables in the implementation without accounting for the proxy's own storage (e.g., admin, implementation address) can cause slot collisions. Similarly, inherited contracts that add state variables can overwrite slots used by the base or proxy. SCWE-099 covers same-contract layout; this addresses cross-contract layout (proxy + implementation, inheritance chain).</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/#remediation","title":"Remediation","text":"<ul> <li>Use a single storage contract or follow a consistent storage layout convention (e.g., EIP-1967).</li> <li>Reserve gaps (<code>uint256[50] private __gap</code>) in base contracts for future expansion.</li> <li>Run storage layout diff tools before upgrading.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/#vulnerable","title":"Vulnerable","text":"<pre><code>// Proxy\ncontract Proxy {\n    address public implementation;  // slot 0\n    address public admin;           // slot 1\n}\n\n// Implementation V2 - assumes it \"owns\" slots from 0\ncontract ImplV2 {\n    address public owner;      // slot 0 - COLLIDES with proxy's implementation\n    uint256 public newValue;   // slot 1 - COLLIDES with proxy's admin\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-150/#fixed","title":"Fixed","text":"<pre><code>contract ImplV2 {\n    // Storage in implementation must not overlap proxy slots\n    // Use EIP-1967 or append after reserved slots\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894...;\n    // Implementation state starts after proxy slots\n    uint256 public newValue;\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/","title":"SCWE-016: Insufficient Authorization Checks","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#relationships","title":"Relationships","text":"<ul> <li>CWE-862: Missing Authorization   https://cwe.mitre.org/data/definitions/862.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#description","title":"Description","text":"<p>Insufficient authorization occurs when the contract does not verify whether a user has the appropriate permissions to perform specific actions. This vulnerability arises when there are missing or improperly implemented authorization checks, allowing unauthorized users to access functions they should not have access to.</p> <p>Common causes of insufficient authorization include: - Missing access control modifiers or incorrect configuration. - Failure to validate roles before granting access to sensitive functions. - Poor handling of user permissions, which could lead to privilege escalation.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#remediation","title":"Remediation","text":"<ul> <li>Implement role-based access control (RBAC): Define roles such as <code>admin</code>, <code>user</code>, etc., and assign permissions accordingly to ensure only authorized users can call restricted functions.</li> <li>Use access control modifiers: Protect sensitive functions with appropriate modifiers (e.g., <code>onlyOwner</code>, <code>onlyAdmin</code>) to restrict access.</li> <li>Principle of least privilege: Ensure each user only has access to the minimal set of actions they need to perform their role.</li> <li>Thorough testing: Test for authorization vulnerabilities to ensure all restricted functions are properly secured.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#insufficient-authorization-example","title":"Insufficient Authorization Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InsufficientAuthorization {\n    uint public balance;\n\n    function withdraw(uint amount) public {\n        // No checks for user roles, any address can withdraw funds\n        balance -= amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#fixed-authorization-example","title":"Fixed Authorization Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract FixedAuthorization {\n    uint public balance;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        balance -= amount;\n    }\n}\n</code></pre> In the fixed example, the <code>onlyOwner</code> modifier ensures that only the contract owner can withdraw funds, thus preventing unauthorized users from performing sensitive operations like withdrawing assets.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/","title":"SCWE-017: Privileged Role Mismanagement","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#relationships","title":"Relationships","text":"<ul> <li>CWE-269: Improper Privilege Management https://cwe.mitre.org/data/definitions/269.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#description","title":"Description","text":"<p>Privileged role mismanagement occurs when a smart contract incorrectly assigns roles or permissions, granting excessive privileges to certain users. This can lead to users obtaining permissions beyond what is necessary for their intended function, creating a potential for privilege escalation or unauthorized actions. In the context of smart contracts, improper privilege management can lead to critical vulnerabilities such as unauthorized contract changes, malicious interactions, or loss of funds.</p> <p>Common causes include: - Insufficient checks for users attempting to access privileged functions. - Roles being dynamically assigned without validation. - Inadequate access control mechanisms for sensitive contract functions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#remediation","title":"Remediation","text":"<ul> <li>Role-based access control (RBAC): Implement strict role checks using modifiers to ensure that users can only perform actions that correspond to their assigned roles.</li> <li>Principle of least privilege: Limit the privileges of each role to the bare minimum needed to perform their task.</li> <li>Use of trusted or immutable sources: Ensure that privileged roles cannot be arbitrarily changed by unauthorized users or during attacks.</li> <li>Periodic reviews and audits: Regularly review roles and permissions to ensure they are correctly assigned and maintained.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#privileged-role-mismanagement-example","title":"Privileged Role Mismanagement Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract PrivilegedRoleMismanagement {\n    address public admin;\n    uint public balance;\n\n    function setAdmin(address _admin) public {\n        admin = _admin;\n    }\n\n    function withdraw(uint amount) public {\n        require(msg.sender == admin, \"Only admin can withdraw\");\n        balance -= amount;\n    }\n}\n</code></pre> <p>In the above example, there is no check for the address assigning the <code>admin</code> role, and it can be changed by anyone, including malicious actors.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#fixed-privileged-role-management","title":"Fixed Privileged Role Management","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract FixedRoleManagement {\n    address public owner;\n    uint public balance;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        balance -= amount;\n    }\n}\n</code></pre> In the fixed version, the <code>onlyOwner</code> modifier is used to ensure that only the owner can perform sensitive actions such as transferring ownership or withdrawing funds. This helps mitigate the risk of privilege mismanagement by enforcing access control at the contract level.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/","title":"SCWE-018: Use of tx.origin for Authorization","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#relationships","title":"Relationships","text":"<ul> <li>CWE-346: Origin Validation Error https://cwe.mitre.org/data/definitions/346.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#description","title":"Description","text":"<p>The use of <code>tx.origin</code> for authorization is a security vulnerability in which a smart contract checks the origin of the transaction to determine if a user is authorized to perform an action. This approach is flawed because <code>tx.origin</code> can be exploited by an attacker through a chain of transactions, allowing unauthorized users to interact with the contract. An attacker could trick the contract into performing an action on behalf of the victim by utilizing another contract in the transaction chain.</p> <p>Key Issues: - Allows unauthorized transactions by using the <code>tx.origin</code> variable instead of <code>msg.sender</code>. - Vulnerable to phishing and reentrancy attacks, where attackers can use contracts to impersonate the victim. - Mismanagement of roles and improper transaction flow handling.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#remediation","title":"Remediation","text":"<ul> <li>Use <code>msg.sender</code> instead of <code>tx.origin</code>: Always rely on <code>msg.sender</code> for authentication and authorization, as it correctly represents the immediate sender of the current call.</li> <li>Strict validation checks: Ensure that authorization checks are done on the direct sender of the transaction, i.e., <code>msg.sender</code>, and not the originator.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#vulnerable-contract-using-txorigin-for-authorization","title":"Vulnerable Contract (Using <code>tx.origin</code> for Authorization)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Vulnerable {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function restrictedAction() public {\n        require(tx.origin == owner, \"Only the owner can perform this action\");\n        // Action code here\n    }\n}\n</code></pre> In the vulnerable contract, the authorization check uses <code>tx.origin</code> to validate the caller. This is a problem because if the contract is called via another contract, <code>tx.origin</code> will return the original transaction sender (not the immediate caller), which opens up the contract to attacks such as phishing. The attacker can create a contract that interacts with the vulnerable contract on behalf of the victim.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#fixed-contract-using-msgsender-for-authorization","title":"Fixed Contract (Using msg.sender for Authorization)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Secure {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function restrictedAction() public {\n        require(msg.sender == owner, \"Only the owner can perform this action\");\n        // Action code here\n    }\n}\n</code></pre> In the fixed contract, <code>msg.sender</code> is used instead of <code>tx.origin</code>. This ensures that the contract checks the immediate sender of the call, which prevents attacks where malicious contracts impersonate the victim.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/","title":"SCWE-019: Insecure Signature Verification","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature   https://cwe.mitre.org/data/definitions/347.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#description","title":"Description","text":"<p>Insecure signature verification occurs when a contract improperly verifies a cryptographic signature or fails to securely validate signatures, allowing attackers to forge or manipulate them. This vulnerability can allow unauthorized transactions or the bypassing of important security mechanisms, potentially leading to fraud, unauthorized access, or other attacks.</p> <p>Common causes of insecure signature verification include: - Not validating the signer's address. - Using weak or outdated cryptographic libraries. - Failing to check signature validity before processing actions. - Incorrectly handling the signature format.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#remediation","title":"Remediation","text":"<ul> <li>Verify signatures properly: Always verify that the signature matches the intended signer by using the <code>ecrecover</code> function for Ethereum addresses and comparing the result to the expected signer address.</li> <li>Use strong cryptographic methods: Ensure the use of robust cryptographic techniques and libraries. Avoid using outdated or weak algorithms.</li> <li>Use secure signature formats: Make sure that signature formats are validated properly (e.g., ensure proper handling of <code>v</code>, <code>r</code>, <code>s</code> values in Ethereum signatures).</li> <li>Implement checks before acting on the signature: Always perform checks for valid signature and relevant parameters before executing any logic that could be influenced by the signature.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#insecure-signature-verification","title":"Insecure Signature Verification","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureSignatureExample {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Insecure signature verification: does not properly validate the signature\n    function executeTransaction(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public {\n        address signer = ecrecover(hash, v, r, s);  // Signature verification\n        if (signer == owner) {\n            // Execute some sensitive action\n        }\n    }\n}\n</code></pre> In the insecure version, the contract checks if the signature corresponds to the owner but does not properly validate or handle potential issues with the signature, such as its format or correctness.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#fixed-signature-verification","title":"Fixed Signature Verification","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureSignatureExample {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Secure signature verification: properly checks signature and signer\n    function executeTransaction(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public {\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == owner, \"Invalid signature\");  // Ensure valid signature before proceeding\n        // Execute some sensitive action\n    }\n}\n</code></pre> In the fixed version, we use the <code>require()</code> function to ensure the signature matches the owner's address, thereby improving security by preventing unauthorized access or actions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/","title":"SCWE-020: Absence of Time-Locked Functions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#relationships","title":"Relationships","text":"<ul> <li>CWE-840: Business Logic Errors   https://cwe.mitre.org/data/definitions/840.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#description","title":"Description","text":"<p>Absence of time-locked functions occurs when smart contracts do not implement mechanisms to delay certain critical functions or actions based on time conditions. This can result in the contract allowing actions that should be restricted or postponed for a certain period, such as emergency fund withdrawals or sensitive administrative actions. Without time-locking mechanisms, malicious actors or faulty logic could trigger these actions at the wrong time, leading to undesired outcomes.</p> <p>Time-locking is commonly used in scenarios like: - Delaying admin or owner functions to prevent immediate misuse. - Ensuring withdrawal or fund transfer happens only after a predefined delay. - Enabling emergency actions only after a certain time or under specific conditions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#remediation","title":"Remediation","text":"<ul> <li>Implement time-locked functions: Ensure that critical functions, especially those related to fund transfers or administrative actions, are protected by a time lock, delaying their execution until an appropriate time has passed.</li> <li>Use block timestamps: Leverage block timestamps or block numbers to control the execution of functions.</li> <li>Limit emergency access: If implementing emergency mechanisms, ensure that there are time delays before they can be invoked, to reduce the chance of misuse.</li> <li>Review time-based logic regularly: Verify the correctness of time-based logic to ensure that the system behaves as intended.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#absence-of-time-locked-function","title":"Absence of Time-Locked Function","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract NoTimeLock {\n    address public owner;\n    uint public funds;\n\n    constructor() {\n        owner = msg.sender;\n        funds = 1000;\n    }\n\n    // Critical function without time-lock\n    function withdrawFunds(uint amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        funds -= amount;\n    }\n}\n</code></pre> In this example, the contract lacks any time-lock mechanism, allowing the owner to withdraw funds at any time, which could be dangerous if mishandled. </p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#time-locked-function-implementation","title":"Time-Locked Function Implementation","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TimeLockExample {\n    address public owner;\n    uint public funds;\n    uint public lastWithdrawalTime;\n    uint public withdrawalDelay = 1 weeks;\n\n    constructor() {\n        owner = msg.sender;\n        funds = 1000;\n        lastWithdrawalTime = block.timestamp;\n    }\n\n    // Critical function with time-lock\n    function withdrawFunds(uint amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        require(block.timestamp &gt;= lastWithdrawalTime + withdrawalDelay, \"Time lock not expired\");\n\n        lastWithdrawalTime = block.timestamp;\n        funds -= amount;\n    }\n}\n</code></pre> In the fixed version, a time-lock mechanism is implemented, ensuring that the owner can only withdraw funds after a certain delay (e.g., one week). This provides an added layer of security, particularly in cases where emergency withdrawals or administrative actions are necessary but should not be immediate.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/","title":"SCWE-038: Insecure Use of Selfdestruct","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource CWE-732 Link</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#description","title":"Description","text":"<p>Insecure use of selfdestruct refers to vulnerabilities that arise when the <code>selfdestruct</code> function is used without proper safeguards. This can lead to: - Unauthorized destruction of the contract. - Loss of funds or data. - Exploitation of vulnerabilities in contract logic.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#remediation","title":"Remediation","text":"<ul> <li>Restrict access: Ensure only authorized addresses can call <code>selfdestruct</code>. Note: <code>selfdestruct</code> is deprecated per EIP-6049 (Solidity 0.8.24+); prefer migration patterns where possible.</li> <li>Implement circuit breakers: Add mechanisms to halt operations in case of suspicious activity.</li> <li>Test thoroughly: Conduct extensive testing to ensure <code>selfdestruct</code> is used securely.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#examples","title":"Examples","text":"<ul> <li> <p>Insecure Selfdestruct Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureSelfdestruct {\n    function destroy() public {\n        selfdestruct(payable(msg.sender)); // No access control\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Selfdestruct Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureSelfdestruct {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\");\n        _;\n    }\n\n    function destroy() public onlyAdmin {\n        selfdestruct(payable(admin)); // Restricted to admin\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/","title":"SCWE-045: Insecure Use of Modifiers","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource CWE-732 Link</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#description","title":"Description","text":"<p>Insecure use of modifiers refers to vulnerabilities that arise when modifiers are used improperly. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of vulnerabilities in contract logic.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#remediation","title":"Remediation","text":"<ul> <li>Restrict access: Ensure only authorized addresses can use the modifier.</li> <li>Validate inputs: Ensure all inputs to the modifier are properly validated.</li> <li>Test thoroughly: Conduct extensive testing to ensure modifiers are secure.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#examples","title":"Examples","text":"<ul> <li>Insecure Modifier Usage (With Storage Bug) <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureModifier {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin; // \u274c Storage bug: Allows setting admin to zero address.\n    }\n\n    modifier onlyAdmin() {\n        require(admin == address(0), \"Unauthorized\"); // \u274c Wrong condition, only works if admin is zero!\n        _;\n    }\n\n    function updateAdmin(address newAdmin) public onlyAdmin {\n        admin = newAdmin; // \u274c Can set admin to zero address, breaking access control.\n    }\n\n    function updateBalance(uint newBalance) public onlyAdmin {\n        // Update balance\n    }\n}\n</code></pre></li> </ul> <p>Why is this Insecure? - Wrong Condition in <code>onlyAdmin()</code>     - <code>require(admin == address(0), \"Unauthorized\");</code> only allows function execution when admin is zero.     - This means no valid admin can ever execute admin functions!     - If admin is ever non-zero, all <code>onlyAdmin</code> functions become unusable.</p> <ul> <li> <p>Loss of Control</p> <ul> <li>If admin is accidentally set to <code>address(0)</code>, anyone can now execute admin functions, breaking security</li> </ul> </li> <li> <p>Secure Modifier Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureModifier {\n    address public admin;\n\n    constructor(address _admin) {\n        require(_admin != address(0), \"Invalid admin address\"); // \u2705 Proper validation\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\"); // \u2705 Correctly restricts access\n        _;\n    }\n\n    function updateAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"New admin cannot be zero address\"); // \u2705 Prevents admin loss\n        admin = newAdmin;\n    }\n\n    function updateBalance(uint newBalance) public onlyAdmin {\n        // Update balance securely\n    }\n}\n</code></pre></p> </li> </ul> <p>Why is this Secure? - Proper access control in <code>onlyAdmin()</code>     - <code>require(msg.sender == admin, \"Unauthorized\");</code> ensures only the correct admin can execute admin functions.         - Prevents privilege escalation - <code>updateAdmin()</code> prevents setting <code>admin = address(0)</code>, avoiding unintended loss of access.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/","title":"SCWE-049: Unprotected Ether Withdrawal","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource https://cwe.mitre.org/data/definitions/732.html </li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#description","title":"Description","text":"<p>Unprotected Ether withdrawal occurs when a smart contract allows withdrawal of Ether (ETH) without sufficient access control or proper authorization mechanisms. This vulnerability exposes the contract to unauthorized or malicious users, enabling them to drain funds without any checks on the withdrawal request.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#remediation","title":"Remediation","text":"<p>To prevent this vulnerability, implement strong access control mechanisms like the <code>onlyOwner</code> modifier or a more flexible role-based access control (RBAC) system. Ensure that only authorized users (e.g., the contract owner or specific users) can initiate Ether withdrawals. Always verify user permissions before allowing access to critical contract functions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#impact","title":"Impact","text":"<p>An attacker can exploit this vulnerability to withdraw Ether from the contract, leading to potential financial loss. This could result in a total loss of funds if no protective measures are in place, exposing the contract and its users to significant risks.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract EtherWallet {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint amount) public {\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");  // No access control\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract EtherWallet {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");  // Access control added\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/","title":"SCWE-050: Unprotected SELFDESTRUCT Instruction","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource https://cwe.mitre.org/data/definitions/732.html </li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#description","title":"Description","text":"<p>The <code>SELFDESTRUCT</code> instruction in Ethereum allows a contract to destroy itself and send its remaining Ether balance to a specified address. If this instruction is not properly protected with access controls, an attacker could trigger it, causing the contract to self-destruct and possibly transferring all the funds to an unauthorized address. This can result in the total loss of funds or disruption of contract functionality.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, it is crucial to protect the <code>SELFDESTRUCT</code> instruction with proper access control mechanisms. Only authorized users, such as the contract owner or admin, should be allowed to call the <code>SELFDESTRUCT</code> function. Consider using modifiers like <code>onlyOwner</code> or a role-based access control system to enforce permission checks before allowing this critical operation. Note: <code>selfdestruct</code> is deprecated per EIP-6049 (Solidity 0.8.24+); prefer migration patterns where possible.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Destructible {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Unprotected SELFDESTRUCT allowing anyone to call it\n    function destruct() public {\n        selfdestruct(payable(msg.sender));  // No access control\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Destructible {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Only the owner can call SELFDESTRUCT\n    function destruct() public onlyOwner {\n        selfdestruct(payable(msg.sender));  // Access control added\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/","title":"SCWE-105: Permit Signature Replay via Missing Domain Separator or Nonce","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature https://cwe.mitre.org/data/definitions/347.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/#description","title":"Description","text":"<p>Improper EIP-2612 permit implementations that omit chain-specific domain separators, do not increment nonces, or ignore expiration allow signatures to be replayed across chains or multiple times. Attackers can repeatedly approve spending or re-use permits on forked networks.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/#remediation","title":"Remediation","text":"<ul> <li>Build EIP-712 domain separators including <code>name</code>, <code>version</code>, <code>chainId</code>, and <code>verifyingContract</code>.</li> <li>Maintain per-owner nonces and increment on every successful permit.</li> <li>Enforce deadlines and reject expired signatures.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\ncontract Token {\n    mapping(address =&gt; uint256) public nonces;\n\n    function permit(address owner, address spender, uint256 value, bytes calldata sig) external {\n        // missing chainId/domain checks, nonce not incremented\n        address signer = ecrecover(/* simplified */);\n        require(signer == owner, \"bad sig\");\n        // allowance set here...\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-105/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\ncontract Token {\n    bytes32 public DOMAIN_SEPARATOR;\n    mapping(address =&gt; uint256) public nonces;\n\n    constructor() {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(\"Token\")),\n            keccak256(bytes(\"1\")),\n            block.chainid,\n            address(this)\n        ));\n    }\n\n    function permit(/* params */) external {\n        // verify typed data with nonce and deadline, then increment nonce\n        nonces[owner] += 1;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/","title":"SCWE-106: Unauthenticated Meta-Transactions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature https://cwe.mitre.org/data/definitions/347.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/#description","title":"Description","text":"<p>Meta-transaction forwarders that relay calls without verifying the signer, nonce, chain, or expiry let relayers execute arbitrary actions on behalf of victims. Missing replay protection allows the same signed request to be executed multiple times.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/#remediation","title":"Remediation","text":"<ul> <li>Verify EIP-712 typed data signatures against the declared signer.</li> <li>Track and increment per-signer nonces; enforce deadlines and chainId.</li> <li>Restrict trusted forwarders and sanitize <code>msg.sender</code>/<code>msg.data</code> assumptions in downstream calls.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Forwarder {\n    function relay(address target, bytes calldata data) external {\n        (bool ok, ) = target.call(data); // no signature or nonce check\n        require(ok, \"call failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-106/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Forwarder {\n    mapping(address =&gt; uint256) public nonces;\n\n    function relay(address target, bytes calldata data, uint256 nonce, uint256 deadline, bytes calldata sig) external {\n        require(block.timestamp &lt;= deadline, \"expired\");\n        bytes32 digest = keccak256(abi.encode(target, data, nonce, block.chainid, deadline));\n        address signer = ECDSA.recover(digest, sig);\n        require(nonce == nonces[signer]++, \"bad nonce\");\n        (bool ok, ) = target.call(data);\n        require(ok, \"call failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/","title":"SCWE-129: Single EOA Admin Without Rotation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/#relationships","title":"Relationships","text":"<ul> <li>CWE-284: Improper Access Control https://cwe.mitre.org/data/definitions/284.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/#description","title":"Description","text":"<p>Relying on a single externally owned account (EOA) as contract admin creates a single point of failure. Key compromise, loss, or coercion can lead to irreversible upgrades, pauses, or fund drains with no recovery.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/#remediation","title":"Remediation","text":"<ul> <li>Use multisig (&gt;=2-of-3) with hardware keys and timelocks for admin roles.</li> <li>Document and test key rotation and recovery procedures.</li> <li>Limit admin powers by role (upgrade vs. ops) and enforce separation of duties.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Gov {\n    address public admin; // single EOA \u2014 key loss or compromise = no recovery\n\n    modifier onlyAdmin() { require(msg.sender == admin, \"not admin\"); _; }\n    function upgrade(address impl) external onlyAdmin { /* ... */ }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-129/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Gov {\n    IMultisig public admin;     // 2-of-3 multisig with hardware keys\n    ITimelock public timelock;  // 48h delay for upgrades\n\n    function proposeUpgrade(address impl) external {\n        require(admin.isOwner(msg.sender), \"not owner\");\n        timelock.schedule(impl);\n    }\n    function executeUpgrade() external {\n        timelock.execute(); // only after delay; supports key rotation\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/","title":"SCWE-139: Single-Step Ownership Transfer Without Confirmation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/#relationships","title":"Relationships","text":"<ul> <li>CWE-670: Always-Incorrect Control Flow Implementation https://cwe.mitre.org/data/definitions/670.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/#description","title":"Description","text":"<p>A single-step <code>transferOwnership(newOwner)</code> immediately assigns ownership to the new address. If the wrong address is used (typo, burn address <code>address(0)</code>, or a contract that cannot receive ownership), the contract can be permanently locked\u2014no one can perform owner-only actions or correct the mistake. A two-step process (propose \u2192 accept) allows the intended recipient to confirm and prevents accidental loss of control.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/#remediation","title":"Remediation","text":"<ul> <li>Implement a two-step ownership transfer: <code>transferOwnershipPending(newOwner)</code> sets a pending owner, and <code>acceptOwnership()</code> (callable only by the pending owner) completes the transfer.</li> <li>Validate that <code>newOwner != address(0)</code> and consider rejecting contract addresses if the owner must be an EOA for operational reasons.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Ownable {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"Not owner\");\n        owner = newOwner;  // Single step: typo or address(0) permanently locks contract\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-139/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"Not owner\");\n        require(newOwner != address(0), \"Zero address\");\n        pendingOwner = newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == pendingOwner, \"Not pending owner\");\n        owner = pendingOwner;\n        delete pendingOwner;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/","title":"SCWE-147: Permit or Meta-Transaction Signatures Without Expiration","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature https://cwe.mitre.org/data/definitions/347.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/#description","title":"Description","text":"<p>Permit (EIP-2612) and meta-transaction signatures that omit a <code>deadline</code> or <code>expiry</code> parameter can be replayed indefinitely once obtained. An attacker who captures a valid signature (e.g., via phishing or a compromised frontend) can submit it at any future time. SCWE-105 covers domain separator and nonce; this weakness specifically addresses the absence of expiration.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/#remediation","title":"Remediation","text":"<ul> <li>Include a <code>deadline</code> (or <code>expiry</code>) in the signed message and enforce <code>require(block.timestamp &lt;= deadline, \"Expired\")</code> when processing the signature.</li> <li>Use EIP-712 structured data with a deadline field.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract MetaTx {\n    function execute(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s) external {\n        require(ecrecover(hash, v, r, s) == signer, \"Bad sig\");\n        // No deadline: signature valid forever\n        _execute(signer);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-147/#fixed","title":"Fixed","text":"<p><pre><code>function execute(address signer, uint256 deadline, bytes32 hash, uint8 v, bytes32 r, bytes32 s) external {\n    require(block.timestamp &lt;= deadline, \"Expired\");\n    require(ecrecover(hash, v, r, s) == signer, \"Bad sig\");\n    _execute(signer);\n}\n</code></pre> Note: The <code>hash</code> must be computed from EIP-712 structured data that includes the <code>deadline</code> field so the signature cannot be replayed after expiry.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/","title":"SCWE-155: Single Point of Failure in Administrative Key Management","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/#relationships","title":"Relationships","text":"<ul> <li>CWE-284: Improper Access Control https://cwe.mitre.org/data/definitions/284.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/#description","title":"Description","text":"<p>Contracts that rely on a single administrative key (EOA or contract) without multisig, timelock, or key rotation create a single point of failure. Compromise of that key (phishing, malware, physical theft) gives full control; loss of the key (e.g., no backup) can permanently lock critical functions. SCWE-129 covers single EOA admin; this weakness focuses on the risk of single-key design and the absence of mitigations.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/#remediation","title":"Remediation","text":"<ul> <li>Use multisig wallets (e.g., Gnosis Safe) for administrative actions.</li> <li>Implement timelocks for sensitive operations (SCWE-020).</li> <li>Plan for key rotation or recovery mechanisms.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Treasury {\n    address public owner;\n\n    function withdraw(uint256 amount) external {\n        require(msg.sender == owner, \"Not owner\");\n        (bool ok, ) = owner.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Risk: Single <code>owner</code> key; no multisig, no timelock. Compromise or loss permanently affects the treasury.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-155/#fixed","title":"Fixed","text":"<p><pre><code>contract Treasury {\n    address public owner;  // In production: use multisig (e.g., Gnosis Safe)\n    uint256 public constant TIMELOCK = 2 days;\n    uint256 public pendingAmount;\n    uint256 public unlockTime;\n\n    function proposeWithdraw(uint256 amount) external {\n        require(msg.sender == owner, \"Not owner\");\n        pendingAmount = amount;\n        unlockTime = block.timestamp + TIMELOCK;\n    }\n\n    function executeWithdraw() external {\n        require(msg.sender == owner, \"Not owner\");\n        require(block.timestamp &gt;= unlockTime, \"Timelock\");\n        uint256 amount = pendingAmount;\n        pendingAmount = 0;\n        (bool ok, ) = owner.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Fix: Timelock adds a delay so large withdrawals can be contested. Use a multisig for <code>owner</code> in production.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/","title":"SCWE-024: Weak Randomness Sources","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#relationships","title":"Relationships","text":"<ul> <li>CWE-336: Predictable Random Number Generator CWE-336 Link</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#description","title":"Description","text":"<p>Weak randomness sources refer to the use of predictable or insecure sources of randomness, such as block timestamps or block hashes. This can lead to: - Exploitation of the contract's logic. - Loss of funds or data. - Reduced trust in the contract's security.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#remediation","title":"Remediation","text":"<ul> <li>Use secure randomness: Leverage secure randomness sources like Chainlink VRF.</li> <li>Avoid block variables: Do not rely on block timestamps or hashes for randomness.</li> <li>Test thoroughly: Conduct extensive testing to ensure randomness is secure.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#examples","title":"Examples","text":"<ul> <li> <p>Weak Randomness <pre><code>pragma solidity ^0.8.0;\n\ncontract WeakRandomness {\n    function generateRandomNumber() public view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty))); // Insecure: post-merge use block.prevrandao; both are insecure for value-at-stake randomness\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Randomness     ```solidity     pragma solidity ^0.8.0;</p> </li> </ul> <p>import \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\"; // Note: Chainlink VRF V1 is deprecated; use VRF V2 (VRFConsumerBaseV2) in production</p> <p>contract SecureRandomness is VRFConsumerBase {         bytes32 internal keyHash;         uint256 internal fee;         uint256 public randomResult;</p> <pre><code>    constructor(address vrfCoordinator, address linkToken, bytes32 _keyHash, uint256 _fee)\n        VRFConsumerBase(vrfCoordinator, linkToken) {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n\n    function getRandomNumber() public returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) &gt;= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n    }\n}\n```\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/","title":"SCWE-031: Insecure use of Block Variables","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#description","title":"Description","text":"<p>In blockchain networks like Ethereum, block variables <code>(block.timestamp, block.number, block.difficulty</code> / <code>block.prevrandao</code> post-merge, etc.) provide information about the current state of the blockchain. However, these values are not fully deterministic and can be manipulated by validators (or miners on PoW chains), leading to vulnerabilities in smart contracts.</p> <p>Block timestamps are not guaranteed to be accurate or consistent, and validators (or miners on PoW chains) can influence them within a certain range. This can cause issues when contracts depend on precise timing for critical functionality, such as token distribution, access control, or other time-sensitive events.</p> <p>Potential issues that arise from insecure timestamp usage include:</p> <ul> <li>Timestamp Manipulation: Validators (or miners on PoW) can slightly alter <code>block.timestamp</code> to influence time-sensitive logic (e.g., auctions, token distributions, staking rewards).</li> <li>Predictable Randomness: Using <code>block.number</code> or <code>block.difficulty</code> as a source of randomness allows attackers to predict and manipulate outcomes.</li> <li>Exploitable Access Control: Contracts that rely on block timestamps for permissions or actions may be bypassed if timestamps are adjusted.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#remediation","title":"Remediation","text":"<ul> <li>Avoid timestamp-based conditions: Where possible, use block numbers instead of timestamps. Block numbers are more reliable and less subject to manipulation.</li> <li>Use Oracles: For time-sensitive contracts, consider using trusted oracles to provide external time data.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#insecure-block-timestamp-usage-timestamp-based-deadlines","title":"Insecure Block Timestamp Usage- Timestamp-Based Deadlines","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract TimestampExample {\n    uint public deadline;\n\n    function setDeadline(uint _deadline) public {\n        deadline = _deadline;\n    }\n\n    function checkDeadline() public view returns (string) {\n        if (block.timestamp &gt; deadline) {\n            return \"Deadline passed\";\n        } else {\n            return \"Deadline not passed\";\n        }\n    }\n}\n</code></pre> <p>In the above example, <code>block.timestamp</code> is used to compare with the deadline. This creates a potential vulnerability as validators (or miners on PoW) can manipulate the block timestamp within a predefined window (~15 seconds).</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#fixed-block-timestamp-usage","title":"Fixed Block Timestamp Usage","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract SafeTimestampExample {\n    uint public deadline;\n    uint public blockNumber;\n\n    function setDeadline(uint _deadline) public {\n        deadline = _deadline;\n        blockNumber = block.number;\n    }\n\n    function checkDeadline() public view returns (string) {\n        if (block.number &gt; blockNumber + 1000) { // Assuming a reasonable number of blocks for a deadline\n            return \"Deadline passed\";\n        } else {\n            return \"Deadline not passed\";\n        }\n    }\n}\n</code></pre> In this fixed version, the contract uses <code>block.number</code> instead of <code>block.timestamp</code>. This makes the contract less susceptible to timestamp manipulation, as block numbers are more reliable and consistent.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#insecure-lottery-using-blocktimestamp","title":"Insecure Lottery Using block.timestamp","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureLottery {\n    address[] public players;\n\n    function enter() public payable {\n        require(msg.value &gt; 0.01 ether, \"Minimum ETH required\");\n\n        players.push(msg.sender);\n    }\n\n    function pickWinner() public {\n        uint index = uint(block.timestamp) % players.length; // Insecure: Predictable outcome\n        (bool ok, ) = payable(players[index]).call{value: address(this).balance}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Issue: - Predictability: Since <code>block.timestamp</code> is manipulable within a small range, validators (or miners on PoW chains) can influence the winner selection. - Attack Vector: A validator (or miner on PoW) could reorder transactions to ensure a specific outcome</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#secure-alternative-commit-reveal","title":"Secure Alternative (Commit-Reveal)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureLottery {\n    mapping(address =&gt; bytes32) public commits;\n    mapping(address =&gt; bytes32) public revealed;\n    address[] public players;\n\n    function commit(bytes32 hash) external payable {\n        require(msg.value &gt; 0.01 ether, \"Minimum ETH required\");\n        require(commits[msg.sender] == bytes32(0), \"Already committed\");\n        commits[msg.sender] = hash;\n        players.push(msg.sender);\n    }\n\n    function reveal(bytes32 secret) external {\n        require(keccak256(abi.encodePacked(secret)) == commits[msg.sender], \"Invalid reveal\");\n        revealed[msg.sender] = secret;\n    }\n\n    function pickWinner() external {\n        bytes32 combined = bytes32(0);\n        for (uint i = 0; i &lt; players.length; i++) {\n            require(revealed[players[i]] != bytes32(0), \"All must reveal\");\n            combined = keccak256(abi.encodePacked(combined, revealed[players[i]]));\n        }\n        uint index = uint(combined) % players.length;\n        (bool ok, ) = payable(players[index]).call{value: address(this).balance}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Fixes: - Uses commit-reveal: each player commits a hash, then reveals; combined secrets determine the winner. - <code>block.prevrandao</code> and <code>block.timestamp</code> are not safe for value-at-stake randomness \u2014 use VRF (e.g., Chainlink) or commit-reveal.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/","title":"SCWE-065: Block Values as a Proxy for Time","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#description","title":"Description","text":"<p>Using block values (such as <code>block.timestamp</code>, <code>block.number</code>, or <code>block.difficulty</code> / <code>block.prevrandao</code> post-merge) as a proxy for time in Ethereum smart contracts can be problematic. Block values are determined by validators (or miners on PoW chains) and can be manipulated within certain limits, making them unreliable for time-sensitive logic. Relying on these values for critical decisions like deadlines or expiration dates can result in unexpected behaviors, such as manipulations by validators (or miners on PoW chains) or unintended contract states.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, account for the manipulation bounds of block values. <code>block.timestamp</code> can vary by ~15 seconds per block; design deadlines and time checks with this tolerance in mind. Time oracles are uncommon; the standard approach is to use <code>block.timestamp</code> with appropriate buffers. Where precision is critical, consider commit-reveal or multi-block confirmation.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract TimeSensitive {\n    uint public deadline;\n\n    constructor(uint _deadline) {\n        deadline = _deadline;\n    }\n\n    function hasExpired() public view returns (bool) {\n        return block.timestamp &gt; deadline;  // Relies on block.timestamp\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TimeSensitive {\n    uint public constant DEADLINE_BUFFER = 15; // seconds \u2014 accounts for block.timestamp manipulation\n    uint public deadline;\n\n    constructor(uint _deadline) {\n        // Set deadline with buffer so expiry is robust to ~15s timestamp variance\n        deadline = _deadline + DEADLINE_BUFFER;\n    }\n\n    function hasExpired() public view returns (bool) {\n        return block.timestamp &gt; deadline;\n    }\n}\n</code></pre> Mitigation: Add a buffer when setting deadlines to account for the ~15 second manipulation window of <code>block.timestamp</code>. Avoid relying on sub-minute precision.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/","title":"SCWE-073: Message Call with Hardcoded Gas Amount","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#description","title":"Description","text":"<p>In Solidity, calling external contracts with a hardcoded gas value can lead to various issues, such as running out of gas or allowing a malicious contract to manipulate gas consumption. Hardcoding the gas amount is inflexible and may lead to resource exhaustion or cause the transaction to fail when the gas limit is insufficient for the operation.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#remediation","title":"Remediation","text":"<p>Instead of hardcoding gas values, it is better to allow the gas to be automatically determined or adjust the gas dynamically depending on the needs of the transaction. This ensures that the transaction can complete successfully while avoiding unnecessary resource consumption.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    address public target;\n\n    function callTarget() public {\n        // Hardcoding the gas value for the message call\n        target.call{gas: 100000}(\"\");  // Vulnerable to resource consumption issues\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    address public target;\n\n    function callTarget() public {\n        // Let Solidity handle gas consumption dynamically\n        target.call(\"\");  // Gas amount handled by the EVM dynamically\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/","title":"SCWE-127: EIP-1559 Basefee Assumptions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/#relationships","title":"Relationships","text":"<ul> <li>CWE-841: Improper Enforcement of Behavioral Workflow https://cwe.mitre.org/data/definitions/841.html</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/#description","title":"Description","text":"<p>Hardcoding gas price/basefee assumptions (e.g., fixed <code>gasprice</code> limits or expecting refunds) can break on EIP-1559 chains. Contracts that require exact <code>block.basefee</code> ranges or reimburse fixed gas can become stuck or exploitable via gas griefing.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/#remediation","title":"Remediation","text":"<ul> <li>Avoid relying on specific basefee values; parameterize and allow updates via governance with delays.</li> <li>Use robust gas estimation and caps on external calls; avoid refund-dependent logic.</li> <li>Simulate on mainnet forks with varying basefee to validate liveness.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/#vulnerable","title":"Vulnerable","text":"<pre><code>require(tx.gasprice &lt;= 30 gwei, \"gas too high\"); // fails as basefee rises\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-127/#fixed","title":"Fixed","text":"<pre><code>uint256 maxGasPrice = governanceMaxGasPrice;\nrequire(tx.gasprice &lt;= maxGasPrice, \"gas too high\"); // upgradable with delays\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/","title":"SCWE-153: Reliance on block.prevrandao for High-Value Randomness","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/#relationships","title":"Relationships","text":"<ul> <li>CWE-330: Use of Insufficiently Random Values https://cwe.mitre.org/data/definitions/330.html</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/#description","title":"Description","text":"<p>Post-merge (Ethereum PoS), <code>block.difficulty</code> was replaced by <code>block.prevrandao</code>. Both are manipulable by validators: they can influence the value within protocol rules. Using <code>block.prevrandao</code> (or <code>block.difficulty</code>) for high-value randomness\u2014lotteries, airdrops, winner selection\u2014allows validators or sophisticated actors to predict or bias outcomes. SCWE-024 and SCWE-084 cover blockhash/timestamp; this weakness specifically addresses <code>block.prevrandao</code>.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/#remediation","title":"Remediation","text":"<ul> <li>Do not use <code>block.prevrandao</code> or <code>block.difficulty</code> for value-at-stake randomness.</li> <li>Use Chainlink VRF, commit-reveal schemes, or other verifiable randomness sources.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Lottery {\n    address[] public participants;\n\n    function pickWinner() external view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.prevrandao, block.timestamp))) % participants.length;\n    }\n}\n</code></pre> Why vulnerable: <code>block.prevrandao</code> is manipulable by validators; they can influence the value to bias the outcome.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-153/#fixed","title":"Fixed","text":"<p>Use Chainlink VRF V2 or a commit-reveal scheme where participants commit hashes before the random value is known. See SCWE-024 for a Chainlink VRF example.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/","title":"SCWE-032: Dependency on Block Gas Limit","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption CWE-400 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#description","title":"Description","text":"<p>Dependency on block gas limit refers to the reliance on the Ethereum block gas limit for contract operations, which can lead to: - Failed transactions if gas limits are exceeded. - Exploitation of vulnerabilities in gas-intensive operations. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#remediation","title":"Remediation","text":"<ul> <li>Optimize gas usage: Minimize gas consumption in contract operations.</li> <li>Avoid unbounded loops: Ensure loops have a fixed upper limit.</li> <li>Test thoroughly: Conduct extensive testing to ensure operations stay within gas limits.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#examples","title":"Examples","text":"<ul> <li>Gas-Intensive Operation- Storing Large Dynamic Data <pre><code>pragma solidity ^0.8.0;\n\ncontract GasIntensive {\n    uint[] public largeArray;\n\n    function appendData(uint[] memory data) public {\n        for (uint i = 0; i &lt; data.length; i++) {\n            largeArray.push(data[i]); // Storing a large dataset in a single transaction\n        }\n    }\n}\n</code></pre></li> <li>This contract appends large arrays in a single transaction, which fails when the block gas limit is exceeded.</li> <li> <p>Attackers could exploit this by forcing high gas consumption and causing DoS attacks (e.g., filling storage inefficiently).</p> </li> <li> <p>Optimized Gas Usage- Chunk Processing &amp; Gas Efficiency <pre><code>pragma solidity ^0.8.0;\n\ncontract GasOptimized {\n    uint[] public largeArray;\n\n    function appendData(uint[] memory data, uint start, uint end) public {\n        require(end &lt;= data.length, \"Invalid range\");\n        for (uint i = start; i &lt; end; i++) {\n            largeArray.push(data[i]); // Process in controlled batches\n        }\n    }\n}\n</code></pre></p> </li> </ul> <p>Why is this better? - The start and end parameters allow batch processing instead of handling everything in a single call. - Prevents hitting the block gas limit by splitting work across multiple transactions.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/","title":"SCWE-033: Chain Split Risks","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#description","title":"Description","text":"<p>Chain split risks refer to vulnerabilities that arise when a blockchain splits into multiple chains, such as during a hard fork. This can lead to: - Confusion or inconsistencies in contract logic. - Loss of funds or data. - Exploitation of vulnerabilities in cross-chain operations.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#remediation","title":"Remediation","text":"<ul> <li>Handle chain splits: Implement logic to handle potential chain splits.</li> <li>Use chain identifiers: Include chain identifiers in cross-chain communications.</li> <li>Test thoroughly: Conduct extensive testing to ensure contract logic is robust.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable to Chain Splits <pre><code>pragma solidity ^0.8.0;\n\ncontract ChainSplitVulnerable {\n    function processTransaction(bytes memory data) public {\n        // Process transaction without chain split handling\n    }\n}\n</code></pre></p> </li> <li> <p>Protected Against Chain Splits <pre><code>pragma solidity ^0.8.0;\n\ncontract ChainSplitProtected {\n    uint public chainId;\n\n    constructor(uint _chainId) {\n        chainId = _chainId;\n    }\n\n    function processTransaction(bytes memory data, uint transactionChainId) public {\n        require(transactionChainId == chainId, \"Invalid chain ID\");\n        // Process transaction\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/","title":"SCWE-034: Insecure Cross-Chain Messaging","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#description","title":"Description","text":"<p>Insecure cross-chain messaging refers to vulnerabilities that arise when communicating between different blockchains. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of vulnerabilities in cross-chain logic.</p> <ul> <li>Economic inconsistencies due to unvalidated msg.value in message handlers.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#remediation","title":"Remediation","text":"<ul> <li>Validate messages: Ensure all cross-chain messages are properly validated.</li> <li>Use secure protocols: Leverage secure cross-chain communication protocols.</li> <li> <p>Test thoroughly: Conduct extensive testing to ensure cross-chain logic is secure.</p> </li> <li> <p>Validate msg.value: Decode expected value from the message payload or protocol parameters and require that <code>msg.value</code> matches (or meets) this expectation; revert on mismatch.</p> </li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#examples","title":"Examples","text":"<ul> <li>Insecure Cross-Chain Messaging <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureCrossChain {\n    event MessageProcessed(bytes message);\n\n    function processMessage(bytes memory message) public {\n        // \u274c No validation of the sender (anyone can call this function!)\n        // \u274c No signature verification (attackers can inject fake messages!)\n        // \ud83d\udea8 No relayer authorization\n        // \ud83d\udea8 No replay protection\n        emit MessageProcessed(message);\n    }\n}\n</code></pre> \ud83d\udd34 Issue: The function accepts messages without validation, allowing unauthorized transactions.</li> </ul> <p>Unauthorized Relayers (Anyone Can Call!) - Issue: The function allows any msg.sender to call processMessage(), meaning an attacker can send arbitrary messages. - Impact: Attackers can forge transactions, trigger unintended actions, or drain funds if the function is connected to cross-chain asset transfers.</p> <p>No Signature Verification (Fake Messages) - Issue: The contract doesn\u2019t verify the authenticity of the message. - Impact: Attackers can inject fake messages and trick the contract into executing unauthorized actions.</p> <p>Replay Attacks - Issue: The contract doesn\u2019t track processed messages. - Impact: The same message can be replayed multiple times, leading to repeated execution of sensitive operations.</p> <ul> <li>Secure Cross-Chain Messaging <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureCrossChain {\n    mapping(address =&gt; bool) public trustedRelayers;\n    mapping(bytes32 =&gt; bool) public processedMessages;\n\n    event MessageProcessed(bytes32 indexed messageHash, address indexed sender);\n    event RelayerUpdated(address relayer, bool status);\n\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor(address[] memory initialRelayers) {\n        owner = msg.sender;\n        for (uint i = 0; i &lt; initialRelayers.length; i++) {\n            trustedRelayers[initialRelayers[i]] = true;\n        }\n    }\n\n    function setRelayer(address relayer, bool status) external onlyOwner {\n        trustedRelayers[relayer] = status;\n        emit RelayerUpdated(relayer, status);\n    }\n\n    function processMessage(\n        bytes memory message, \n        uint8 v, bytes32 r, bytes32 s\n    ) public {\n        require(trustedRelayers[msg.sender], \"Unauthorized relayer\");\n\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\n        address signer = ecrecover(messageHash, v, r, s);\n        require(signer != address(0), \"Invalid signature\");\n\n        require(!processedMessages[messageHash], \"Message already processed\");\n        processedMessages[messageHash] = true;\n\n        emit MessageProcessed(messageHash, signer);\n\n        // \u2705 Securely process the message\n    }\n}\n</code></pre></li> </ul> <p>Fix: Implements signature verification, relayer validation, and replay protection. Why is this better? \u2705 Verifies Signatures Properly: Uses ecrecover() with Ethereum Signed Message hashing. \u2705 Admin Can Manage Relayers: Allows dynamic relayer updates via setRelayer(). \u2705 Prevents Replay Attacks: Tracks processed messages in processedMessages mapping. \u2705 Ensures Message Authenticity: Only validly signed messages are accepted.</p> <ul> <li> <p>Unvalidated msg.value in Cross-Chain Message Handling <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VulnerableBridgedGovernor {\n    address public endpoint;\n    uint256 public _lastNonce;\n    uint32 public ownerEid;\n    address public owner;\n\n    struct Origin {\n        uint32 srcEid;\n        address sender;\n        uint256 nonce;\n    }\n\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    modifier onlyProxy() {\n        _;\n    }\n\n    function runCalls(Call[] memory calls) internal {\n        for (uint i = 0; i &lt; calls.length; i++) {\n            (bool success, ) = calls[i].to.call{value: calls[i].value}(calls[i].data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    function lzReceive(\n        Origin calldata origin,\n        bytes32, /* guid */\n        bytes calldata message,\n        address, /* executor */\n        bytes calldata /* extraData */\n    ) public payable onlyProxy {\n        require(msg.sender == endpoint, \"Must be called by the endpoint\");\n        require(origin.srcEid == ownerEid, \"Invalid message source chain\");\n        require(origin.sender == owner, \"Invalid message sender\");\n        require(origin.nonce == _lastNonce + 1, \"Invalid message nonce\");\n        _lastNonce = origin.nonce;\n        runCalls(abi.decode(message, (Call[])));\n        // &lt;-- No check on msg.value!\n    }\n}\n</code></pre>     \ud83d\udd34 Issue: The handler accepts arbitrary <code>msg.value</code>, enabling front-running or unintended value-carrying calls that desync protocol accounting.</p> </li> <li> <p>Validated msg.value in Cross-Chain Message Handling <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SafeBridgedGovernor {\n    address public endpoint;\n    uint256 public _lastNonce;\n    uint32 public ownerEid;\n    address public owner;\n\n    struct Origin {\n        uint32 srcEid;\n        address sender;\n        uint256 nonce;\n    }\n\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    modifier onlyProxy() {\n        _;\n    }\n\n    function runCalls(Call[] memory calls) internal {\n        for (uint i = 0; i &lt; calls.length; i++) {\n            (bool success, ) = calls[i].to.call{value: calls[i].value}(calls[i].data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    function lzReceive(\n        Origin calldata origin,\n        bytes32, /* guid */\n        bytes calldata message,\n        address, /* executor */\n        bytes calldata /* extraData */\n    ) public payable onlyProxy {\n        require(msg.sender == endpoint, \"Must be called by the endpoint\");\n        require(origin.srcEid == ownerEid, \"Invalid message source chain\");\n        require(origin.sender == owner, \"Invalid message sender\");\n        require(origin.nonce == _lastNonce + 1, \"Invalid message nonce\");\n        _lastNonce = origin.nonce;\n\n        (uint256 expectedMsgValue, Call[] memory calls) = abi.decode(message, (uint256, Call[]));\n        require(msg.value &gt;= expectedMsgValue, \"Invalid message value\");\n        runCalls(calls);\n    }\n}\n</code></pre>     \u2705 Fix: Decode expected value from the payload and enforce that <code>msg.value</code> meets it before executing downstream calls.</p> </li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/","title":"SCWE-087: Missing Payload Size Validation in Cross-Chain Messaging (Denial of Service/Stuck Funds)","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#relationships","title":"Relationships","text":"<ul> <li>CWE-1284: Improper Validation of Specified Quantity in Input CWE-1284 Link</li> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#description","title":"Description","text":"<p>This weakness arises when smart contracts performing cross-chain messaging fail to validate the size of payloads before emitting or sending them. In protocols using relayer-based messaging (e.g., LayerZero, Wormhole), data is typically encoded and emitted as a payload on the source chain, then relayed and decoded on the destination chain. If the encoded payload exceeds the maximum allowed size (often 10,000 bytes or similar, depending on the bridge/messaging protocol), the message transmission or decoding can revert\u2014often because the large payload causes out-of-gas consumption during processing or fails explicit size checks. In lock-mint architectures, this can lead to permanent loss of user funds due to inability to unlock or mint assets on the destination chain.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#impact","title":"Impact","text":"<ul> <li>Denial of Service: Oversized payloads will revert during cross-chain transmission, preventing legitimate state updates or token minting/unlocking on the destination chain.</li> <li>Stuck or Lost Funds: In bridges using lock-and-mint or burn-and-mint designs, users\u2019 assets may be locked on the source chain with no way to release or claim them on the destination due to repeated transaction failure.</li> <li>Operational Risk: Malicious or unintentional submission of oversized payloads can be used to disrupt bridge operations, preventing protocol liveness or causing critical business logic to be inaccessible.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#remediation","title":"Remediation","text":"<ul> <li>Enforce maximum payload size validation on both source and destination chains.</li> <li>Perform defensive coding around payload encoding and decoding to catch out-of-gas or out-of-bound errors.</li> <li>Consider fallback or reversion handling strategies to safely refund or unlock funds when such failures occur.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#examples","title":"Examples","text":"<p>\ud83e\uddea  Example: User-Supplied Merkle Proof in <code>lockTokens()</code></p> <p>\u274c Vulnerable Code (No Payload Size Validation) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// SourceChain.sol\nevent Locked(address indexed user, uint256 amount, bytes payload);\nfunction lockTokens(uint256 amount, bytes calldata merkleProof) external {\n    require(amount &gt; 0, \"Invalid amount\");\n    // Lock tokens (ERC20 transferFrom)\n    require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n    // Encode user, amount, timestamp, and the supplied Merkle proof\n    bytes memory payload = abi.encode(msg.sender, amount, block.timestamp, merkleProof);\n    // \u26a0\ufe0f No payload size validation!\n    emit Locked(msg.sender, amount, payload);\n}\n</code></pre> Destination Chain: Decode and Mint <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// DestinationChain.sol\nfunction mintFromPayload(bytes calldata payload) external {\n    // Will revert if payload is too large for decode!\n    (address user, uint256 amount, uint256 timestamp, bytes memory merkleProof) =\n        abi.decode(payload, (address, uint256, uint256, bytes));\n    // Verification of Merkle proof, then mint tokens\n    _mint(user, amount);\n}\n</code></pre> \u2705  Safe Code (With Payload Size Validation) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// SourceChain.sol\nevent Locked(address indexed user, uint256 amount, bytes payload);\nfunction lockTokens(uint256 amount, bytes calldata merkleProof) external {\n    require(amount &gt; 0, \"Invalid amount\");\n    // Lock tokens (ERC20 transferFrom)\n    require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n    // Encode user, amount, timestamp, and the supplied Merkle proof\n    bytes memory payload = abi.encode(msg.sender, amount, block.timestamp, merkleProof);\n    // Check payload size\n    require(payload.length &lt;= 10_000, \"Payload exceeds max allowed size\");\n    emit Locked(msg.sender, amount, payload);\n}\n</code></pre> Destination Chain: Decode and Mint (Optional Double Check) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// DestinationChain.sol\nfunction mintFromPayload(bytes calldata payload) external {\n    require(payload.length &lt;= 10_000, \"Payload too large\");\n    (address user, uint256 amount, uint256 timestamp, bytes memory merkleProof) =\n        abi.decode(payload, (address, uint256, uint256, bytes));\n    // Proceed with Merkle proof verification and minting\n    _mint(user, amount);\n}\n</code></pre></p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-094/","title":"SCWE-094: Insufficient Gas Limit Validation in LayerZero Message Sending","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-094/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-094/#description","title":"Description","text":"<p>This weakness arises when a smart contract using LayerZero for cross-chain communication fails to validate the minimum gas limit in the adapter parameters. Attackers (or misconfigured clients) can specify an adapter params gas value that is too low for the destination chain execution. As a result, message processing reverts before reaching business logic or error-handling, and the message is recorded as a failed payload on the destination chain. Accumulating failed payloads can disrupt protocol liveness by blocking the cross-chain communication pathway until manual intervention is performed.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-094/#impact","title":"Impact","text":"<ul> <li>Denial of Service: Destination chain message execution reverts due to insufficient gas, preventing critical state changes or callbacks.</li> <li>Message Backlog/Failed Payloads: Messages accumulate in failed payload storage/queues, increasing operational burden.</li> <li>Operational Risk: Requires manual retries, clearing, or rescue flows to restore liveness; prolonged outages can impact user operations (e.g., bridging, synchronization, DeFi actions).</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-094/#remediation","title":"Remediation","text":"<ul> <li>Validate minimum gas limit: Decode LayerZero adapter parameters and enforce a protocol-defined minimum gas limit per message type.</li> <li>Use safe defaults: Provide default adapter params with adequate gas and reject user-supplied values below the threshold.</li> <li>Granular minima: If different message types have varying complexity, define per-endpoint or per-function minimum gas values.</li> <li>Robust failure handling: Implement operational procedures and tooling to safely retry or clear failed payloads without compromising security.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-094/#examples","title":"Examples","text":"<p>\ud83e\uddea  Example</p> <p>\u274c Vulnerable Code (Lack of gas limit validation allows pathway blocking) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol\";\n\ncontract VulnerableLzApp is NonblockingLzApp {\n    constructor(address _endpoint) NonblockingLzApp(_endpoint) {}\n\n    function sendMessage(uint16 _dstChainId, bytes calldata _payload, bytes calldata _adapterParams) external payable {\n        // No validation on _adapterParams, attacker can specify low gas\n        _lzSend(_dstChainId, _payload, payable(msg.sender), address(0), _adapterParams, msg.value);\n    }\n}\n</code></pre></p> <p>\u2705 Safe Code (Enforces minimum gas limit to prevent blocking) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol\";\n\ncontract FixedLzApp is NonblockingLzApp {\n    uint256 public constant MIN_GAS_LIMIT = 200000;\n\n    constructor(address _endpoint) NonblockingLzApp(_endpoint) {}\n\n    function sendMessage(uint16 _dstChainId, bytes calldata _payload, bytes calldata _adapterParams) external payable {\n        require(_extractGasLimit(_adapterParams) &gt;= MIN_GAS_LIMIT, \"low gas\");\n        _lzSend(_dstChainId, _payload, payable(msg.sender), address(0), _adapterParams, msg.value);\n    }\n\n    function _extractGasLimit(bytes calldata _adapterParams) internal pure returns (uint256 gasLimit) {\n        require(_adapterParams.length &gt;= 34, \"bad params\");\n        assembly { gasLimit := calldataload(add(_adapterParams.offset, 2)) }\n    }\n}\n</code></pre></p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-096/","title":"SCWE-096: Missing Token Burn During Cross-Chain NFT Withdrawal","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-096/#relationships","title":"Relationships","text":"<ul> <li>CWE-345:  Insufficient Verification of Data Authenticity CWE-345 Link</li> <li>CWE-664: Improper Control of a Resource Through Its Lifetime     CWE-664 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-096/#description","title":"Description","text":"<p>This weakness occurs when a cross-chain bridge allows withdrawals from Chain B to Chain A without properly burning or locking the corresponding token on the source chain (Chain B) before initiating the cross-chain transaction.</p> <p>As a result, the same token can exist simultaneously on both chains, enabling a double-spend scenario where malicious actors can sell, transfer, or use the same token on multiple chains.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-096/#remediation","title":"Remediation","text":"<ol> <li> <p>Burn the NFT  </p> <ul> <li>Call the <code>burn(tokenId)</code> function on the L2 NFT contract before sending the cross-chain withdrawal request.  </li> <li>This ensures that the NFT no longer exists on L2 and cannot be reused, transferred, or sold.  </li> </ul> </li> <li> <p>Alternatively, Lock the NFT (if burning isn\u2019t possible)  </p> <ul> <li>If NFTs are not meant to be permanently destroyed, implement a lock mechanism to freeze the token on L2 until the cross-chain withdrawal is completed successfully.  </li> </ul> </li> <li> <p>Update Cross-Chain Workflow  </p> <ul> <li>Enforce the burn/lock operation as part of the withdrawal process.  </li> <li>Revert the entire transaction if the burn/lock fails.  </li> </ul> </li> </ol>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-096/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Code (Not Burning Token Before Sending Cross Chain Message) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract SourceChainNFTGateway {\n    mapping(address =&gt; mapping(uint256 =&gt; address)) public ownerOf;\n\n    function withdrawNFT(address l2Token, uint256 tokenId) external {\n        require(ownerOf[l2Token][tokenId] == msg.sender, \"Not the owner\");\n\n        // \u274c Send cross-chain message to Destination Chain (omitted for simplicity)\n        // NFT is still available on Source Chain \u2192 double-spend possible\n    }\n}\n</code></pre></p> </li> <li> <p>Safe Code (Burning Token Before Sending Cross Chain Message) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IL2NFT {\n    function burn(uint256 tokenId) external;\n}\n\ncontract SourceChainNFTGateway {\n    mapping(address =&gt; mapping(uint256 =&gt; address)) public ownerOf;\n\n    function withdrawNFT(address l2Token, uint256 tokenId) external {\n        require(ownerOf[l2Token][tokenId] == msg.sender, \"Not the owner\");\n\n        // \u2705 Burn the NFT on Source Chain to prevent double-spend\n        IL2NFT(l2Token).burn(tokenId);\n\n        // Send cross-chain message to Destination Chain (omitted for simplicity)\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/","title":"SCWE-132: Mismatched Token Decimals in Bridge Mint/Burn","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/#description","title":"Description","text":"<p>Bridging tokens with differing decimals without normalization can over- or under-mint wrapped assets. Attackers can exploit decimal confusion to siphon value or lock funds when withdrawing back to the origin chain.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/#remediation","title":"Remediation","text":"<ul> <li>Normalize amounts to a canonical precision before mint/burn.</li> <li>Store per-token decimal config and validate consistency during bridge operations.</li> <li>Add tests for round-trip conversions across chains with varying decimals.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/#vulnerable","title":"Vulnerable","text":"<pre><code>// assumes 18 decimals on both sides; origin token has 6\n_mint(user, amount);\n</code></pre>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-132/#fixed","title":"Fixed","text":"<pre><code>uint8 srcDec = 6;\nuint8 dstDec = 18;\nuint256 normalized = amount * 10**(dstDec - srcDec);\n_mint(user, normalized);\n</code></pre>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/","title":"SCWE-133: Missing Replay Nonce per Bridge Lane","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/#relationships","title":"Relationships","text":"<ul> <li>CWE-294: Authentication Bypass by Capture-replay https://cwe.mitre.org/data/definitions/294.html</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/#description","title":"Description","text":"<p>Bridge receivers that do not track nonces per source chain/sender allow the same message to be replayed, causing duplicate mints or withdrawals. Forked chains can also replay historical messages if lanes are not isolated.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/#remediation","title":"Remediation","text":"<ul> <li>Maintain monotonically increasing nonces per (sourceChain, sourceSender).</li> <li>Reject messages with reused or out-of-order nonces.</li> <li>Bind nonces into signed payloads or proofs to prevent tampering.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/#vulnerable","title":"Vulnerable","text":"<pre><code>function receive(bytes calldata payload) external {\n    _execute(payload); // no nonce tracking\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-133/#fixed","title":"Fixed","text":"<pre><code>mapping(uint256 =&gt; mapping(address =&gt; uint256)) public nonce;\n\nfunction receive(uint256 srcChain, address src, uint256 n, bytes calldata payload) external {\n    require(n == nonce[srcChain][src]++, \"replay\");\n    _execute(payload);\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/","title":"SCWE-007: Presence of Unused Variables","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#relationships","title":"Relationships","text":"<ul> <li>CWE-563: Assignment to Variable with No Effect   https://cwe.mitre.org/data/definitions/563.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#description","title":"Description","text":"<p>The presence of unused variables in smart contracts refers to variables that are declared but never utilized in the contract logic. These variables consume storage or memory space unnecessarily, potentially wasting gas when deployed or executed. This situation often arises due to incomplete code, forgotten variables, or code that was intended for future use but never implemented. The presence of such variables increases the attack surface by making it harder to understand the contract and opens up potential vulnerabilities.</p> <p>Some common risks include: - Wasted gas due to storage and memory consumption. - Increased complexity and difficulty in understanding contract behavior. - Potential confusion for auditors or future developers working on the contract.</p> <p>Unused variables can also hide logic errors or indicate that parts of the contract are not functioning as intended.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#remediation","title":"Remediation","text":"<ul> <li>Remove Unused Variables: Ensure that any variables that are not required for the contract\u2019s functionality are removed.</li> <li>Code Review and Refactoring: Regularly review and refactor the code to eliminate dead or unnecessary variables.</li> <li>Automated Static Analysis Tools: Use static analysis tools to detect unused variables and other unnecessary code patterns.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#contract-with-unused-variables","title":"Contract with Unused Variables","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract UnusedVariables {\n    uint public balance;\n    uint public unusedVariable; // This variable is not used anywhere\n\n    function deposit(uint amount) public payable {\n        require(msg.value == amount, \"ETH amount mismatch\");\n        balance += amount;\n    }\n\n    function withdraw(uint amount) public {\n        balance -= amount;\n    }\n}\n</code></pre> <p>In the example above, the <code>unusedVariable</code> is declared but never used within the contract. This is a waste of storage space and can confuse anyone reading or auditing the code.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#fixed-code-with-unused-variables-removed","title":"Fixed Code with Unused Variables Removed","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract FixedUnusedVariables {\n    uint public balance;\n\n    function deposit(uint amount) public payable {\n        require(msg.value == amount, \"ETH amount mismatch\");\n        balance += amount;\n    }\n\n    function withdraw(uint amount) public {\n        require(balance &gt;= amount, \"Insufficient balance\");\n        balance -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre> The improved contract removes the unnecessary <code>unusedVariable</code>, reducing the complexity and improving gas efficiency.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/","title":"SCWE-008: Hardcoded Constants","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#relationships","title":"Relationships","text":"<ul> <li>CWE-547: Use of Hard-coded, Security-relevant Constants   https://cwe.mitre.org/data/definitions/547.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#description","title":"Description","text":"<p>Hardcoded constants refer to values that are embedded directly into the code and cannot be easily changed without modifying the code itself. These constants may include critical parameters, addresses, or settings that could be subject to change based on external factors or evolving needs. Hardcoding these values in the code introduces several issues:</p> <ul> <li>Lack of flexibility: Once the contract is deployed, these hardcoded values cannot be changed without deploying a new version, leading to inefficiency and reduced adaptability.</li> <li>Security risks: Hardcoded values may expose sensitive information or create vulnerabilities if they are not properly protected.</li> <li>Upgrade challenges: Contracts with hardcoded constants cannot easily evolve to support new functionality or parameters without requiring costly redeployment.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#remediation","title":"Remediation","text":"<ul> <li>Use variables instead of constants: Instead of hardcoding values, define them as variables that can be updated through administrative actions.</li> <li>Implement upgradeable contract patterns: Use proxy contracts or other patterns that support upgrades to allow flexibility in modifying constants.</li> <li>External configuration: Use off-chain storage for configuration values that can be updated without needing to deploy new contract versions.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#contract-with-hardcoded-constants","title":"Contract with Hardcoded Constants","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract HardcodedConstants {\n    address public owner = 0x1234567890abcdef1234567890abcdef12345678; // Hardcoded address\n    uint public maxSupply = 1000000; // Hardcoded supply limit\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n\n    function setMaxSupply(uint newMaxSupply) public {\n        maxSupply = newMaxSupply;\n    }\n}\n</code></pre> In this example, the <code>owner</code> address and <code>maxSupply</code> are hardcoded values that cannot be changed without redeploying the contract. This reduces flexibility and creates potential security risks.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#improved-contract-with-external-configuration","title":"Improved Contract with External Configuration","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract ConfigurableContract {\n    address public owner;\n    uint public maxSupply;\n\n    constructor(address initialOwner, uint initialMaxSupply) {\n        owner = initialOwner;\n        maxSupply = initialMaxSupply;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n\n    function setMaxSupply(uint newMaxSupply) public {\n        maxSupply = newMaxSupply;\n    }\n}\n</code></pre> <p>In this improved example, the <code>owner</code> address and <code>maxSupply</code> are configurable through the constructor, allowing for more flexibility without the need for redeployment.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/","title":"SCWE-009: Deprecated Variable and Function Usage","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#relationships","title":"Relationships","text":"<ul> <li>CWE-477: Use of Obsolete Function   https://cwe.mitre.org/data/definitions/477.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#description","title":"Description","text":"<p>The use of deprecated variables and functions refers to employing code elements that are no longer recommended for use, either due to obsolescence, security concerns, or the introduction of better alternatives. Using such elements can cause issues, including reduced compatibility, poor maintainability, and security vulnerabilities. Specific concerns related to deprecated usage are:</p> <ul> <li>Security risks: Deprecated functions may have known vulnerabilities or might not be patched.</li> <li>Compatibility issues: Newer compiler versions and environments may not support deprecated code.</li> <li>Maintenance difficulties: Continuing to use deprecated code increases the complexity of codebase management and prevents clean upgrades.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#remediation","title":"Remediation","text":"<ul> <li>Replace deprecated functions: Always use the recommended and supported alternatives in the latest compiler versions.</li> <li>Update dependencies: If relying on libraries that use deprecated elements, upgrade to versions that support current standards.</li> <li>Monitor for deprecation warnings: Stay informed about deprecated functions in the Solidity language or external libraries and refactor the code when necessary.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#contract-with-deprecated-function-usage","title":"Contract with Deprecated Function Usage","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract DeprecatedUsage {\n    address public owner;\n    uint public balance;\n\n    // Deprecated function, example using older Solidity versions\n    function sendTransaction(address recipient, uint amount) public {\n        recipient.transfer(amount);\n    }\n}\n</code></pre> <p>In this example, the <code>transfer</code> function in Solidity's older versions is deprecated. Continuing to use such functions can cause issues with future compiler versions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#improved-contract-without-deprecated-usage","title":"Improved Contract without Deprecated Usage","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract UpdatedUsage {\n    address public owner;\n    uint public balance;\n\n    // Replaced with call{value} \u2014 avoids 2300 gas limit of transfer/send\n    function sendTransaction(address recipient, uint amount) public {\n        (bool success, ) = payable(recipient).call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre> In this improved example, the contract uses <code>call{value}</code> instead of deprecated <code>transfer</code>/<code>send</code>, avoiding the 2300 gas limit that can cause DoS when the recipient is a contract (see SCWE-079).</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/","title":"SCWE-010: Shadowing Variables and Functions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#relationships","title":"Relationships","text":"<ul> <li>CWE-1109: Use of Same Variable for Multiple Purposes CWE-1109   Description: This weakness occurs when a variable is used for multiple purposes in a way that causes confusion, bugs, or unintentional side effects. In the context of smart contracts, shadowing variables leads to such misuse, as it causes ambiguity between different scopes.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#description","title":"Description","text":"<p>Shadowing variables or functions is a scenario where a local variable or function shares the same name as one in a larger or outer scope. This can cause ambiguity and lead to unexpected behavior or bugs, as the inner variable or function hides the outer one. This problem is especially tricky in Solidity due to its inheritance model, where a child contract might unintentionally override parent contract variables or functions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#key-issues","title":"Key issues:","text":"<ul> <li>Ambiguity: The developer might not be aware that a variable or function is being hidden.</li> <li>Unintentional logic errors: It may lead to the wrong variable being accessed, or the wrong function being called.</li> <li>Difficulty in debugging: Shadowing makes the code harder to understand and trace, especially in complex contracts or when inheritance is involved.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#remediation","title":"Remediation","text":"<ul> <li>Use unique and descriptive names: Always use unique names for variables and functions to avoid shadowing. Use clear, descriptive names for contract variables and functions.</li> <li>Avoid redeclaring variables in nested scopes: Ensure that variables or functions in inner scopes don\u2019t conflict with those in outer scopes.</li> <li>Static analysis tools: Use static analysis tools to detect and warn about shadowing issues.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#example-of-shadowing-variables-and-functions","title":"Example of Shadowing Variables and Functions","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract ShadowingExample {\n    uint public balance;\n\n    // This function shadows the 'balance' variable\n    function deposit(uint balance) public {\n        // Local variable 'balance' now shadows the contract's balance variable\n        balance += balance;  // This operation affects the local 'balance', not the contract's state variable\n    }\n}\n\ncontract Test {\n    ShadowingExample example;\n\n    constructor() {\n        example = new ShadowingExample();\n    }\n\n    function testDeposit() public {\n        example.deposit(100);  // Calling the deposit function on the example contract\n    }\n}\n</code></pre> In the above example, the parameter <code>balance</code> in the <code>deposit</code> function shadows the contract\u2019s state variable <code>balance</code>. This causes confusion, and the operation <code>balance += balance</code>; modifies the local variable instead of the contract state variable, leading to unexpected behavior.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#fixed-code","title":"Fixed Code","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract ShadowingExample {\n    uint public balance;\n\n    // The parameter is renamed to avoid shadowing the state variable 'balance'\n    function deposit(uint amount) public {\n        balance += amount;  // Correctly updates the contract's state variable\n    }\n}\n\ncontract Test {\n    ShadowingExample example;\n\n    constructor() {\n        example = new ShadowingExample();\n    }\n\n    function testDeposit() public {\n        example.deposit(100);  // Calling the deposit function on the example contract\n    }\n}\n</code></pre> In the optimized version, the function parameter is renamed from <code>balance</code> to <code>amount</code> to avoid shadowing the state variable. This clears up the ambiguity and ensures the function operates on the contract's state variable, not the local variable.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/","title":"SCWE-011: Insecure ABI Encoding and Decoding","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#relationships","title":"Relationships","text":"<ul> <li>CWE-116: Improper Encoding or Escaping of Output    https://cwe.mitre.org/data/definitions/116.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#description","title":"Description","text":"<p>Insecure ABI encoding and decoding occur when a smart contract improperly handles data serialization and deserialization, leading to vulnerabilities such as data corruption, type confusion, or reentrancy attacks. Solidity provides ABI encoding functions like <code>abi.encode()</code>, <code>abi.encodePacked()</code>, and <code>abi.decode()</code>, but improper usage can cause unexpected behavior.</p> <p>Common issues with insecure ABI handling: - Collision Risks in <code>abi.encodePacked()</code>: Multiple concatenated parameters can lead to ambiguous encoding, making it vulnerable to hash collisions. - Unchecked Decoding: Improper use of <code>abi.decode()</code> can result in unintended memory corruption or type confusion. - Lack of Input Validation: Encoding user inputs without verification can introduce security flaws. - Mismatched Data Types: Decoding an incorrectly encoded data structure can lead to invalid memory access.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#remediation","title":"Remediation","text":"<ul> <li>Use <code>abi.encode()</code> Instead of <code>abi.encodePacked()</code> for Hashing: Prevent collision risks by ensuring unique encoding.</li> <li>Validate Data Before Decoding: Ensure the encoded data conforms to the expected structure before decoding.</li> <li>Match Encoding and Decoding Types: Always use the correct type structure when decoding to avoid unintended behavior.</li> <li>Avoid Direct ABI Decoding of External Calls: Use strict validation mechanisms when handling data from external contracts.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#example-of-insecure-abi-encoding","title":"Example of Insecure ABI Encoding:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureABI {\n    function hashValues(string memory str, uint256 num) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(str, num)); // Collision risk\n    }\n}\n</code></pre> <ul> <li>In this example, <code>abi.encodePacked()</code> creates a collision risk because different input combinations can produce the same hash.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#refactored-to-secure-abi-encoding","title":"Refactored to Secure ABI Encoding:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureABI {\n    function hashValues(string memory str, uint256 num) public pure returns (bytes32) {\n        return keccak256(abi.encode(str, num)); // Unique encoding, no collision\n    }\n}\n</code></pre> <ul> <li>In this improved version, <code>abi.encode()</code> ensures a unique encoding structure, preventing hash collision attacks.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/","title":"SCWE-013: Unauthorized Parameter Changes","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#relationships","title":"Relationships","text":"<ul> <li>CWE-233: Improper Handling of Parameters    https://cwe.mitre.org/data/definitions/233.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#description","title":"Description","text":"<p>Unauthorized parameter changes occur when privileged smart contract parameters\u2014such as fees, governance rules, withdrawal limits, or security configurations\u2014can be modified by a single entity or an unauthorized user. This can lead to unexpected behavior, security risks, or financial loss if an attacker gains access to the privileged account.</p> <p>Key risks associated with unauthorized parameter changes: - Single Point of Control: A centralized owner can unilaterally alter critical parameters, leading to governance concerns. - Malicious Modifications: Attackers who exploit an access control flaw may change key parameters, resulting in stolen funds or manipulated contract logic. - Lack of Transparency: Hidden or undocumented parameter changes can mislead users and investors, reducing trust. - Impact on DeFi Protocols: Unauthorized changes to liquidity pool fees, interest rates, or reward mechanisms can disrupt incentives and harm protocol users.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#remediation","title":"Remediation","text":"<ul> <li>Use Role-Based Access Control (RBAC): Assign granular roles and restrict who can modify key parameters.</li> <li>Multisig Approval for Parameter Changes: Require governance approval (e.g., Gnosis Safe) before making critical updates.</li> <li>Timelocks for Parameter Changes: Introduce time delays on modifications to allow community review and prevent instant malicious changes.</li> <li>On-Chain Governance for DAOs: Utilize decentralized governance mechanisms where stakeholders vote on parameter updates.</li> <li>Emit Events for Transparency: Log all parameter changes on-chain to ensure visibility and auditability.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#example-of-a-contract-with-unauthorized-parameter-changes-centralized-control","title":"Example of a Contract With Unauthorized Parameter Changes (Centralized Control)","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract RiskyContract {\n    address public owner;\n    uint256 public feeRate;\n\n    constructor() {\n        owner = msg.sender;\n        feeRate = 5; // Default fee rate\n    }\n\n    function updateFeeRate(uint256 newRate) public {\n        require(msg.sender == owner, \"Only owner can update fee rate\");\n        feeRate = newRate; // \u274c Single entity can modify a critical parameter at any time\n    }\n}\n</code></pre> <ul> <li>In this example, the owner can unilaterally change the fee rate, which poses a security risk.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#refactored-to-require-multisig-and-timelocks","title":"Refactored to Require Multisig and Timelocks","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface ITimelock {\n    function queueTransaction(address target, uint256 value, bytes calldata data, uint256 eta) external;\n    function executeTransaction(address target, uint256 value, bytes calldata data, uint256 eta) external;\n}\n\ncontract SecureGovernance {\n    ITimelock public timelock;\n    uint256 public feeRate;\n\n    constructor(address _timelock) {\n        timelock = ITimelock(_timelock);\n        feeRate = 5; // Default fee rate\n    }\n\n    function updateFeeRate(uint256 newRate) public {\n        bytes memory data = abi.encodeWithSignature(\"setFeeRate(uint256)\", newRate);\n        timelock.queueTransaction(address(this), 0, data, block.timestamp + 2 days); // \u2705 Adds delay before execution\n    }\n\n    function setFeeRate(uint256 newRate) public {\n        require(msg.sender == address(timelock), \"Only timelock can execute\");\n        feeRate = newRate;\n    }\n}\n</code></pre> <p>This improved version: - Uses a Timelock contract to delay parameter changes, preventing instant unauthorized updates. - Restricts execution to an approved governance mechanism, preventing a single actor from making direct changes.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/","title":"SCWE-014: Lack of Emergency Stop Mechanism","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#relationships","title":"Relationships","text":"<ul> <li>CWE-693: Protection Mechanism Failure CWE-693</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#description","title":"Description","text":"<p>A Lack of Emergency Stop Mechanism refers to the absence of a built-in feature in a smart contract that allows for halting or pausing critical operations during emergencies. This mechanism is essential for mitigating risks like a discovered vulnerability, unexpected behavior, or a malicious attack. Without this safeguard, the contract may continue executing malicious actions or suffer irreversible damage. The ability to stop critical functions provides an important recovery measure in scenarios where an exploit is detected or control needs to be regained.</p> <p>Key risks: - Continuous execution of harmful or malicious actions without control. - Difficulty in recovering from unexpected failures. - Increased vulnerability to hacks or exploitation.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#remediation","title":"Remediation","text":"<ul> <li>Implement a pausable contract pattern: Use the <code>Pausable</code> contract from the OpenZeppelin library to implement a mechanism that allows authorized users (e.g., the owner or a governance entity) to pause and unpause certain critical contract functions.</li> <li>Limit emergency stop to critical functions: Ensure that only critical functions can be paused to minimize the impact on the rest of the system's operation.</li> <li>Implement role-based access control: Use a role-based mechanism to control who has the ability to pause or unpause functions, reducing the risk of unauthorized access.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#lack-of-emergency-stop-mechanism-example","title":"Lack of Emergency Stop Mechanism Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract NoEmergencyStop {\n    address public owner;\n    uint public criticalValue;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // This function is critical and lacks an emergency stop mechanism\n    function updateCriticalValue(uint newValue) public {\n        require(msg.sender == owner, \"Only the owner can update this value\");\n        criticalValue = newValue;\n    }\n}\n</code></pre> In the <code>NoEmergencyStop</code> contract, there is no way to stop or pause critical operations, which makes it vulnerable to continued exploitation if an issue arises.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#fixed-emergency-stop-mechanism-example","title":"Fixed: Emergency Stop Mechanism Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\"; // OZ 5.x: utils/Pausable.sol\n\ncontract EmergencyStopExample is Pausable {\n    address public owner;\n    uint public criticalValue;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Critical function that can be paused in case of emergency\n    function updateCriticalValue(uint newValue) public whenNotPaused {\n        require(msg.sender == owner, \"Only the owner can update this value\");\n        criticalValue = newValue;\n    }\n\n    // Emergency stop function to pause the contract\n    function emergencyStop() public {\n        require(msg.sender == owner, \"Only the owner can stop the contract\");\n        _pause();  // Pauses the contract\n    }\n\n    // Emergency restart function to unpause the contract\n    function resumeOperations() public {\n        require(msg.sender == owner, \"Only the owner can resume the contract\");\n        _unpause();  // Resumes the contract\n    }\n}\n</code></pre> The <code>EmergencyStopExample</code> contract implements the <code>Pausable</code> pattern, which allows the contract owner to pause and unpause critical functions using the <code>emergencyStop</code> and <code>resumeOperations</code> functions. This ensures that if a vulnerability is discovered or a critical issue occurs, the contract can be halted temporarily to prevent further damage.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/","title":"SCWE-039: Insecure Use of Inline Assembly","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#relationships","title":"Relationships","text":"<ul> <li>CWE-704: Incorrect Type Conversion or Cast CWE-704 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#description","title":"Description","text":"<p>Insecure use of inline assembly refers to vulnerabilities that arise when low-level assembly code is used improperly. This can lead to: - Incorrect type conversions or casts. - Exploitation of vulnerabilities in low-level operations. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#remediation","title":"Remediation","text":"<ul> <li>Avoid inline assembly: Use high-level Solidity code whenever possible.</li> <li>Validate inputs: Ensure all inputs to assembly code are properly validated.</li> <li>Test thoroughly: Conduct extensive testing to ensure assembly code is secure.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#examples","title":"Examples","text":"<ul> <li>Insecure Inline Assembly- Unsafe Type Casting Leads to Exploitable Overflow <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureAssembly {\n    function unsafeCast(uint256 value) public pure returns (uint8) {\n        uint8 result;\n        assembly {\n            result := value // Unsafe cast, truncating high bits\n        }\n        return result;\n    }\n}\n</code></pre> \u26a0\ufe0f Why is this Vulnerable?</li> <li>Casting a large uint256 into uint8 without bounds checking causes integer truncation.</li> <li>If value = 257, it becomes 1 (256 is lost).</li> <li> <p>Attackers can bypass security checks if truncation affects authentication or balance checks.</p> </li> <li> <p>Secure Alternative \u2014 High-Level Code with Bounds Checking <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureAssembly {\n    function safeCast(uint256 value) public pure returns (uint8) {\n        require(value &lt;= type(uint8).max, \"Value too large\"); // Prevent truncation\n        return uint8(value);\n    }\n}\n</code></pre> Fixes:</p> </li> <li>Bounds checking (require) prevents unintended truncation.</li> <li>Prefer high-level Solidity over assembly when possible; if assembly is required, validate inputs first.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/","title":"SCWE-040: Incorrect Storage Packing","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#relationships","title":"Relationships","text":"<ul> <li>CWE-805: Buffer Access with Incorrect Length Value https://cwe.mitre.org/data/definitions/805.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#description","title":"Description","text":"<p>Incorrect storage packing in Solidity occurs when storage variables are not efficiently packed within a single storage slot, leading to unnecessary gas consumption. Solidity automatically stores variables in 32-byte (256-bit) slots, and inefficient ordering of data types can lead to wasted space. Contracts that fail to optimize storage packing may incur higher gas costs during deployments and transactions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#remediation","title":"Remediation","text":"<p>To optimize storage packing: - Group smaller data types together (e.g., <code>uint8</code>, <code>bool</code>) to fit within a single 32-byte slot. - Avoid leaving gaps between variables of different sizes. - Order state variables efficiently to minimize wasted storage slots.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InefficientStorage {\n    uint256 a;  // Occupies full 32-byte slot\n    bool b;     // Occupies another 32-byte slot (wasteful)\n    uint8 c;    // Uses a new 32-byte slot instead of sharing\n    uint256 d;  // Uses its own slot, leading to extra gas costs\n}\n</code></pre> <p>Why is this vulnerable? - Each variable unnecessarily occupies a separate storage slot, increasing gas costs. - The <code>bool</code> and <code>uint8</code> could be packed into the same 32-byte slot, reducing wasted storage space.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract OptimizedStorage {\n    uint256 a;   // Occupies one full 32-byte slot\n    uint256 d;   // Placed next to 'a' to use another full slot\n    bool b;      // Packed within the same slot as 'c'\n    uint8 c;     // Fits within the same slot as 'b'\n}\n</code></pre> Why is this safe? - <code>bool</code> and <code>uint8</code> share the same storage slot, reducing unnecessary storage use. - <code>uint256</code> variables are placed together to minimize fragmentation. - Optimized storage layout leads to lower gas costs for contract execution.</p> <p>By correctly ordering state variables and utilizing Solidity\u2019s storage packing rules, developers can significantly reduce gas fees and improve contract efficiency.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/","title":"SCWE-041: Unsafe Downcasting","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#relationships","title":"Relationships","text":"<ul> <li>CWE-681: Incorrect Conversion between Numeric Types https://cwe.mitre.org/data/definitions/681.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#description","title":"Description","text":"<p>Unsafe downcasting occurs when a larger integer type is implicitly or explicitly converted to a smaller type, leading to precision loss, unintended value changes, or integer overflows. Solidity does not automatically check for overflow when performing explicit type conversions, making it possible to unintentionally truncate values.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#remediation","title":"Remediation","text":"<p>To prevent unsafe downcasting: - Always validate that the value fits within the target data type before casting. - Use safe mathematical libraries like OpenZeppelin's <code>SafeCast</code> to ensure proper conversions. - Avoid unnecessary downcasting unless explicitly needed for gas optimization.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UnsafeDowncasting {\n    function truncateValue(uint256 largeNumber) public pure returns (uint8) {\n        return uint8(largeNumber);  // \u26a0\ufe0f Potential data loss if largeNumber &gt; 255\n    }\n}\n</code></pre> <p>Why is this vulnerable? - If <code>largeNumber &gt; 255</code>, the higher bits will be truncated, resulting in unexpected values. - No validation ensures that <code>largeNumber</code> fits within <code>uint8</code>, leading to silent failures.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract SafeDowncasting {\n    using SafeCast for uint256;\n\n    function safeTruncateValue(uint256 largeNumber) public pure returns (uint8) {\n        return largeNumber.toUint8();  // \u2705 Ensures safe conversion\n    }\n}\n</code></pre> Why is this safe?</p> <ul> <li>Uses OpenZeppelin\u2019s <code>SafeCast</code> library to enforce safe downcasting.</li> <li>If <code>largeNumber</code> exceeds <code>uint8</code> limits, the transaction will revert instead of silently truncating.</li> <li>Prevents unexpected behavior and potential security vulnerabilities.</li> </ul> <p>By properly handling type conversions, developers can avoid integer truncation issues and maintain data integrity in smart contracts.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/","title":"SCWE-046: Reentrancy Attacks","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#relationships","title":"Relationships","text":"<ul> <li>CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition https://cwe.mitre.org/data/definitions/367.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#description","title":"Description","text":"<p>Reentrancy attacks occur when a contract allows untrusted external calls during execution without properly updating state variables or implementing protections. This enables attackers to repeatedly call functions and manipulate the contract\u2019s state before execution completes. Common issues include:</p> <ul> <li>Making external calls before updating state variables.  </li> <li>Lack of mechanisms to prevent repeated or recursive calls.  </li> <li>Improper handling of external interactions. </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#remediation","title":"Remediation","text":"<ul> <li>Update state first: Modify critical state variables before any external calls.  </li> <li>Implement reentrancy guards: Use tools like <code>nonReentrant</code> modifiers to block recursive calls. </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#vulnerable-contract-example-reentrancy","title":"Vulnerable Contract Example (Reentrancy)","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vulnerable {\n    mapping(address =&gt; uint) public balances;\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount);\n        (bool success, ) = msg.sender.call{value: _amount}(\"\"); // Vulnerable: external call before state update (reentrancy)\n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= _amount;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; // OZ 5.x: utils/ReentrancyGuard.sol\n\ncontract Secure is ReentrancyGuard {\n    mapping(address =&gt; uint) public balances;\n\n    function withdraw(uint _amount) public nonReentrant {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/","title":"SCWE-047: Integer Overflows and Underflows","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#relationships","title":"Relationships","text":"<ul> <li>CWE-190: Integer Overflow or Wraparound https://cwe.mitre.org/data/definitions/190.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#description","title":"Description","text":"<p>Integer overflows and underflows occur when arithmetic operations exceed the bounds of the integer data type, causing the value to \"wrap around\" to an unexpected number.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#remediation","title":"Remediation","text":"<ul> <li>Use Solidity 0.8.0 or later: Leverage the compiler\u2019s built-in overflow and underflow checks.  </li> <li>Apply SafeMath libraries: Use libraries like OpenZeppelin\u2019s <code>SafeMath</code> for versions before 0.8.0.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Vulnerable {\n    uint8 public totalSupply;\n\n    function addTokens(uint8 _value) public {\n        totalSupply += _value; // May overflow\n    }\n\n    function subtractTokens(uint8 _value) public {\n        totalSupply -= _value; // May underflow\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Secure {\n    uint8 public totalSupply;\n\n    function addTokens(uint8 _value) public {\n        totalSupply += _value; // Built-in overflow check in 0.8+\n    }\n\n    function subtractTokens(uint8 _value) public {\n        totalSupply -= _value; // Built-in underflow check in 0.8+\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/","title":"SCWE-048: Unchecked Call Return Value","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#relationships","title":"Relationships","text":"<ul> <li>CWE-252: Unchecked Return Value   https://cwe.mitre.org/data/definitions/252.html</li> <li>CWE-390: Detection of Error Condition Without Action   https://cwe.mitre.org/data/definitions/390.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#description","title":"Description","text":"<p>Unchecked call return value vulnerabilities occur when a contract fails to validate the success or failure of low-level calls, such as <code>call</code>, <code>delegatecall</code>, and <code>staticcall</code>. Ignoring the return values of these calls can result in undetected errors, allowing malicious or unintended actions to succeed silently.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#remediation","title":"Remediation","text":"<ul> <li>Check return values: Always verify the success of low-level calls.  </li> <li>Use higher-level abstractions: Prefer method calls or, if you are confident that 2300 gas are sufficient for the recipient to handle the transfer, <code>transfer</code> over <code>call</code>, as they revert on failure. </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UncheckedCall {\n    function sendEther(address _recipient) public payable {\n        _recipient.call{value: msg.value}(\"\"); // Unchecked call, no error handling\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract CheckedCall {\n    function sendEther(address payable _recipient) public payable {\n        (bool success, ) = _recipient.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/","title":"SCWE-053: Improper Deletion of Mappings","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#relationships","title":"Relationships","text":"<ul> <li>CWE-459: Incomplete Cleanup https://cwe.mitre.org/data/definitions/459.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#description","title":"Description","text":"<p>In Solidity, mappings (<code>mapping(address =&gt; uint256)</code>) do not store key-value pairs in a way that allows them to be iterated over or deleted in a straightforward manner. Deleting a mapping variable does not remove its entries; it only resets the reference to the mapping, leaving stale data accessible if another variable references the same mapping. Improper deletion of mappings can lead to storage inconsistencies, potential access control issues, and unintended behavior.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#remediation","title":"Remediation","text":"<ul> <li>Instead of using <code>delete mappingVariable;</code>, explicitly set each key\u2019s value to zero where necessary.  </li> <li>Consider additional data structures (e.g., arrays or linked lists) to track mapping keys if deletion is required.  </li> <li>Ensure mapping deletions do not leave residual data that can be accessed unexpectedly.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    mapping(address =&gt; uint256) public balances;\n\n    function addBalance(address user, uint256 amount) public {\n        balances[user] = amount;\n    }\n\n    function resetBalances() public {\n        delete balances;  // \u274c This does not clear individual key-value pairs!\n    }\n}\n</code></pre> Why is this vulnerable?</p> <ul> <li><code>delete balances;</code> only resets the storage reference but does not remove key-value pairs.</li> <li>If another contract or function still references <code>balances</code>, the data remains accessible.</li> <li>Unexpected behavior may arise where users assume balances have been erased but can still access the old data.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureExample {\n    mapping(address =&gt; uint256) public balances;\n    address[] private users;\n\n    function addBalance(address user, uint256 amount) public {\n        if (balances[user] == 0) {\n            users.push(user);\n        }\n        balances[user] = amount;\n    }\n\n    function resetBalances() public {\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            balances[users[i]] = 0;  // \u2705 Explicitly clears each entry\n        }\n        delete users;  // \u2705 Resets the tracking array\n    }\n}\n</code></pre> <p>Why is this safe? - Tracks users in an array to allow explicit deletion of each mapping entry. - Ensures all key-value pairs are properly reset instead of just deleting the mapping reference. - Prevents residual data from being accessed unintentionally.</p> <p>By properly handling mapping deletions, developers can avoid unintended data persistence and ensure accurate contract state management.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/","title":"SCWE-060: Floating Pragma","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#relationships","title":"Relationships","text":"<ul> <li>CWE-703: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/703.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#description","title":"Description","text":"<p>The use of floating pragmas (e.g., <code>^0.8.0</code>) in smart contract development can lead to unexpected issues when new versions of the Solidity compiler are released. Floating versions allow the contract to automatically use newer versions of the compiler within the specified range, which may introduce breaking changes, unexpected bugs, or security vulnerabilities. To avoid this, it is important to specify fixed versions to ensure the contract works reliably and consistently across different environments.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, always specify a fixed compiler version in the contract to avoid using floating pragmas. This ensures that the contract is compiled using a known and tested version of the compiler, preventing unexpected behavior from new, untested releases.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;  // Floating version allows for any 0.8.x version\n\ncontract Vulnerable {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity 0.8.4;  // Fixed version ensures no unexpected updates\n\ncontract Fixed {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/","title":"SCWE-061: Outdated Compiler Version","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#relationships","title":"Relationships","text":"<ul> <li>CWE-1103: Use of Outdated or Insecure Software https://cwe.mitre.org/data/definitions/1103.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#description","title":"Description","text":"<p>Using an outdated compiler version can expose a smart contract to vulnerabilities that have already been patched in newer versions. Compiler versions often include security fixes, optimizations, and new features that are crucial for the safety and performance of contracts.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, always use the most up-to-date stable version of the Solidity compiler. Ensure that your development environment is regularly updated to incorporate the latest security patches, optimizations, and features provided by newer versions of the compiler.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity 0.4.24;  // Outdated compiler version\n\ncontract Vulnerable {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity 0.8.4;  // Updated compiler version for better security and performance\n\ncontract Fixed {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/","title":"SCWE-062: Dead Code","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#relationships","title":"Relationships","text":"<ul> <li>CWE-561: Dead Code https://cwe.mitre.org/data/definitions/561.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#description","title":"Description","text":"<p>Code with no effects or Dead Code- refers to segments of a smart contract that are never executed or do not alter the contract's state or output. This can lead to unnecessary gas consumption, complicate the contract\u2019s logic, and potentially confuse developers. Dead code often appears as leftover code from previous iterations or functions that are no longer in use but have not been removed. Removing such code improves contract efficiency and readability.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that all functions, variables, and logic in the smart contract have a purpose and contribute to the contract\u2019s behavior. Unused code should be removed to reduce complexity, save gas, and improve maintainability.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vulnerable {\n    uint public value;\n\n    // Dead code, never called or used\n    function unusedFunction() public {\n        uint x = 5;\n        uint y = 10;\n        uint result = x + y;\n    }\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Fixed {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/","title":"SCWE-066: Incorrect Handling of Bitwise Operations","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#description","title":"Description","text":"<p>Bitwise operations (e.g., <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) can be efficient alternatives to arithmetic operations but are prone to errors if not used correctly. Misusing bitwise shifts can cause unintended value changes, integer overflows, or precision loss. Solidity lacks native overflow checks for bitwise shifts, making incorrect handling particularly dangerous in financial calculations or cryptographic functions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#remediation","title":"Remediation","text":"<ul> <li>Ensure bitwise shifts do not exceed the size of the data type (e.g., shifting a <code>uint8</code> left by 8+ bits).  </li> <li>Validate input ranges before performing shifts to prevent overflow or precision loss.  </li> <li>Avoid unnecessary bitwise operations in financial calculations unless explicitly needed.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function shiftLeft(uint8 input) public pure returns (uint8) {\n        return input &lt;&lt; 8;  // \u274c Shifting beyond `uint8` capacity leads to zero\n    }\n\n    function bitwiseAnd(uint8 a, uint8 b) public pure returns (uint8) {\n        return a &amp; b;  // \u274c Without proper validation, this could lead to unintended masking\n    }\n}\n</code></pre> Why is this vulnerable?</p> <ul> <li><code>input &lt;&lt; 8</code> shifts a <code>uint8</code> completely out of range, resulting in a value of <code>0</code>.</li> <li><code>a &amp; b</code> can unintentionally mask critical bits if inputs are not properly validated.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureExample {\n    function safeShiftLeft(uint8 input) public pure returns (uint8) {\n        require(input &lt; 32, \"Shift too large\");  // \u2705 Validate shift range\n        return input &lt;&lt; 2;  // \u2705 Safe shift within `uint8` bounds\n    }\n\n    function safeBitwiseAnd(uint8 a, uint8 b) public pure returns (uint8) {\n        require(a &gt; 0 &amp;&amp; b &gt; 0, \"Invalid input\");  // \u2705 Ensure inputs are meaningful\n        return a &amp; b;\n    }\n}\n</code></pre> <p>Why is this safe?</p> <ul> <li>Restricts shift values to prevent unexpected overflows.</li> <li>Ensures bitwise operations do not unintentionally modify values in an unintended way.</li> <li>Protects contract logic from potential manipulation through poorly validated inputs.</li> </ul> <p>By correctly handling bitwise operations, developers can avoid unintended computation errors and ensure mathematical correctness in smart contracts.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/","title":"SCWE-067: Assert Violation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/754.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#description","title":"Description","text":"<p>In Ethereum smart contracts, assertions (<code>assert</code>) are commonly used for internal consistency checks and to prevent erroneous states. However, if not used correctly, they can lead to unexpected behavior. When an <code>assert</code> statement fails, it reverts the entire transaction, and all changes made in the transaction are reverted. This can be problematic if it is used for conditions that can be expected during normal contract execution.</p> <p>Using <code>assert</code> for conditions that can occur under normal circumstances (e.g., user inputs or contract logic) may cause unnecessary reverts and loss of gas. It\u2019s important to reserve <code>assert</code> for critical errors, such as invariants and internal state checks that should never fail.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#remediation","title":"Remediation","text":"<p>To avoid unnecessary assertion failures, use <code>require</code> for input validation and conditions that can reasonably fail. <code>assert</code> should only be used for internal error detection and state validation that should never happen, as it signals a critical issue if violated.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vulnerable {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n\n    function withdraw(uint amount) public {\n        assert(balance &gt;= amount);  // Assert violation on user input\n        balance -= amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Secure {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n\n    function withdraw(uint amount) public {\n        require(balance &gt;= amount, \"Insufficient balance\");  // Use require for expected conditions\n        balance -= amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/","title":"SCWE-068: State Variable Default Visibility","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#relationships","title":"Relationships","text":"<ul> <li>CWE-704: Incorrect Type Conversion or Cast https://cwe.mitre.org/data/definitions/704.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#description","title":"Description","text":"<p>In Solidity, state variables have a default visibility of <code>internal</code>, which means they can only be accessed within the contract or derived contracts (not by external callers). Omitting explicit visibility can lead to unintended behavior: for example, if a developer intends <code>private</code> but forgets to specify it, derived contracts can still access the variable; if they intend <code>public</code> but omit it, no getter is generated and external callers cannot read the value. Explicit visibility ensures the variable behaves as intended.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#remediation","title":"Remediation","text":"<p>Always explicitly specify the visibility of state variables. The possible visibility options are: - <code>public</code>: Accessible by anyone, both externally and internally. - <code>internal</code>: Accessible only within the contract or derived contracts (default). - <code>private</code>: Accessible only within the contract.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Vulnerable {\n    uint balance;  // Default internal; no getter \u2014 external callers cannot read it\n\n    constructor() {\n        balance = 100;\n    }\n\n    function updateBalance(uint amount) public {\n        balance = amount;  // Intended public? Forgot visibility \u2014 no automatic getter\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Secure {\n    uint private balance;  // Explicitly set visibility to private\n\n    constructor() {\n        balance = 100;\n    }\n\n    function updateBalance(uint amount) public {\n        balance = amount;  // No external access to the variable\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/","title":"SCWE-069: Shadowing State Variables","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#relationships","title":"Relationships","text":"<ul> <li>CWE-1001: Variable Shadowing https://cwe.mitre.org/data/definitions/1001.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#description","title":"Description","text":"<p>Shadowing occurs when a state variable in a derived contract uses the same name as one in the base contract. This can lead to confusion and unexpected behavior, as the derived contract will hide the state variable from the base contract, potentially causing errors in contract logic or making it harder to maintain and audit the code.</p> <p>It is essential to avoid naming state variables in derived contracts the same as those in base contracts to ensure that the intended state is correctly accessed and modified.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#remediation","title":"Remediation","text":"<p>To avoid state variable shadowing, use unique names for state variables in derived contracts or explicitly refer to the base contract variable using <code>super</code>. This will ensure that the correct state variable is accessed and manipulated as intended.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Base {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n}\n\ncontract Derived is Base {\n    uint public balance;  // Shadows state variable from Base contract\n\n    function updateBalance(uint amount) public {\n        balance = amount;  // Refers to Derived's balance, not Base's balance\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Base {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n}\n\ncontract Derived is Base {\n    uint public newBalance;  // Unique name for Derived contract\n\n    function updateBalance(uint amount) public {\n        newBalance = amount;  // Updates Derived's balance without shadowing\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/","title":"SCWE-072: Use of Deprecated Solidity Functions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#relationships","title":"Relationships","text":"<ul> <li>CWE-676: Use of a Dangerous Function https://cwe.mitre.org/data/definitions/676.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#description","title":"Description","text":"<p>Some Solidity functions and features have been deprecated over time due to security risks, inefficiencies, or better alternatives being introduced in newer versions of Solidity. Using deprecated functions can expose contracts to known vulnerabilities and potential attacks. Examples include <code>suicide()</code>, which was replaced by <code>selfdestruct()</code>, and <code>sha3()</code>, which was replaced by <code>keccak256()</code>.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#remediation","title":"Remediation","text":"<p>Always check the Solidity documentation to ensure that the functions you're using are not deprecated. If a function is deprecated, replace it with its recommended alternative to maintain the contract's security and ensure compatibility with future Solidity versions. Note: As of EIP-6049 (Solidity 0.8.24+), <code>selfdestruct</code> is deprecated and will be removed in a future EVM version.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function oldFunction() public {\n        // Using deprecated function `suicide`\n        suicide(msg.sender);  // Deprecated, should be replaced with `selfdestruct`\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function oldFunction() public {\n        // Correctly using the recommended alternative `selfdestruct` (deprecated per EIP-6049; prefer migration patterns)\n        selfdestruct(payable(msg.sender));  // Replacing deprecated `suicide` with `selfdestruct`\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/","title":"SCWE-076: Right-To-Left-Override Control Character (U+202E)","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#relationships","title":"Relationships","text":"<ul> <li>CWE-451: User Interface (UI) Misrepresentation of Critical Information CWE-451 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#description","title":"Description","text":"<p>The Right-To-Left-Override (RTLO) control character (U+202E) can be used to manipulate the display order of text, creating misleading or deceptive visual representations in source code. Malicious actors can exploit this to: - Mask malicious logic or misrepresent code intent. - Introduce security-critical bugs that are difficult to detect visually. - Deceive auditors, developers, or end-users by obscuring real functionality.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#remediation","title":"Remediation","text":"<ul> <li>Disallow U+202E in source code: Ensure RTLO and similar Unicode direction control characters are explicitly banned in smart contracts.</li> <li>Static analysis tools: Use static analysis to detect and prevent Unicode control characters in contract source code.</li> <li>Education and awareness: Educate developers about the risks associated with Unicode control characters in smart contract development.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#examples","title":"Examples","text":"<ul> <li> <p>Code with RTLO Character <pre><code>pragma solidity ^0.8.0;\n\ncontract MaliciousExample {\n    function performAction() public {\n        // The following line contains an RTLO character to misrepresent the logic visually\n        executeLogic(/* attacker logic\u202e/*desrever ro*/victim logic */);\n    }\n\n    function executeLogic(bytes memory logic) internal {\n        // Process logic here\n    }\n}\n</code></pre></p> </li> <li> <p>Code Without RTLO Character <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureExample {\n    function performAction(bytes memory logic) public {\n        // Properly documented and clear function calls\n        executeLogic(logic);\n    }\n\n    function executeLogic(bytes memory logic) internal {\n        // Process logic here\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/","title":"SCWE-089: Vulnerable & Outdated Libraries","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#relationships","title":"Relationships","text":"<ul> <li>CWE-1104: Use of Unmaintained Third Party Components CWE-1104 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#description","title":"Description","text":"<p>Smart contracts that depend on outdated or vulnerable third\u2011party libraries inherit their security flaws. Attackers can exploit known issues in widely used libraries (e.g., reentrancy, integer overflow, or access control bypasses), especially if the library is no longer maintained or patched. Common risks include: - Exploitation of known vulnerabilities in older OpenZeppelin versions or other dependencies. - Inheriting insecure logic or deprecated patterns from unmaintained libraries. - Increased attack surface due to indirect dependencies.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#remediation","title":"Remediation","text":"<ul> <li>Version pinning: Always specify exact, up\u2011to\u2011date versions of dependencies in <code>package.json</code>, <code>foundry.toml</code>, or <code>hardhat.config.js</code>.  </li> <li>Regular audits: Periodically review library versions for known vulnerabilities and upgrade accordingly.  </li> <li>Vendor management: Rely on reputable, actively maintained libraries (e.g., OpenZeppelin). Avoid custom forks unless fully audited.  </li> <li>Automated scanning: Use dependency scanners (e.g., <code>npm audit</code>, <code>snyk</code>, <code>slither-check-oz</code>) to detect outdated or vulnerable libraries.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#examples","title":"Examples","text":"<ul> <li> <p>Outdated Dependency Example (<code>package.json</code>) <pre><code>{\n  \"dependencies\": {\n    \"@openzeppelin/contracts\": \"^2.3.0\",\n    \"truffle\": \"^5.0.0\"\n  },\n  \"notes\": \"Insecure: OpenZeppelin v2.3.0 contains outdated ERC777 and SafeMath implementations.\"\n}\n</code></pre></p> </li> <li> <p>Updated Dependency Example (<code>package.json</code>) <pre><code>{\n  \"dependencies\": {\n    \"@openzeppelin/contracts\": \"^5.0.0\",\n    \"hardhat\": \"^2.22.0\"\n  },\n  \"notes\": \"Secure: Latest OpenZeppelin release with modern ERC20, patched ERC777, and Solidity 0.8+ overflow checks.\"\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/","title":"SCWE-090: Missing Slippage Protection in Automated Token Swaps","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#relationships","title":"Relationships","text":"<ul> <li>CWE-20:  Improper Input Validation    CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#description","title":"Description","text":"<p>This weakness occurs when smart contracts execute token swaps through DEX routers (e.g., Uniswap, PancakeSwap, SushiSwap) with the amountOutMin parameter set to 0 or a hardcoded static value. This disables slippage protection and allows trades to execute regardless of adverse price movement. As a result, users or protocols may receive significantly fewer tokens than expected, especially under high volatility, front-running, or sandwich attack conditions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#remediation","title":"Remediation","text":"<ul> <li>Always validate amountOutMin based on live price quotes (e.g., using on-chain oracles or pre-trade estimates).</li> <li>Allow users to configure slippage tolerance (0.5%, 1%, etc.), and enforce it in contract logic.</li> <li>Never hardcode 0 or static values for amountOutMin.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Code (Missing Slippage Protection) <pre><code>function swapTokens(address tokenIn, address tokenOut, uint256 amountIn) external {\n    IERC20(tokenIn).approve(address(uniswapRouter), amountIn);\n\n    address[] memory path = new address[](2);\n    path[0] = tokenIn;\n    path[1] = tokenOut;\n\n    // \u274c amountOutMin is set to 0 \u2192 no protection against slippage\n    uniswapRouter.swapExactTokensForTokens(\n        amountIn,\n        0, // Vulnerable: accepts any output amount\n        path,\n        msg.sender,\n        block.timestamp\n    );\n} \n</code></pre></p> </li> <li> <p>Safe Code (With Slippage Protection) <pre><code>function swapTokensWithSlippage(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 minAmountOut\n) external {\n    IERC20(tokenIn).approve(address(uniswapRouter), amountIn);\n\n    address[] memory path = new address[](2);\n    path[0] = tokenIn;\n    path[1] = tokenOut;\n\n    // \u2705 Enforces user-provided slippage tolerance\n    uniswapRouter.swapExactTokensForTokens(\n        amountIn,\n        minAmountOut, // Safe: requires a minimum output\n        path,\n        msg.sender,\n        block.timestamp\n    );\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/","title":"SCWE-091: Lack of Zero Value Check in Token Transfers","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions CWE-754 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#description","title":"Description","text":"<p>This weakness occurs when smart contracts perform ERC20 token transfers without first validating that the transfer amount is greater than zero. While most ERC20 tokens allow zero\u2011value transfers, some implementations (e.g., LEND and others) revert when the amount is zero. This inconsistency can cause unexpected reverts in production, disrupt execution flow, and prevent critical contract logic from completing successfully. Common risks include: - Unexpected revert when interacting with non\u2011standard ERC20 tokens that disallow zero\u2011value operations. - Potential denial\u2011of\u2011service conditions if an attacker or integration repeatedly triggers zero\u2011value transfers. - Broken integrations when protocols assume uniform ERC20 behavior across diverse tokens.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#remediation","title":"Remediation","text":"<ul> <li>Validate transfer amounts: Ensure <code>amount &gt; 0</code> before calling <code>transfer</code>/<code>transferFrom</code>.  </li> <li>Treat zero as a no\u2011op if acceptable: Early\u2011return when <code>amount == 0</code> rather than calling token methods.  </li> <li>Use robust token wrappers: Centralize token operations (e.g., via OpenZeppelin <code>SafeERC20</code>) and standardize zero\u2011value handling.  </li> <li>Integration testing: Include zero\u2011value cases for all integrated tokens (especially known non\u2011standard tokens like LEND).  </li> <li>Input sanitization: Validate and sanitize externally supplied amounts prior to token interactions.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Code (No Zero Value Check) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; // OZ 5.x: token/ERC20/utils/SafeERC20.sol\n\ncontract ExampleContract {\n    using SafeERC20 for IERC20;\n    IERC20 public inToken;\n    address public vault;\n\n    function transferTokens(uint256 feeTokenAmount) external {\n        // No validation \u2192 may revert with some ERC20 tokens\n        inToken.safeTransfer(vault, feeTokenAmount);\n    }\n}\n</code></pre></p> </li> <li> <p>Safe Code (With Zero Value Check) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; // OZ 5.x: token/ERC20/utils/SafeERC20.sol\n\ncontract ExampleContract {\n    using SafeERC20 for IERC20;\n    IERC20 public inToken;\n    address public vault;\n\n    function transferTokens(uint256 feeTokenAmount) external {\n        require(feeTokenAmount &gt; 0, \"Amount must be greater than zero\");\n        inToken.safeTransfer(vault, feeTokenAmount);\n    }\n}\n</code></pre></p> </li> <li> <p>Alternative Safe Pattern (No\u2011op on Zero) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; // OZ 5.x: token/ERC20/utils/SafeERC20.sol\n\ncontract ExampleContract {\n    using SafeERC20 for IERC20;\n    IERC20 public inToken;\n    address public vault;\n\n    function transferTokens(uint256 feeTokenAmount) external {\n        if (feeTokenAmount == 0) {\n            return; // Skip calling token methods to avoid non-standard reverts\n        }\n        inToken.safeTransfer(vault, feeTokenAmount);\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/","title":"SCWE-092: Missing Disable Initializer in Constructor for Proxy Contracts","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#relationships","title":"Relationships","text":"<ul> <li>CWE-665: Improper Initialization</li> </ul>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#description","title":"Description","text":"<p>This weakness occurs when upgradeable proxy contracts (e.g., UUPS or Transparent Proxy patterns) do not include a call to <code>_disableInitializers()</code> inside their constructor. Without this safeguard, malicious actors may invoke the <code>initialize()</code> function directly on the implementation contract. This can lead to takeover of admin roles, unauthorized ownership assignment, or malicious configuration of protocol-critical parameters.  </p> <p>This mistake is frequently observed in contracts built with OpenZeppelin Upgradeable libraries where developers forget to disable initializers in the implementation contract\u2019s constructor.  </p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#impact","title":"Impact","text":"<p>Failure to disable initializers in proxy contracts is a recurring and high-severity weakness. It enables attackers to: - Become the owner/admin of an uninitialized logic contract. - Hijack upgradeability or governance control. - Set malicious parameters (fees, treasury addresses, token supply logic, etc.).  </p> <p>This weakness has caused multiple security incidents in production DeFi and NFT projects where attackers initialized orphaned implementation contracts and drained funds.  </p> <p>Its importance stems from: - Widespread use of upgradeable contracts in DeFi and DAOs. - Frequent developer oversight when using proxy patterns. - High impact \u2014 loss of protocol ownership, funds, and governance control.  </p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#remediation","title":"Remediation","text":"<ul> <li>Always call <code>_disableInitializers()</code> in the constructor of implementation contracts.  </li> <li>Review all upgradeable contracts to ensure the implementation cannot be directly initialized.  </li> <li>Use OpenZeppelin\u2019s recommended pattern and annotations (e.g., <code>@custom:oz-upgrades-unsafe-allow constructor</code>) when disabling initializers.  </li> </ul>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#examples","title":"Examples","text":"<ul> <li>\u274c Vulnerable Code <pre><code>// Implementation contract for a UUPS Proxy\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Vault is Initializable {\n    address public owner;\n\n    function initialize(address _owner) public initializer {\n        owner = _owner;\n    }\n}\n</code></pre></li> </ul> <p>\u26a0\ufe0f Issue: - The constructor does not call <code>_disableInitializers()</code>. - Attackers can directly call <code>initialize()</code> on the implementation contract (not through the proxy) and take over ownership.  </p> <ul> <li>\u2705 Safe Code <pre><code>// Secure implementation contract for a UUPS Proxy\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Vault is Initializable {\n    address public owner;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers(); // Prevents initialize() from being called on implementation\n    }\n\n    function initialize(address _owner) public initializer {\n        owner = _owner;\n    }\n}\n</code></pre></li> </ul> <p>\u2705 Fix: - Adding <code>_disableInitializers()</code> in the constructor ensures the logic (implementation) contract cannot be initialized directly. - Only the proxy can call <code>initialize()</code> safely during deployment.  </p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-093/","title":"SCWE-093: Unnamed Function Parameters","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-093/#relationships","title":"Relationships","text":"<ul> <li>CWE-710: Improper Adherence to Coding Standards</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-093/#description","title":"Description","text":"<p>This weakness occurs when functions declare parameters without names (only types). Unnamed parameters reduce code clarity and hinder maintainability, making it difficult for reviewers and future maintainers to understand the purpose and expected usage of each argument. In smart contracts, where correctness is critical, this ambiguity can result in misinterpretation, incorrect argument ordering in calls or refactors, and subtle logic errors.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-093/#impact","title":"Impact","text":"<p>Lack of clear parameter names can lead to: - Misuse of function arguments due to misunderstanding of their meaning. - Increased likelihood of logic bugs during refactoring and maintenance. - Higher audit and review overhead; reduced readability and self-documentation. - Potential security issues if parameters are confused (e.g., recipient vs. sender, amount vs. fee).  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-093/#remediation","title":"Remediation","text":"<ul> <li>Always provide descriptive names for all function parameters.  </li> <li>Choose meaningful, self-explanatory names consistent with a coding standard.  </li> <li>Supplement with NatSpec where helpful to document parameter intent and units.  </li> <li>Enforce naming conventions with linters and code review checklists.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-093/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Code (Unnamed parameters reduce clarity) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ncontract Example {\n    function transfer(address, uint256, bytes memory) public {\n        // Function logic\n    }\n}\n</code></pre></p> </li> <li> <p>\u2705 Safe Code (Named parameters improve readability) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ncontract Example {\n    function transfer(address recipient, uint256 amount, bytes memory data) public {\n        // Function logic\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-095/","title":"SCWE-095: Missing Destination Address Size Check","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-095/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-095/#description","title":"Description","text":"<p>This weakness occurs when a smart contract function accepts a <code>bytes32</code> parameter intended to represent an Ethereum address without validating its size. Ethereum addresses are 20 bytes, and using a <code>bytes32</code> type without proper checks can lead to incorrect address interpretation, potentially causing funds to be sent to unintended addresses.  </p> <p>This is especially risky in cross-chain, bridging, or interoperability contexts where address formats and padding conventions may vary. If the upper 12 bytes of the <code>bytes32</code> value are non-zero (or the value is otherwise malformed), naive casting to <code>address</code> can silently truncate or misinterpret the actual destination, leading to irreversible fund loss or misdirection.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-095/#impact","title":"Impact","text":"<p>Failure to validate <code>bytes32</code> inputs that represent addresses may enable: - Accidental misdirection of funds to unintended addresses due to truncation. - Loss of funds in production deployments, as ETH/token transfers are irreversible. - Exploitation by attackers who craft inputs with malicious upper bits to redirect value. - Integration fragility in cross-chain workflows where address encoding/padding differs.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-095/#remediation","title":"Remediation","text":"<ul> <li>Avoid using <code>bytes32</code> to represent addresses when possible; prefer the native <code>address</code> type.  </li> <li>If <code>bytes32</code> is required for protocol compatibility, validate that the upper 12 bytes are zero before casting: ensure <code>uint256(destination) &gt;&gt; 160 == 0</code>.  </li> <li>Centralize the validation and conversion logic in a dedicated helper to prevent inconsistent handling.  </li> <li>Add unit tests and fuzzing to verify that malformed <code>bytes32</code> values are rejected.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-095/#examples","title":"Examples","text":"<ul> <li> <p>\u274c Vulnerable Code (Lack of address size validation) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract Example {\n    mapping(address =&gt; uint256) public balances;\n\n    // Deposit ETH\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    // \u274c Vulnerable: destinationAddress is bytes32, not validated\n    function withdraw(bytes32 destinationAddress, uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        _debitFrom(msg.sender, amount);\n        _send(destinationAddress, amount);\n    }\n\n    // Internal debit\n    function _debitFrom(address from, uint256 amount) internal {\n        balances[from] -= amount;\n    }\n\n    // Internal send\n    function _send(bytes32 destinationAddress, uint256 amount) internal {\n        address payable dest = payable(address(uint160(uint256(destinationAddress))));\n        (bool ok, ) = dest.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre></p> </li> <li> <p>\u2705 Safe Code (Validation of address size) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract Example {\n    mapping(address =&gt; uint256) public balances;\n\n    // Deposit ETH\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    // \u2705 Safe: Validates destinationAddress size\n    function withdraw(bytes32 destinationAddress, uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        require(uint256(destinationAddress) &gt;&gt; 160 == 0, \"Invalid address: upper 12 bytes must be zero\");\n        _debitFrom(msg.sender, amount);\n        _send(destinationAddress, amount);\n    }\n\n    // Internal debit\n    function _debitFrom(address from, uint256 amount) internal {\n        balances[from] -= amount;\n    }\n\n    // Internal send\n    function _send(bytes32 destinationAddress, uint256 amount) internal {\n        address payable dest = payable(address(uint160(uint256(destinationAddress))));\n        (bool ok, ) = dest.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/","title":"SCWE-097: Missing Explicit Function Visibility","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/#relationships","title":"Relationships","text":"<ul> <li>CWE-284: Improper Access Control https://cwe.mitre.org/data/definitions/284.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/#description","title":"Description","text":"<p>When a function\u2019s visibility is omitted in Solidity, it defaults to <code>public</code>, allowing any caller to invoke logic that may have been intended to be internal or private. This expands the attack surface, enabling unauthorized state changes, fund movements, or reentrancy entry points.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/#remediation","title":"Remediation","text":"<ul> <li>Explicitly declare visibility (<code>private</code>, <code>internal</code>, <code>public</code>, <code>external</code>) on every function.</li> <li>Use linters/static analysis to enforce visibility declarations.</li> <li>Restrict privileged logic with proper access modifiers and role checks.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vault {\n    uint256 public balance;\n\n    function withdraw(uint256 amount) { // defaults to public\n        balance -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-097/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vault {\n    uint256 public balance;\n\n    function withdraw(uint256 amount) external {\n        // add proper access control or business checks here\n        balance -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/","title":"SCWE-120: Missing Return Data Length Validation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/#relationships","title":"Relationships","text":"<ul> <li>CWE-697: Incorrect Comparison https://cwe.mitre.org/data/definitions/697.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/#description","title":"Description","text":"<p>Low-level calls that decode return values without checking <code>returndatasize</code> can read zeroed or truncated data. Attackers can craft contracts that return short payloads so callers mis-interpret success flags, prices, or balances.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/#remediation","title":"Remediation","text":"<ul> <li>Verify <code>returndatasize</code> matches expected length before decoding.</li> <li>Prefer high-level interfaces that perform ABI decoding checks.</li> <li>Revert on unexpected return sizes and log anomalies.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\n(bool ok, bytes memory data) = token.staticcall(abi.encodeWithSignature(\"balanceOf(address)\", user));\nuint256 bal = abi.decode(data, (uint256)); // assumes length &gt;= 32\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-120/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\n(bool ok, bytes memory data) = token.staticcall(abi.encodeWithSignature(\"balanceOf(address)\", user));\nrequire(ok &amp;&amp; data.length == 32, \"bad returndata\");\nuint256 bal = abi.decode(data, (uint256));\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/","title":"SCWE-121: Swallowed Revert Reasons","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/#relationships","title":"Relationships","text":"<ul> <li>CWE-388: Error Handling https://cwe.mitre.org/data/definitions/388.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/#description","title":"Description","text":"<p>Ignoring revert data (e.g., using <code>require(ok)</code> without bubbling reason) hides the root cause of failures. Protocols may proceed under incorrect assumptions, misprice risk, or block user funds without actionable errors.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/#remediation","title":"Remediation","text":"<ul> <li>Bubble revert reasons from external calls (<code>(bool ok, bytes memory data)</code>, then <code>assembly { revert(add(data,32), mload(data)) }</code> when <code>!ok</code>).</li> <li>Standardize error handling with custom errors and propagate upstream.</li> <li>Emit diagnostics when external calls fail to aid monitoring.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\n(bool ok, ) = target.call(payload);\nrequire(ok, \"call failed\"); // hides real reason\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-121/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\n(bool ok, bytes memory data) = target.call(payload);\nif (!ok) {\n    assembly {\n        revert(add(data, 32), mload(data))\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/","title":"SCWE-122: Calldata Length Not Validated Before Decode","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/#description","title":"Description","text":"<p>Functions that <code>abi.decode</code> calldata without first checking expected length can revert unpredictably or read malformed inputs. Attackers can craft short calldata to trigger reverts that lock functionality or bypass logic that runs before decode.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/#remediation","title":"Remediation","text":"<ul> <li>Validate <code>msg.data.length</code> against expected sizes (including selector).</li> <li>Prefer Solidity typed arguments but still guard against undersized calldata on low-level entrypoints.</li> <li>Reject unexpected trailing data when strict parsing is required.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\nfunction execute(bytes calldata data) external {\n    (address to, uint256 amount) = abi.decode(data, (address, uint256));\n    // ...\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-122/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\nfunction execute(bytes calldata data) external {\n    require(data.length == 64, \"bad length\"); // selector handled elsewhere\n    (address to, uint256 amount) = abi.decode(data, (address, uint256));\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/","title":"SCWE-123: Corrupt Free Memory Pointer in Assembly","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/#relationships","title":"Relationships","text":"<ul> <li>CWE-693: Protection Mechanism Failure https://cwe.mitre.org/data/definitions/693.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/#description","title":"Description","text":"<p>Inline assembly that writes to memory without preserving the Solidity free-memory pointer (at <code>0x40</code>) can corrupt ABI encoding for later calls or returns. Downstream decodes may misread buffers, leading to unexpected reverts or data leaks.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/#remediation","title":"Remediation","text":"<ul> <li>Save and restore the free-memory pointer when using custom memory writes.</li> <li>Prefer Solidity primitives unless assembly is necessary; encapsulate unsafe sections.</li> <li>Use formalized patterns for encoding/decoding (e.g., <code>abi.encode</code>) to avoid manual pointer math.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\nassembly {\n    mstore(0x40, add(0x40, 0x20)) // advances but later writes may clobber\n    mstore(0x00, value)\n}\n// subsequent abi.encode may read corrupted area\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-123/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\nassembly {\n    let memPtr := mload(0x40)\n    mstore(memPtr, value)\n    mstore(0x40, add(memPtr, 0x20))\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/","title":"SCWE-124: Inconsistent Rounding Direction in Financial Math","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/#description","title":"Description","text":"<p>Using mixed rounding strategies (floor vs. ceil vs. truncation) across mint/burn/withdraw logic causes value drift. Attackers can cycle operations to accumulate dust gains or trigger unfair liquidations due to asymmetry.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/#remediation","title":"Remediation","text":"<ul> <li>Define and document a single rounding direction per invariant (e.g., always round in favor of the protocol or user).</li> <li>Centralize math helpers and reuse them across all financial paths.</li> <li>Add property-based tests to ensure invariant preservation under rounding.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\nshares = amount * totalShares / totalAssets;      // truncates\nassets = shares * totalAssets / totalShares + 1;  // rounds up\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-124/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\n// consistently round down (or up) and state it explicitly\nshares = amount * totalShares / totalAssets;\nassets = shares * totalAssets / totalShares;\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/","title":"SCWE-137: Read-Only Reentrancy via View Function State Staleness","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/#relationships","title":"Relationships","text":"<ul> <li>CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition https://cwe.mitre.org/data/definitions/367.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/#description","title":"Description","text":"<p>Read-only reentrancy occurs when a <code>view</code> or <code>pure</code> function is called during an external callback (e.g., from a lending protocol reading collateral, or an integrator querying state). The view function returns stale state because the contract's effects have not yet been applied\u2014the callback happens mid-transaction, before state updates complete. External protocols that rely on this state for critical decisions (e.g., liquidations, pricing, health checks) can be exploited to drain funds or bypass invariants.</p> <p>This is distinct from classic reentrancy (SCWE-046): no state-modifying function is reentered, but the read of inconsistent state by external callers during a callback causes the vulnerability.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/#remediation","title":"Remediation","text":"<ul> <li>Apply <code>nonReentrant</code> guards to functions that make external calls, even if the caller only reads state\u2014external protocols may call back into view functions.</li> <li>Use a \"read-your-writes\" pattern: ensure view functions reflect in-flight state or document that they are unsafe during callbacks.</li> <li>Integrators should not rely on view functions of contracts that perform external calls without reentrancy guards.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract LendingPool {\n    mapping(address =&gt; uint256) public balances;\n    mapping(address =&gt; uint256) public borrowed;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient\");\n        balances[msg.sender] -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    function getHealthFactor(address user) external view returns (uint256) {\n        return (balances[user] * 1e18) / (borrowed[user] + 1);\n    }\n}\n</code></pre> Why vulnerable: During <code>withdraw</code>, the recipient's callback can invoke <code>getHealthFactor(user)</code> (e.g., from an integrator or liquidation bot). The victim's state may be mid-update or the integrator may rely on cached/stale values from the victim or dependent contracts. External protocols making decisions based on such reads can allow unhealthy borrows or incorrect liquidations.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-137/#fixed","title":"Fixed","text":"<p><pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract LendingPool is ReentrancyGuard {\n    mapping(address =&gt; uint256) public balances;\n    mapping(address =&gt; uint256) public borrowed;\n\n    function withdraw(uint256 amount) external nonReentrant {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient\");\n        balances[msg.sender] -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Fix: <code>nonReentrant</code> prevents external callbacks from reentering or being used while state is mid-update, so view functions cannot be called in an inconsistent state during the callback.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/","title":"SCWE-141: Lack of Deadline Validation in Time-Sensitive External Calls","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/#description","title":"Description","text":"<p>Time-sensitive external calls (e.g., DEX swaps, limit orders) that use only <code>block.timestamp</code> as a deadline\u2014or no user-supplied deadline\u2014can be front-run or executed at unfavorable times. A user signs a transaction expecting execution within a short window, but miners/validators can delay inclusion. Without a <code>deadline</code> parameter, the transaction may execute when prices have moved adversely. SCWE-090 covers slippage; this weakness addresses the absence of explicit deadline validation.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/#remediation","title":"Remediation","text":"<ul> <li>Accept a <code>deadline</code> parameter from users and enforce <code>require(block.timestamp &lt;= deadline, \"Expired\")</code> before executing time-sensitive logic.</li> <li>Never rely solely on <code>block.timestamp</code> for user-intended time bounds without a user-supplied deadline.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface IRouter {\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory);\n}\n\ncontract Swapper {\n    IRouter public router;\n\n    function swap(address[] calldata path, uint256 amountIn, uint256 minOut) external {\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            msg.sender,\n            block.timestamp  // No user deadline: tx can be delayed and executed at bad time\n        );\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-141/#fixed","title":"Fixed","text":"<pre><code>function swap(address[] calldata path, uint256 amountIn, uint256 minOut, uint256 deadline) external {\n    require(block.timestamp &lt;= deadline, \"Expired\");\n    router.swapExactTokensForTokens(amountIn, minOut, path, msg.sender, deadline);\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/","title":"SCWE-143: Critical Address Parameters Not Validated for Zero Address","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/#description","title":"Description","text":"<p>Critical address parameters (owner, oracle, fee recipient, token address) that are not validated for <code>address(0)</code> can brick the contract or cause funds to be sent to the burn address. Assigning <code>address(0)</code> as owner prevents any owner-only actions; using it as a recipient loses funds permanently. SCWE-091 covers zero value in token transfers; this weakness addresses zero address.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/#remediation","title":"Remediation","text":"<ul> <li>Validate <code>require(addr != address(0), \"Zero address\")</code> for all critical address parameters in constructors and setters.</li> <li>Use custom errors for gas efficiency where appropriate.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vault {\n    address public owner;\n    address public feeRecipient;\n\n    constructor(address _owner, address _feeRecipient) {\n        owner = _owner;           // No check: address(0) bricks contract\n        feeRecipient = _feeRecipient;  // No check: fees sent to burn address\n    }\n\n    function collectFees() external {\n        uint256 fees = address(this).balance;\n        (bool ok, ) = feeRecipient.call{value: fees}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-143/#fixed","title":"Fixed","text":"<pre><code>constructor(address _owner, address _feeRecipient) {\n    require(_owner != address(0), \"Invalid owner\");\n    require(_feeRecipient != address(0), \"Invalid fee recipient\");\n    owner = _owner;\n    feeRecipient = _feeRecipient;\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/","title":"SCWE-144: Bypassable Contract Existence Check via extcodesize","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/#relationships","title":"Relationships","text":"<ul> <li>CWE-697: Incorrect Comparison https://cwe.mitre.org/data/definitions/697.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/#description","title":"Description","text":"<p>Using <code>extcodesize(addr) &gt; 0</code> to detect whether an address is a contract fails during construction. When code runs inside a constructor, <code>extcodesize(address(this))</code> returns 0 because the contract's code is not yet deployed. An attacker can deploy a contract whose constructor calls the victim\u2014the victim sees <code>extcodesize(caller) == 0</code> and treats the caller as an EOA, bypassing contract-specific restrictions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/#remediation","title":"Remediation","text":"<ul> <li>Do not rely on <code>extcodesize</code> to distinguish EOAs from contracts.</li> <li>If contract-only or EOA-only logic is required, use a different mechanism (e.g., trusted registry, explicit opt-in) or accept that constructor calls cannot be distinguished.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TokenGating {\n    mapping(address =&gt; bool) public allowed;\n\n    function claim() external {\n        require(extcodesize(msg.sender) == 0, \"Contracts not allowed\");\n        allowed[msg.sender] = true;\n    }\n\n    function extcodesize(address account) internal view returns (uint256 size) {\n        assembly { size := extcodesize(account) }\n    }\n}\n</code></pre> Why vulnerable: An attacker deploys <code>Attacker</code> whose constructor calls <code>claim()</code>. During the constructor, <code>extcodesize(Attacker) == 0</code>, so the check passes and the contract receives the claim.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-144/#fixed","title":"Fixed","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TokenGating {\n    mapping(address =&gt; bool) public allowed;\n    mapping(address =&gt; bool) public claimed;\n\n    function claim() external {\n        require(allowed[msg.sender], \"Not allowed\");\n        require(!claimed[msg.sender], \"Already claimed\");\n        claimed[msg.sender] = true;\n    }\n}\n</code></pre> Fix: Use an allowlist instead of <code>extcodesize</code>. Access control is based on explicit registration, not EOA vs contract detection.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/","title":"SCWE-146: Improper Use of try/catch Leading to Silent Failures","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/#relationships","title":"Relationships","text":"<ul> <li>CWE-390: Detection of Error Condition Without Action https://cwe.mitre.org/data/definitions/390.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/#description","title":"Description","text":"<p>Solidity 0.6+ <code>try/catch</code> allows catching reverts from external calls. If the catch block does not properly handle the failure\u2014e.g., proceeds without reverting, leaves state inconsistent, or swallows the error without logging\u2014the contract can continue execution under incorrect assumptions. Silent failures can lead to fund loss, corrupted state, or exploitable inconsistencies.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/#remediation","title":"Remediation","text":"<ul> <li>In catch blocks, either revert with a clear message or update state to reflect the failure (e.g., mark operation as failed, emit event).</li> <li>Avoid proceeding with critical logic when the external call failed unless the failure is explicitly handled and documented.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Aggregator {\n    function swap(address router, bytes calldata data) external {\n        try IRouter(router).swap(data) returns (uint256 amountOut) {\n            transferToUser(msg.sender, amountOut);\n        } catch {\n            // Silent: user gets nothing but tx succeeds; state may be inconsistent\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-146/#fixed","title":"Fixed","text":"<p><pre><code>function swap(address router, bytes calldata data) external {\n    try IRouter(router).swap(data) returns (uint256 amountOut) {\n        transferToUser(msg.sender, amountOut);\n    } catch {\n        revert(\"Swap failed\");\n    }\n}\n</code></pre> Fix: Revert in the catch block so the transaction fails. Avoid <code>catch (bytes memory reason)</code> with string concatenation\u2014<code>reason</code> may be a custom error selector, not a string.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/","title":"SCWE-152: Misuse of Custom Errors Leading to Information Leakage or Wrong Revert Behavior","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/#relationships","title":"Relationships","text":"<ul> <li>CWE-209: Generation of Error Message Containing Sensitive Information https://cwe.mitre.org/data/definitions/209.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/#description","title":"Description","text":"<p>Custom errors (Solidity 0.8.4+) save gas but can expose internal state if parameters include sensitive data (e.g., balances, private keys, internal addresses). Using the wrong error in a revert can also mislead integrators or hide the actual failure reason. Custom errors are part of the revert payload and can be decoded off-chain.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/#remediation","title":"Remediation","text":"<ul> <li>Avoid including sensitive data in custom error parameters.</li> <li>Use generic error messages for external-facing reverts when the internal reason is confidential.</li> <li>Ensure error selection matches the actual failure condition.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vault {\n    error InsufficientBalance(uint256 requested, uint256 available);\n\n    function withdraw(uint256 amount) external {\n        uint256 balance = balances[msg.sender];\n        if (amount &gt; balance) {\n            revert InsufficientBalance(amount, balance);  // Exposes user balance\n        }\n        balances[msg.sender] -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-152/#fixed","title":"Fixed","text":"<pre><code>error InsufficientBalance();\n\nfunction withdraw(uint256 amount) external {\n    if (amount &gt; balances[msg.sender]) {\n        revert InsufficientBalance();\n    }\n    // ...\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/","title":"SCWE-154: Calldata Decode Without Length Check","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/#description","title":"Description","text":"<p>Decoding calldata or bytes with <code>abi.decode</code> without first verifying the input length can cause unexpected reverts. In modern Solidity (0.4.22+), <code>abi.decode</code> with data shorter than expected reverts due to bounds checking; malformed or incorrectly typed data can produce wrong values. SCWE-122 covers calldata length validation; this weakness addresses the broader pattern of decoding without length checks.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/#remediation","title":"Remediation","text":"<ul> <li>Validate <code>data.length &gt;= expectedLength</code> before <code>abi.decode</code>.</li> <li>Use <code>abi.decode</code> with the correct type and ensure the encoded data matches.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Decoder {\n    function decodeAndUse(bytes calldata data) external {\n        (address recipient, uint256 amount) = abi.decode(data, (address, uint256));\n        // If data is too short, decode reverts; malformed data can produce wrong values\n        transfer(recipient, amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-154/#fixed","title":"Fixed","text":"<pre><code>function decodeAndUse(bytes calldata data) external {\n    require(data.length &gt;= 32 + 32, \"Invalid data length\");\n    (address recipient, uint256 amount) = abi.decode(data, (address, uint256));\n    transfer(recipient, amount);\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/","title":"SCWE-021: Unsecured Data Transmission","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#relationships","title":"Relationships","text":"<ul> <li>CWE-319: Cleartext Transmission of Sensitive Information CWE-319 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#description","title":"Description","text":"<p>Unsecured data transmission refers to the transmission of sensitive information, such as private keys or user data, without encryption. This can lead to: - Interception of sensitive data by malicious actors. - Exploitation of vulnerabilities in the contract. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#remediation","title":"Remediation","text":"<ul> <li>Use encryption: Encrypt sensitive data before transmission.</li> <li>Leverage secure protocols: Use HTTPS or other secure communication protocols.</li> <li>Avoid transmitting sensitive data: Minimize the transmission of sensitive data whenever possible.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#examples","title":"Examples","text":"<ul> <li> <p>Unsecured Data Transmission <pre><code>pragma solidity ^0.8.0;\n\ncontract UnsecuredData {\n    function transmitData(bytes memory data) public {\n        // Transmit data without encryption\n    }\n}\n</code></pre></p> </li> <li> <p>Secured Data Transmission <pre><code>pragma solidity ^0.8.0;\n\ncontract SecuredData {\n    function transmitData(bytes memory encryptedData) public {\n        // Transmit encrypted data\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/","title":"SCWE-022: Message Replay Vulnerabilities","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#relationships","title":"Relationships","text":"<ul> <li>CWE-294: Authentication Bypass by Capture-replay CWE-294 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#description","title":"Description","text":"<p>Message replay vulnerabilities occur when an attacker can reuse a valid message or transaction to perform unauthorized actions. This can lead to: - Unauthorized access to sensitive functions. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#remediation","title":"Remediation","text":"<ul> <li>Use nonces: Include a unique nonce in each message to prevent reuse.</li> <li>Validate timestamps: Ensure messages are only valid for a limited time.</li> <li>Implement replay protection: Use established libraries or mechanisms to prevent replay attacks.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable to Replay Attacks <pre><code>pragma solidity ^0.8.0;\n\ncontract ReplayVulnerable {\n    function processMessage(bytes memory message) public {\n        // Process message without replay protection\n    }\n}\n</code></pre></p> </li> <li> <p>Protected Against Replay Attacks <pre><code>pragma solidity ^0.8.0;\n\ncontract ReplayProtected {\n    mapping(bytes32 =&gt; bool) public usedMessages;\n\n    function processMessage(bytes memory message, uint nonce, uint chainId) public {\n        bytes32 messageHash = keccak256(abi.encodePacked(message, nonce, chainId));\n        require(!usedMessages[messageHash], \"Message already used\");\n        usedMessages[messageHash] = true;\n        // Process message\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/","title":"SCWE-023: Lack of Communication Authenticity","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#description","title":"Description","text":"<p>Lack of communication authenticity refers to the failure to verify the authenticity of messages or transactions. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#remediation","title":"Remediation","text":"<ul> <li>Use signatures: Require signed messages for critical actions.</li> <li>Validate inputs: Ensure all messages are properly validated before processing.</li> <li>Implement secure communication: Use secure protocols and libraries for communication.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#examples","title":"Examples","text":"<ul> <li> <p>Lack of Authenticity <pre><code>pragma solidity ^0.8.0;\n\ncontract NoAuthenticity {\n    function processMessage(bytes memory message) public {\n        // Process message without authenticity check\n    }\n}\n</code></pre></p> </li> <li> <p>Authentic Communication <pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract AuthenticCommunication {\n    using ECDSA for bytes32;\n\n    function processMessage(bytes memory message, bytes memory signature) public {\n        bytes32 messageHash = keccak256(message);\n        address signer = messageHash.recover(signature);\n        require(signer == msg.sender, \"Invalid signature\");\n        // Process message\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/","title":"SCWE-035: Insecure Delegatecall Usage","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#relationships","title":"Relationships","text":"<ul> <li>CWE-250: Execution with Unnecessary Privileges CWE-250 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#description","title":"Description","text":"<p>Insecure delegatecall usage refers to vulnerabilities that arise when using <code>delegatecall</code> to execute code from another contract. This can lead to: - Unauthorized access to sensitive functions. - Exploitation of vulnerabilities in the called contract. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#remediation","title":"Remediation","text":"<ul> <li>Validate targets: Ensure the target contract is trusted and secure.</li> <li>Restrict permissions: Restrict <code>delegatecall</code> usage to trusted addresses.</li> <li>Test thoroughly: Conduct extensive testing to ensure <code>delegatecall</code> is used securely.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#examples","title":"Examples","text":"<ul> <li>Insecure Delegatecall Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureDelegatecall {\n    function executeDelegatecall(address target, bytes memory data) public {\n        (bool success, ) = target.delegatecall(data); // \u274c No validation, attacker-controlled contract can be used\n        require(success, \"Delegatecall failed\");\n    }\n}\n</code></pre></li> <li>Anyone can call <code>executeDelegatecall()</code> with a malicious contract, which will execute arbitrary code within the caller\u2019s context.</li> <li> <p>Can lead to theft of funds, privilege escalation, or state corruption.</p> </li> <li> <p>Secure Delegatecall Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureDelegatecall {\n    address public owner;\n    address public trustedTarget;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    constructor(address _trustedTarget) {\n        owner = msg.sender;\n        trustedTarget = _trustedTarget;\n    }\n\n    function updateTrustedTarget(address _newTarget) public onlyOwner {\n        require(isTrusted(_newTarget), \"Untrusted target\");\n        trustedTarget = _newTarget;\n    }\n\n    function executeDelegatecall(bytes memory data) public onlyOwner {\n        require(trustedTarget != address(0), \"Invalid target\");\n        (bool success, ) = trustedTarget.delegatecall(data);\n        require(success, \"Delegatecall failed\");\n    }\n\n    function isTrusted(address _target) internal pure returns (bool) {\n        // Implement further checks if needed\n        return _target != address(0);\n    }\n}\n</code></pre></p> </li> </ul> <p>Fixes: - Only the contract owner can update trustedTarget. - Validation of trusted target before executing delegatecall. - Prevents arbitrary execution by restricting calls to trustedTarget.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/","title":"SCWE-042: Insecure Use of External Calls","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#relationships","title":"Relationships","text":"<ul> <li>CWE-829: Inclusion of Functionality from Untrusted Control Sphere CWE-829 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#description","title":"Description","text":"<p>Insecure use of external calls refers to vulnerabilities that arise when calling external contracts without proper validation or safeguards. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of vulnerabilities in the called contract.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#remediation","title":"Remediation","text":"<ul> <li>Validate targets: Ensure the target contract is trusted and secure.</li> <li>Use secure libraries: Leverage well-audited libraries for external calls.</li> <li>Test thoroughly: Conduct extensive testing to ensure external calls are secure.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#examples","title":"Examples","text":"<ul> <li> <p>Insecure External Call <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureExternalCall {\n    function callExternal(address target, bytes memory data) public {\n        (bool success, ) = target.call(data); // No validation\n        require(success, \"Call failed\");\n    }\n}\n</code></pre></p> </li> <li> <p>Secure External Call <pre><code>pragma solidity ^0.8.0;\n\ninterface ITrustedContract {\n    function executeAction(uint256 param) external;\n}\n\ncontract SecureExternalCall {\n    address public immutable trustedTarget;\n    address public owner;\n\n    constructor(address _trustedTarget) {\n        trustedTarget = _trustedTarget;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized\");\n        _;\n    }\n\n    function callExternal(uint256 param) public onlyOwner {\n        ITrustedContract(trustedTarget).executeAction(param);\n    }\n}\n</code></pre> Why is this secure?</p> </li> <li>No arbitrary data input\u2014Only predefined <code>function executeAction(uint256)</code> can be called.</li> <li>Access control added\u2014Only the owner can execute external calls.</li> <li>Interface-based call\u2014Avoids raw <code>.call()</code>, reducing attack vectors.</li> <li>Immutable trusted address\u2014Prevents runtime modifications to the target contract.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/","title":"SCWE-063: Insecure Event Emission","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#relationships","title":"Relationships","text":"<ul> <li>CWE-778: Insufficient Logging https://cwe.mitre.org/data/definitions/778.html </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#description","title":"Description","text":"<p>Events in Solidity play a critical role in logging contract activity and ensuring transparency. Improper event handling can lead to security risks such as:  </p> <ol> <li>Missing critical event emissions \u2013 Making external monitoring difficult.  </li> <li>Emitting misleading or incorrect data \u2013 Resulting in users or external systems making incorrect assumptions.  </li> <li>Logging sensitive information \u2013 Leaking private or security-sensitive data.  </li> </ol> <p>Failure to handle events properly can affect contract auditing, debugging, and external monitoring tools, making it difficult to detect anomalies or track contract states correctly.  </p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#remediation","title":"Remediation","text":"<ul> <li>Emit events for all critical state changes, such as token transfers, ownership changes, or contract upgrades.  </li> <li>Ensure that the data logged in events accurately represents the actual contract state.  </li> <li>Avoid logging sensitive information such as private keys, hashes used for authentication, or confidential business logic.  </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint) public balances;\n    event Withdraw(address indexed user, uint amount);\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient funds\");\n        payable(msg.sender).transfer(_amount);\n        balances[msg.sender] -= _amount;\n\n        // Incorrect event emission: Logs the requested amount instead of the actual withdrawn amount\n        emit Withdraw(msg.sender, _amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#issues-in-the-vulnerable-code","title":"Issues in the Vulnerable Code","text":"<ul> <li>The Withdraw event logs <code>_amount</code>, which is the requested <code>withdrawal</code> amount, but if the transfer fails (due to gas limits, reentrancy, or an external issue), the event still logs it as if the withdrawal happened.</li> <li>If an attacker exploits a discrepancy between event logs and actual state changes, they could mislead users, external indexers, or off-chain services.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint) public balances;\n    event Withdraw(address indexed user, uint actualAmount);\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient funds\");\n\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        balances[msg.sender] -= _amount;\n\n        // Logs the amount actually withdrawn (equals _amount on success)\n        emit Withdraw(msg.sender, _amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#fixes-in-the-secure-code","title":"Fixes in the Secure Code","text":"<ul> <li>Uses <code>call{value: _amount}(\"\")</code> to send funds safely and ensures success before updating the balance.</li> <li>Updates state and emits the event only after a successful transfer; logs <code>_amount</code> (the actual withdrawn amount on success).</li> <li>Prevents false event emissions by reverting on transfer failure before any state change or event.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/","title":"SCWE-103: ERC20 Approval Double-Spend (Allowance Race)","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/#relationships","title":"Relationships","text":"<ul> <li>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization (Race Condition) https://cwe.mitre.org/data/definitions/362.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/#description","title":"Description","text":"<p>Changing an ERC20 allowance from value <code>X</code> to <code>Y</code> with a single <code>approve</code> call allows a spender to front-run and spend <code>X</code> before the change, then spend <code>Y</code> after, effectively double-spending. Integrations that do not use <code>increaseAllowance</code>/<code>decreaseAllowance</code> are exposed.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/#remediation","title":"Remediation","text":"<ul> <li>Follow the allowance reset pattern: set allowance to <code>0</code>, then set the new value.</li> <li>Prefer <code>increaseAllowance</code>/<code>decreaseAllowance</code> or EIP-2612 <code>permit</code> with nonces.</li> <li>For critical flows, pull tokens via <code>transferFrom</code> after verifying allowance updates.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\ninterface IERC20 { function approve(address,uint256) external returns (bool); }\n\ncontract DApp {\n    IERC20 public token;\n\n    function changeSpender(address spender, uint256 newAmount) external {\n        token.approve(spender, newAmount); // can be front-run\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-103/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract DApp {\n    using SafeERC20 for IERC20;\n    IERC20 public token;\n\n    function changeSpender(address spender, uint256 newAmount) external {\n        token.safeApprove(spender, 0);      // reset first; SafeERC20 handles non-standard tokens (e.g. USDT)\n        token.safeApprove(spender, newAmount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/","title":"SCWE-104: Unprotected ERC777 Token Hooks","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/#relationships","title":"Relationships","text":"<ul> <li>CWE-841: Improper Enforcement of Behavioral Workflow https://cwe.mitre.org/data/definitions/841.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/#description","title":"Description","text":"<p>ERC777 tokens trigger <code>tokensReceived</code> hooks on recipients. Contracts that accept tokens without reentrancy protection or without blocking ERC777 hooks can be reentered during token transfers, enabling double-withdrawals or bypassing invariants.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/#remediation","title":"Remediation","text":"<ul> <li>Add <code>nonReentrant</code> guards around token transfer handlers and withdrawals.</li> <li>Block unexpected token types or disable ERC777 acceptance by rejecting the ERC1820 interface.</li> <li>Use pull-based withdrawals and avoid performing sensitive logic inside token receive hooks.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\ninterface IERC777 { function send(address,uint256,bytes calldata) external; }\n\ncontract Rewards {\n    uint256 public totalPaid;\n\n    function claim(address token, uint256 amount) external {\n        IERC777(token).send(msg.sender, amount, \"\"); // ERC777 hook can reenter\n        totalPaid += amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-104/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; // OZ 5.x: utils/ReentrancyGuard.sol\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract Rewards is ReentrancyGuard {\n    mapping(address =&gt; bool) public allowedTokens; // only non-ERC777 tokens\n    uint256 public totalPaid;\n\n    function claim(address token, uint256 amount) external nonReentrant {\n        require(allowedTokens[token], \"token not allowed\"); // block ERC777\n        totalPaid += amount;\n        IERC20(token).transfer(msg.sender, amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/","title":"SCWE-107: Missing Chain ID Validation in Cross-Chain Messages","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity https://cwe.mitre.org/data/definitions/345.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/#description","title":"Description","text":"<p>Cross-chain handlers that accept payloads without checking the source <code>chainId</code> or endpoint domain allow replay of messages from other networks or forks. Attackers can re-trigger transfers, minting, or governance actions on unintended chains.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/#remediation","title":"Remediation","text":"<ul> <li>Bind every inbound message to an expected source chain/domain and trusted sender.</li> <li>Include <code>chainId</code>/domain separators in signed payloads and verify them before execution.</li> <li>Maintain replay protection (nonces) per (sourceChain, sourceSender).</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract BridgeReceiver {\n    function receiveMessage(bytes calldata data) external {\n        _execute(data); // no chainId/source validation\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-107/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract BridgeReceiver {\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public nonce; // per (chainId, sender)\n    address public trustedSender;\n    uint256 public trustedChainId;\n\n    function receiveMessage(uint256 srcChainId, address src, uint256 n, bytes calldata data) external {\n        require(srcChainId == trustedChainId &amp;&amp; src == trustedSender, \"unauthorized source\");\n        require(n == nonce[srcChainId][src]++, \"replay\");\n        _execute(data);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/","title":"SCWE-108: Unverified Cross-Chain Message Proofs","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity https://cwe.mitre.org/data/definitions/345.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/#description","title":"Description","text":"<p>Relayers may deliver fabricated payloads if the destination contract does not validate Merkle proofs, light-client headers, or signatures that attest to the message on the source chain. Forged messages can mint wrapped assets or execute arbitrary calls.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/#remediation","title":"Remediation","text":"<ul> <li>Verify message inclusion against a trusted root (Merkle/Patricia proof) or light-client header.</li> <li>Validate signatures from authorized validators and enforce quorum thresholds.</li> <li>Reject messages that fail proof verification or originate from unrecognized relayers.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Inbox {\n    function deliver(bytes calldata payload) external {\n        _process(payload); // assumes relayer is honest\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-108/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Inbox {\n    address[] public validators;\n    uint256 public constant QUORUM = 2;\n\n    function deliver(bytes calldata payload, bytes[] calldata sigs) external {\n        require(_verifyQuorum(payload, sigs) &gt;= QUORUM, \"invalid proof\");\n        _process(payload);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-3"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/","title":"SCWE-128: Insecure Multicall Context Forwarding","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/#relationships","title":"Relationships","text":"<ul> <li>CWE-841: Improper Enforcement of Behavioral Workflow https://cwe.mitre.org/data/definitions/841.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/#description","title":"Description","text":"<p>Multicall-style aggregators that forward calls without guarding against reentrancy or context changes let attackers reorder actions within one tx (e.g., deposit then withdraw) or impersonate <code>msg.sender</code> when inner calls use <code>tx.origin</code> or cached sender state.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/#remediation","title":"Remediation","text":"<ul> <li>Apply reentrancy guards around multicall entrypoints.</li> <li>Avoid caching <code>msg.sender</code> across calls; pass explicit sender/context to internal functions.</li> <li>Restrict callable selectors/targets or enforce allowlists.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/#vulnerable","title":"Vulnerable","text":"<pre><code>function multicall(bytes[] calldata data) external {\n    for (uint i; i &lt; data.length; i++) {\n        (bool ok, ) = address(this).delegatecall(data[i]);\n        require(ok, \"fail\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-128/#fixed","title":"Fixed","text":"<pre><code>function multicall(bytes[] calldata data) external nonReentrant {\n    for (uint i; i &lt; data.length; i++) {\n        _dispatch(msg.sender, data[i]); // explicit context, no delegatecall loops\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/","title":"SCWE-134: Low-Level Call to Non-Contract Address","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/#relationships","title":"Relationships","text":"<ul> <li>CWE-252: Unchecked Return Value https://cwe.mitre.org/data/definitions/252.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/#description","title":"Description","text":"<p>When using low-level <code>call</code>, <code>staticcall</code>, or <code>delegatecall</code> to a user-supplied or dynamic address, the target may be an EOA (externally owned account) with no contract code. In that case, the call returns <code>success = true</code> and empty return data, but no code executes. Contracts that assume the target performed logic (e.g., a callback, validation, or state change) can proceed under false assumptions, leading to bypassed checks, unexecuted logic, or incorrect accounting.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/#remediation","title":"Remediation","text":"<ul> <li>Verify that the target address contains code using <code>extcodesize</code> (or <code>address.code.length</code> in Solidity 0.8.12+) before low-level calls.</li> <li>Use allowlists for callable targets instead of accepting arbitrary addresses.</li> <li>Prefer high-level interface calls when the target is known to be a contract.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract PluginRegistry {\n    function executeViaPlugin(address plugin, bytes calldata data) external {\n        (bool ok, ) = plugin.call(data);\n        require(ok, \"plugin failed\");\n        // If plugin is an EOA, call \"succeeds\" but no code ran \u2014 logic may be bypassed\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-134/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract PluginRegistry {\n    function executeViaPlugin(address plugin, bytes calldata data) external {\n        require(plugin.code.length &gt; 0, \"target has no code\");\n        (bool ok, ) = plugin.call(data);\n        require(ok, \"plugin failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/","title":"SCWE-138: Reentrancy via ERC721/ERC1155 Safe Transfer Callbacks","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/#relationships","title":"Relationships","text":"<ul> <li>CWE-841: Improper Enforcement of Behavioral Workflow https://cwe.mitre.org/data/definitions/841.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/#description","title":"Description","text":"<p>ERC721 <code>safeTransferFrom</code> and ERC1155 <code>safeTransferFrom</code> invoke <code>onERC721Received</code> or <code>onERC1155Received</code> on the recipient contract. If the recipient is a contract that accepts NFTs and performs sensitive logic (e.g., withdrawals, state updates) inside these callbacks without reentrancy protection, an attacker can reenter the sender contract during the transfer and exploit stale state\u2014similar to ERC777 hooks (SCWE-104) but for NFTs.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/#remediation","title":"Remediation","text":"<ul> <li>Add <code>nonReentrant</code> guards around functions that perform NFT transfers and any logic that could be reentered via the receiver callback.</li> <li>Update state (e.g., balances, accounting) before calling <code>safeTransferFrom</code>.</li> <li>Consider using <code>transferFrom</code> instead of <code>safeTransferFrom</code> when the recipient is trusted, to avoid callbacks.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ninterface IERC721 {\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract NFTVault {\n    mapping(address =&gt; uint256) public deposits;\n    IERC721 public nft;\n\n    function deposit(uint256 tokenId) external {\n        nft.safeTransferFrom(msg.sender, address(this), tokenId);\n        deposits[msg.sender]++;\n    }\n\n    function withdraw(uint256 tokenId) external {\n        require(deposits[msg.sender] &gt; 0, \"No deposit\");\n        nft.safeTransferFrom(address(this), msg.sender, tokenId);  // Callback here\u2014attacker reenters\n        deposits[msg.sender]--;  // Too late: attacker already reentered and passed the check\n    }\n}\n</code></pre> Why vulnerable: During <code>withdraw</code>, <code>safeTransferFrom</code> calls <code>onERC721Received</code> on the recipient before the state update. A malicious contract can reenter <code>withdraw</code> in that callback, pass the <code>deposits[msg.sender] &gt; 0</code> check again, and withdraw a second NFT (double withdrawal).</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-138/#fixed","title":"Fixed","text":"<p><pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract NFTVault is ReentrancyGuard {\n    mapping(address =&gt; uint256) public deposits;\n    IERC721 public nft;\n\n    function withdraw(uint256 tokenId) external nonReentrant {\n        require(deposits[msg.sender] &gt; 0, \"No deposit\");\n        deposits[msg.sender]--;\n        nft.safeTransferFrom(address(this), msg.sender, tokenId);\n    }\n}\n</code></pre> Fix: <code>nonReentrant</code> blocks reentry through the ERC721 receiver callback.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/","title":"SCWE-149: Transfers to Addresses That Cannot Receive Funds","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/#relationships","title":"Relationships","text":"<ul> <li>CWE-755: Improper Handling of Exceptional Conditions https://cwe.mitre.org/data/definitions/755.html</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/#description","title":"Description","text":"<p>Sending ETH or tokens to addresses that cannot receive them (e.g., contracts with no <code>receive</code>/<code>fallback</code>, or that revert on receive) causes the transfer to fail. In push-based distributions (e.g., airdrops, reward payouts), if one recipient cannot receive, the entire transaction reverts\u2014leading to denial of service for all recipients. Pull-based patterns avoid this by letting users claim individually.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/#remediation","title":"Remediation","text":"<ul> <li>Prefer pull-based over push-based distributions.</li> <li>If push-based is required, use <code>try/catch</code> to skip failing recipients and track failures, or validate recipients (e.g., reject contracts that don't implement a receiver interface).</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract RewardDistributor {\n    function distribute(address[] calldata users, uint256[] calldata amounts) external {\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            (bool ok, ) = users[i].call{value: amounts[i]}(\"\");\n            require(ok, \"Transfer failed\");  // One failure reverts entire batch\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-149/#fixed-pull-based","title":"Fixed (Pull-based)","text":"<pre><code>mapping(address =&gt; uint256) public pendingRewards;\n\nfunction claim() external {\n    uint256 amount = pendingRewards[msg.sender];\n    require(amount &gt; 0, \"Nothing to claim\");\n    pendingRewards[msg.sender] = 0;\n    (bool ok, ) = msg.sender.call{value: amount}(\"\");\n    require(ok, \"Transfer failed\");\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/","title":"SCWE-057: Write to Arbitrary Storage Location","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#description","title":"Description","text":"<p>Writing to arbitrary storage locations can occur when a contract fails to properly validate inputs before interacting with storage variables. An attacker may exploit this vulnerability to overwrite sensitive storage slots, leading to unintended contract behavior, state manipulation, or loss of funds.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that all inputs to storage-related operations are properly validated. Avoid allowing external users to specify arbitrary storage locations. Use access control mechanisms to restrict who can modify sensitive state variables and ensure that only trusted users or contract functions can write to critical storage locations.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract ArbitraryStorageWrite {\n    uint256 public balance;\n\n    function setStorage(uint256 storageLocation, uint256 value) public {\n        assembly {\n            sstore(storageLocation, value)  // Writing to arbitrary storage location\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract SecureStorageWrite {\n    uint256 public balance;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setBalance(uint256 value) public onlyOwner {\n        balance = value;  // Only the owner can modify the balance\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/","title":"SCWE-083: Failure to Handle Edge Cases","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/754.html </li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#description","title":"Description","text":"<p>Failure to account for edge cases can result in unexpected behaviors, security vulnerabilities, and unintended contract failures. Edge cases are unusual but possible inputs or states that developers often overlook, leading to incorrect logic, reverts, or even exploits.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#common-scenarios-include","title":"Common scenarios include:","text":"<ul> <li>Arithmetic Issues (e.g., division by zero, integer overflow/underflow, precision loss).</li> <li>Boundary Conditions (e.g., handling empty arrays, minimum/maximum values).</li> <li>State-Dependent Bugs (e.g., failing to check for uninitialized variables, invalid state transitions).</li> <li>Gas-Related Failures (e.g., unbounded loops consuming excessive gas).</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#remediation","title":"Remediation","text":"<p>Ensure that all edge cases are properly considered and handled during the development of the contract. Utilize <code>require</code> and <code>assert</code> to ensure proper validation of inputs, outputs, and states. - Implement explicit validation for all possible edge cases. - Use Solidity's built-in safety features (e.g., SafeMath, Solidity 0.8 overflow checks). - Use require/assert statements to enforce input constraints and expected states. - Test contracts thoroughly, including stress tests, fuzzing, and invariant testing.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#vulnerable-contract-example-arithmetic-issue","title":"Vulnerable Contract Example-  (Arithmetic Issue)","text":"<pre><code>contract Example {\n    function divide(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {\n        return _numerator / _denominator; // Division by zero is not checked\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#fixed-contract-example","title":"Fixed Contract Example","text":"<ul> <li>Solution: Use <code>require</code> to check for division by zero. <pre><code>contract Example {\n    function divide(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {\n        require(_denominator != 0, \"Cannot divide by zero\");\n        return _numerator / _denominator;\n    }\n}\n</code></pre></li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#handling-empty-arrays","title":"Handling Empty Arrays","text":"<ul> <li>Issue: A function assumes that the array is never empty, leading to an out-of-bounds error.</li> </ul> <pre><code>contract Example {\n    uint256[] public data;\n\n    function getLast() public view returns (uint256) {\n        return data[data.length - 1]; // \u274c Reverts if array is empty\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#fixed-code","title":"Fixed Code:","text":"<ul> <li>Solution: Validate that the array is not empty before accessing elements. <pre><code>contract Example {\n    uint256[] public data;\n\n    function getLast() public view returns (uint256) {\n        require(data.length &gt; 0, \"Array is empty\");\n        return data[data.length - 1];\n    }\n}\n</code></pre></li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/","title":"SCWE-110: Fee-On-Transfer Token Misaccounting","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/#description","title":"Description","text":"<p>Assuming an ERC20 transfer moves the full requested amount fails with fee-on-transfer or deflationary tokens. Protocols that credit users for the requested amount instead of the received amount can be drained or mis-account balances.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/#remediation","title":"Remediation","text":"<ul> <li>Measure token balances before and after transfers to calculate the actual received amount.</li> <li>Maintain allowlists/blocks for incompatible tokens or handle fee-on-transfer explicitly.</li> <li>Validate that accounting uses the net amount when updating shares or debts.</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vault {\n    IERC20 public token;\n    mapping(address =&gt; uint256) public deposits;\n\n    function deposit(uint256 amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        deposits[msg.sender] += amount; // credits full amount even if fee applied\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-110/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Vault {\n    IERC20 public token;\n    mapping(address =&gt; uint256) public deposits;\n\n    function deposit(uint256 amount) external {\n        uint256 beforeBal = token.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), amount);\n        uint256 received = token.balanceOf(address(this)) - beforeBal;\n        deposits[msg.sender] += received; // credit net amount\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/","title":"SCWE-111: Rebase Token Balance Drift","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/#description","title":"Description","text":"<p>Rebasing tokens change user balances over time. Protocols that track deposited amounts as fixed units (instead of shares) can become insolvent or let users withdraw more than their fair share after positive or negative rebases.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/#remediation","title":"Remediation","text":"<ul> <li>Track user positions using share-based accounting that scales with total supply.</li> <li>Normalize balances on every interaction or use wrappers that expose a non-rebasing interface (e.g., wstETH).</li> <li>Validate integrations against tokens with elastic supply and document unsupported assets.</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Savings {\n    IERC20 public rebasingToken;\n    mapping(address =&gt; uint256) public deposits;\n\n    function deposit(uint256 amount) external {\n        rebasingToken.transferFrom(msg.sender, address(this), amount);\n        deposits[msg.sender] += amount; // assumes static balance\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-111/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Savings {\n    IERC20 public rebasingToken;\n    mapping(address =&gt; uint256) public shares;\n    uint256 public totalShares;\n\n    function deposit(uint256 amount) external {\n        uint256 supply = rebasingToken.totalSupply();\n        uint256 share = totalShares == 0 ? amount : amount * totalShares / supply;\n        shares[msg.sender] += share;\n        totalShares += share;\n        rebasingToken.transferFrom(msg.sender, address(this), amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/","title":"SCWE-135: ERC4626 Share Inflation via Donations","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/#description","title":"Description","text":"<p>ERC4626 vaults that do not guard against free-asset donations can skew <code>totalAssets</code> and share price. Attackers can donate assets to inflate share value and then mint shares cheaply before normalization, extracting value from existing holders.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/#remediation","title":"Remediation","text":"<ul> <li>Normalize share price on every deposit/mint using current <code>totalAssets</code>.</li> <li>Optionally block unsolicited donations by reverting on direct transfers or sweeping them into reserves before new share mints.</li> <li>Add tests for donation and price-per-share edge cases.</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/#vulnerable","title":"Vulnerable","text":"<pre><code>// totalAssets() uses balanceOf; donations inflate it and skew share price\nfunction mint(uint256 shares) external {\n    uint256 assets = previewMint(shares);\n    asset.transferFrom(msg.sender, address(this), assets);\n    _mint(msg.sender, shares);\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-COMP/SCWE-135/#fixed","title":"Fixed","text":"<pre><code>uint256 private _accountedAssets; // internal balance; excludes direct transfers\n\nfunction totalAssets() public view override returns (uint256) {\n    return _accountedAssets; // donations do not affect share price\n}\n\nfunction deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\n    uint256 before = asset.balanceOf(address(this));\n    shares = super.deposit(assets, receiver);\n    _accountedAssets += (asset.balanceOf(address(this)) - before);\n}\n\nfunction withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n    shares = super.withdraw(assets, receiver, owner);\n    _accountedAssets -= assets;\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/","title":"SCWE-025: Improper Cryptographic Key Management","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#relationships","title":"Relationships","text":"<ul> <li>CWE-310: Cryptographic Issues CWE-310 Link</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#description","title":"Description","text":"<p>Improper cryptographic key management refers to the failure to securely generate, store, or use cryptographic keys. This can lead to: - Unauthorized access to sensitive data. - Exploitation of the contract's logic. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#remediation","title":"Remediation","text":"<ul> <li>Use secure key management: Leverage secure key management systems or libraries.</li> <li>Avoid hardcoding keys: Never hardcode cryptographic keys in the contract.</li> <li>Regularly rotate keys: Periodically update cryptographic keys to reduce risks.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#examples","title":"Examples","text":"<ul> <li> <p>Improper Key Management <pre><code>pragma solidity ^0.8.0;\n\ncontract ImproperKeyManagement {\n    bytes32 private key = keccak256(\"insecure-key\"); // Hardcoded key\n}\n</code></pre></p> </li> <li> <p>Proper Key Management <pre><code>pragma solidity ^0.8.0;\n\ncontract ProperKeyManagement {\n    bytes32 private key;\n\n    constructor(bytes32 _key) {\n        key = _key; // Configurable key\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/","title":"SCWE-026: Insufficient Hash Verification","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature CWE-347 Link</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#description","title":"Description","text":"<p>Insufficient hash verification refers to the failure to properly verify hashes, such as message hashes or transaction hashes. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#remediation","title":"Remediation","text":"<ul> <li>Validate hashes: Ensure all hashes are properly verified before processing.</li> <li>Use secure libraries: Leverage well-audited libraries for hash verification.</li> <li>Test thoroughly: Conduct extensive testing to ensure hash verification works as intended.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#examples","title":"Examples","text":"<ul> <li> <p>Insufficient Hash Verification <pre><code>pragma solidity ^0.8.0;\n\ncontract InsufficientHashVerification {\n    function processHash(bytes32 hash) public {\n        // Process hash without verification\n    }\n}\n</code></pre></p> </li> <li> <p>Sufficient Hash Verification <pre><code>pragma solidity ^0.8.0;\n\ncontract SufficientHashVerification {\n    function processHash(bytes32 hash, bytes memory data) public {\n        require(keccak256(data) == hash, \"Invalid hash\");\n        // Process hash\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/","title":"SCWE-027: Vulnerable Cryptographic Algorithms","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#relationships","title":"Relationships","text":"<ul> <li>CWE-327: Use of a Broken or Risky Cryptographic Algorithm CWE-327 Link</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#description","title":"Description","text":"<p>Vulnerable cryptographic algorithms refer to the use of outdated or insecure cryptographic algorithms, such as MD5 or SHA-1. This can lead to: - Exploitation of the contract\u2019s logic. - Loss of funds or data. - Reduced trust in the contract\u2019s security.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#remediation","title":"Remediation","text":"<ul> <li>Use secure algorithms: Leverage modern cryptographic algorithms like SHA-256 or Keccak-256.</li> <li>Avoid deprecated algorithms: Do not use algorithms known to be insecure.</li> <li>Test thoroughly: Conduct extensive testing to ensure cryptographic security.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Algorithm <pre><code>pragma solidity ^0.8.0;\n\ncontract VulnerableAlgorithm {\n    function hashData(bytes memory data) public pure returns (bytes32) {\n        return sha256(data); // Insecure algorithm\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Algorithm <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureAlgorithm {\n    function hashData(bytes memory data) public pure returns (bytes32) {\n        return keccak256(data); // Secure algorithm\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/","title":"SCWE-054: Signature Malleability","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity https://cwe.mitre.org/data/definitions/345.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#description","title":"Description","text":"<p>Signature malleability refers to the ability to modify a valid signature without changing its validity. This can occur when signatures are not properly verified or when certain components of a signature (like the <code>v</code>, <code>r</code>, and <code>s</code> values) can be altered while still producing a valid signature.</p> <p>Attackers can modify a signature\u2019s <code>s</code> value or flip <code>v</code> between 27 and 28, generating different valid signatures for the same message. This can lead to:</p> <ul> <li>Replay attacks, where transactions can be re-executed with modified signatures.</li> <li>Transaction hijacking, where a valid signature is altered to redirect funds or manipulate contract state.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#remediation","title":"Remediation","text":"<p>To mitigate signature malleability, ensure that the signature verification process is robust. Use secure cryptographic libraries that properly handle signature validation, such as ECDSA or EdDSA with additional checks to prevent malleability. When verifying signatures, consider using a canonical format for signature components to avoid malleability.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#vulnerable-contract-example-allows-signature-malleability","title":"Vulnerable Contract Example- (Allows Signature Malleability)","text":"<p><pre><code>contract MalleableSignatureExample {\n    function verifySignature(bytes32 message, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\n        address signer = ecrecover(message, v, r, s);  // Signature malleability risk\n        return signer != address(0);\n    }\n}\n</code></pre> - This contract does not restrict <code>s</code> values, allowing malleable signatures. - Issue: The contract does not check if <code>s</code> is in the lower half of the <code>curve (s &lt; secp256k1n/2)</code>, allowing multiple valid signatures for the same message.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#fixed-contract-example-prevents-signature-malleability","title":"Fixed Contract Example- Prevents Signature Malleability)","text":"<pre><code>  pragma solidity ^0.8.0;\n\n  import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n  contract SecureSignatureExample {\n      using ECDSA for bytes32;\n\n      function verifySignature(bytes32 message, bytes memory signature) public pure returns (address) {\n          return message.toEthSignedMessageHash().recover(signature);\n      }\n  }\n</code></pre> <ul> <li>Fix: Uses <code>OpenZeppelin\u2019s ECDSA library</code>, which ensures <code>s</code> is in the lower half and restricts <code>v</code> to 27 or 28.</li> <li>Outcome: Prevents attackers from modifying valid signatures to create alternate, equally valid ones.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/","title":"SCWE-055: Missing Protection against Signature Replay Attacks","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#relationships","title":"Relationships","text":"<ul> <li>CWE-294: Authentication Bypass by Capture-replay https://cwe.mitre.org/data/definitions/294.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#description","title":"Description","text":"<p>Signature replay attacks occur when a valid signature from a previous transaction is reused in a different context, such as a different transaction or contract call. Without proper protection, an attacker can capture and replay a signature, potentially bypassing authentication checks and causing unauthorized actions or transactions.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#remediation","title":"Remediation","text":"<p>To prevent signature replay attacks, include additional checks that ensure the signature is valid for a specific transaction or context. This can be done by incorporating unique identifiers like a nonce, timestamp, or a unique transaction hash into the signature to bind it to a specific use. Always verify that the signature is only valid for the intended action.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract ReplayAttackExample {\n    mapping(address =&gt; uint256) public nonces;\n\n    function authenticate(bytes32 message, uint8 v, bytes32 r, bytes32 s) public {\n        address signer = ecrecover(message, v, r, s);\n        require(signer == msg.sender, \"Invalid signature\");\n        // No protection against replay attacks; attacker can reuse the same signature\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>  pragma solidity ^0.8.0;\n\n  import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n  contract SecureReplayProtectionExample {\n      using ECDSA for bytes32;\n\n      mapping(address =&gt; uint256) public nonces;\n\n      function authenticate(bytes32 message, bytes memory signature) public {\n          uint256 nonce = nonces[msg.sender]++;\n          bytes32 messageWithContext = keccak256(abi.encodePacked(message, nonce, block.chainid));  \n          address signer = messageWithContext.toEthSignedMessageHash().recover(signature);\n          require(signer == msg.sender, \"Invalid signature\");\n      }\n  }\n</code></pre> Fixes Implemented: -  Binds signature to a nonce (ensuring it's only usable once). -  Includes <code>chainId</code> (prevents cross-chain replay attacks). - Uses OpenZeppelin\u2019s ECDSA library (avoids signature malleability risks).</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/","title":"SCWE-056: Lack of Proper Signature Verification","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity https://cwe.mitre.org/data/definitions/345.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#description","title":"Description","text":"<p>This vulnerability occurs when a smart contract fails to properly verify whether a signature was produced by an authorized entity. In Ethereum, contracts often use <code>ecrecover</code> to check signatures, but failing to validate who signed the message allows:</p> <ul> <li>Unauthorized transactions, where attackers submit signatures from any key.</li> <li>Replay attacks, where valid signatures are reused to repeat actions.</li> <li>Malicious contract state manipulation, where attackers gain unauthorized access.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, always implement proper signature verification using secure cryptographic methods. Use the <code>ecrecover</code> function to recover the signer\u2019s address and ensure that the recovered address matches the expected address. Additionally, verify that the signature is valid for the intended message or transaction and that the signer is authorized to perform the action.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#vulnerable-contract-example-lack-of-signer-verification","title":"Vulnerable Contract Example- (Lack of Signer Verification)","text":"<p><pre><code>contract SignatureVerificationExample {\n    function authenticate(bytes32 message, uint8 v, bytes32 r, bytes32 s) public view returns (address) {\n        address signer = ecrecover(message, v, r, s);\n        return signer;  // No further validation of the signer or message\n    }\n}\n</code></pre> - Issue: The contract does not check if the recovered address matches an authorized signer. - Exploit: Any valid ECDSA signature can be used, even from an attacker\u2019s key.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#fixed-contract-example-proper-signature-verification","title":"Fixed Contract Example- (Proper Signature Verification)","text":"<p><pre><code>    pragma solidity ^0.8.0;\n\n    import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n    contract SecureSignatureVerificationExample {\n        using ECDSA for bytes32;\n\n        address public authorizedSigner;\n\n        constructor(address _authorizedSigner) {\n            require(_authorizedSigner != address(0), \"Invalid signer\");\n            authorizedSigner = _authorizedSigner;\n        }\n\n        function authenticate(bytes32 message, bytes memory signature) public view returns (bool) {\n            address signer = message.toEthSignedMessageHash().recover(signature);\n            require(signer == authorizedSigner, \"Unauthorized signer\"); // Proper validation\n            return true;\n        }\n    }\n</code></pre> - Fix: The contract now explicitly checks that the recovered address matches <code>authorizedSigner</code>. - Outcome: Prevents attackers from submitting arbitrary signatures and ensures only authorized signatures are accepted.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/","title":"SCWE-074: Hash Collisions with Multiple Variable Length Arguments","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature https://cwe.mitre.org/data/definitions/347.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#description","title":"Description","text":"<p>When hashing multiple variable-length arguments, there is a potential risk of hash collisions, which can occur if two different sets of inputs produce the same hash output. This vulnerability is particularly relevant in situations where hashes are used as identifiers, signatures, or keys, and collisions may lead to incorrect behavior or security breaches, such as false validation of signatures or unexpected contract logic execution.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#remediation","title":"Remediation","text":"<p>To prevent hash collisions, use a strong cryptographic hashing function like <code>keccak256</code> or <code>sha256</code>, and ensure that the inputs to the hash function are well-structured. Consider combining different sources of entropy (e.g., timestamps, nonces) and always verify the integrity of the data before trusting a hash.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    function verifyData(bytes memory data1, bytes memory data2) public pure returns (bytes32) {\n        // Vulnerable to hash collisions with multiple variable-length arguments\n        return keccak256(abi.encodePacked(data1, data2));  // Possible collision risk\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    function verifyData(bytes memory data1, bytes memory data2) public pure returns (bytes32) {\n        // Safe way to hash multiple variable-length arguments\n        return keccak256(abi.encode(data1, data2));  // More secure handling of variable-length inputs\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/","title":"SCWE-084: Insecure Use of blockhash","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#description","title":"Description","text":"<p>The <code>blockhash</code> function is often misused to generate randomness in smart contracts. However, <code>blockhash</code> is publicly available and can be influenced by validators (or miners on PoW chains), making it an unreliable and insecure source of randomness.</p> <p>Attackers can manipulate <code>blockhash</code> by controlling which transactions are included in a block, reordering transactions, or discarding unfavorable blocks. This can lead to predictable random outcomes, allowing malicious actors to exploit lotteries, gaming, and other randomness-dependent mechanisms.</p> <p>Attack Scenarios - Lottery Manipulation: A validator (or miner on PoW) can withhold or reorder transactions to ensure a favorable <code>blockhash</code> that lets them win. - Game Exploitation: If a game outcome depends on <code>blockhash</code>, an attacker can predict future results and place bets accordingly.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#remediation","title":"Remediation","text":"<p>Do not rely on <code>blockhash</code> for generating randomness. Use more secure and unpredictable sources of randomness, such as using Chainlink VRF or other trusted oracles.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>// Vulnerable contract using blockhash for randomness\npragma solidity ^0.8.0;\n\ncontract InsecureRandomness {\n    function getRandomNumber(uint256 _blockNumber) public view returns (uint256) {\n        return uint256(blockhash(_blockNumber)); // Predictable randomness\n    }\n}\n</code></pre> Why is this insecure? - Validators (or miners on PoW) control block production \u2014 they can reorder or discard blocks to manipulate <code>blockhash</code>. - Predictability - Attackers can call this function for past block numbers, making randomness guessable.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#fixed-contract-example-secure-random-number-generation-using-chainlink-vrf","title":"Fixed Contract Example- Secure Random Number Generation Using Chainlink VRF","text":"<pre><code>pragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\"; // Note: Chainlink VRF V1 is deprecated; use VRF V2 (VRFConsumerBaseV2) in production\n\ncontract SecureLottery is VRFConsumerBase {\n    address[] public players;\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n\n    constructor()\n        VRFConsumerBase(\n            0x514910771AF9Ca656af840dff83E8264EcF986CA, // Chainlink VRF Coordinator\n            0x514910771AF9Ca656af840dff83E8264EcF986CA // LINK Token address\n        )\n    {\n        keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a617d11109b44b8aab01; \n        fee = 0.1 * 10**18; // 0.1 LINK (varies by network)\n    }\n\n    function enter() public payable {\n        require(msg.value &gt; 0.1 ether, \"Minimum ETH required\");\n        players.push(msg.sender);\n    }\n\n    function requestRandomWinner() public returns (bytes32 requestId) {\n        require(players.length &gt; 0, \"No players joined\");\n        require(LINK.balanceOf(address(this)) &gt;= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        uint256 index = randomness % players.length;\n        (bool ok, ) = payable(players[index]).call{value: address(this).balance}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> <p>Why is this secure? - Uses <code>Chainlink VRF</code> (Verifiable Random Function), which provides unpredictable, tamper-proof randomness. - Validators (or miners on PoW) cannot manipulate the randomness as it is derived from a verifiable external source. - Players cannot predict the outcome before participating.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/","title":"SCWE-114: ECDSA Nonce Reuse","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/#relationships","title":"Relationships","text":"<ul> <li>CWE-323: Reusing a Nonce, Key Pair in Encryption https://cwe.mitre.org/data/definitions/323.html</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/#description","title":"Description","text":"<p>Reusing the same ECDSA nonce (<code>k</code>) across signatures (or using predictable nonces) leaks the private key. Contracts that accept off-chain signatures for permits, meta-txs, or governance can be compromised if signing infrastructure mismanages nonces.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/#remediation","title":"Remediation","text":"<ul> <li>Use battle-tested libraries/wallets that generate unique, random or RFC6979 deterministic nonces per message.</li> <li>Monitor and rotate keys if nonce reuse is suspected; support key revocation on-chain.</li> <li>Avoid custom signing code or manual nonce management in scripts.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/#vulnerable","title":"Vulnerable","text":"<pre><code>// Off-chain signer reuses k for two messages:\n// sig1 = (r, s1) with k\n// sig2 = (r, s2) with same k =&gt; private key can be recovered\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-114/#fixed","title":"Fixed","text":"<pre><code>// Off-chain: Use libraries/wallets that follow RFC6979; never reuse k.\n// On-chain: Support key rotation so compromised keys can be revoked.\nmapping(address =&gt; bool) public revokedSigners;\n\nfunction execute(bytes calldata payload, bytes calldata sig) external {\n    address signer = _recoverSigner(payload, sig);\n    require(!revokedSigners[signer], \"key revoked\");\n    // ...\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/","title":"SCWE-115: Weak VRF Parameterization or Callback Validation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/#relationships","title":"Relationships","text":"<ul> <li>CWE-330: Use of Insufficiently Random Values https://cwe.mitre.org/data/definitions/330.html</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/#description","title":"Description","text":"<p>Using VRF services without validating <code>requestId</code>, sender, or subscription can let attackers spoof fulfillments or drain subscription balances. Misconfigured key hashes, gas limits, or shared subscriptions can cause predictable failures and force fallback logic that leaks randomness.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/#remediation","title":"Remediation","text":"<ul> <li>Bind VRF fulfillments to tracked <code>requestId</code> values and trusted coordinator addresses.</li> <li>Use dedicated subscriptions, appropriate key hashes, and sane callback gas limits.</li> <li>Revert on unexpected fulfillments and avoid using fallback pseudo-randomness.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\ncontract Lottery is VRFConsumerBaseV2 {\n    uint256 public randomWord;\n\n    function fulfillRandomWords(uint256, uint256[] memory words) internal override {\n        randomWord = words[0]; // no requestId or sender validation\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-115/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\ncontract Lottery is VRFConsumerBaseV2 {\n    uint256 public pending;\n\n    function request() external { pending = COORDINATOR.requestRandomWords(/* params */); }\n\n    function fulfillRandomWords(uint256 requestId, uint256[] memory words) internal override {\n        require(requestId == pending, \"unknown request\");\n        pending = 0;\n        // use words[0]...\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/","title":"SCWE-131: Missing Domain Separation in Aggregate Signatures","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature https://cwe.mitre.org/data/definitions/347.html</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/#description","title":"Description","text":"<p>BLS/aggregate signature schemes that omit domain separation (e.g., chain id, contract, purpose) allow signature replay across domains. A valid signature for one network or message type can be reused elsewhere to authorize unintended actions.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/#remediation","title":"Remediation","text":"<ul> <li>Include explicit domain separation tags in the signed message for every aggregate signature.</li> <li>Verify domains on-chain and reject signatures from unknown domains.</li> <li>Use well-reviewed libraries and EIP-712 style typed data for aggregate schemes.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/#vulnerable","title":"Vulnerable","text":"<pre><code>bytes32 message = keccak256(abi.encode(data)); // no domain tag\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-131/#fixed","title":"Fixed","text":"<pre><code>bytes32 message = keccak256(abi.encode(DOMAIN_SEPARATOR, keccak256(data)));\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/","title":"SCWE-036: Inadequate Gas Limit Handling","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption CWE-400 Link</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#description","title":"Description","text":"<p>Inadequate gas limit handling occurs when a contract fails to manage gas constraints efficiently, leading to performance bottlenecks and denial-of-service (DoS) risks. Poor gas handling can result in: - Unoptimized execution: Unnecessary gas-heavy computations increasing costs. - DoS vulnerabilities: Transactions failing due to excessive gas usage, blocking operations. - Inefficient batch processing: Overloaded loops or storage updates causing out-of-gas (OOG) errors.</p> <p>Unlike SCWE-032, which focuses on the protocol-level block gas limit, this issue arises due to poor gas management at the smart contract level.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#remediation","title":"Remediation","text":"<ul> <li>Optimize gas usage: Minimize gas consumption in contract operations.</li> <li>Avoid unbounded loops: Ensure loops have a fixed upper limit.</li> <li>Test thoroughly: Conduct extensive testing to ensure operations stay within gas limits.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#examples","title":"Examples","text":"<ul> <li>Inadequate Gas Handling <pre><code>pragma solidity ^0.8.0;\n\ncontract InefficientProcessing {\n    mapping(address =&gt; uint) public balances;\n\n    function batchTransfer(address[] memory recipients, uint amount) public {\n        for (uint i = 0; i &lt; recipients.length; i++) {\n            balances[recipients[i]] += amount; // Gas-intensive operation\n        }\n    }\n}\n</code></pre></li> </ul> <p>Issue: Processes large arrays in a single transaction, which can fail due to out-of-gas errors.</p> <p>Why is this a problem? - If recipients.length is too large, the transaction fails. - Attackers can exploit this by submitting large recipient lists, causing a DoS attack.</p> <ul> <li>Adequate Gas Handling <pre><code>pragma solidity ^0.8.0;\n\ncontract GasOptimizedProcessing {\n    mapping(address =&gt; uint) public balances;\n\n    function batchTransfer(address[] memory recipients, uint amount) public {\n        uint i = 0;\n        while (i &lt; recipients.length &amp;&amp; gasleft() &gt; 50000) { // Stop before out of gas\n            balances[recipients[i]] += amount;\n            i++;\n        }\n    }\n}\n</code></pre> \u2714\ufe0f Fix: Uses gasleft() to gracefully exit before running out of gas, ensuring some transfers complete. Why is this better? \u2705 Prevents complete transaction failure by handling only as many iterations as gas allows. \u2705 Reduces DoS risk by allowing partial execution instead of reverting everything. \u2705 Enables retrying to complete all operations over multiple calls.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/","title":"SCWE-058: DoS with Block Gas Limit","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#description","title":"Description","text":"<p>Denial of Service (DoS) with block gas limit occurs when a contract is designed in such a way that its execution depends on a large amount of gas, potentially exceeding the block gas limit. This can result in the transaction failing, causing the contract to become unavailable or unusable. Attackers can exploit this vulnerability by creating transactions that consume excessive gas, effectively locking the contract or preventing normal operation.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that operations that depend on gas consumption are efficient and that gas limits are taken into account when designing contract logic. Avoid functions that require large amounts of gas to complete, and consider implementing features like batching or chunking operations to spread the gas usage across multiple transactions.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasLimitDoS {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        for (uint256 i = 0; i &lt; newData.length; i++) {\n            data.push(newData[i]);  // Can consume a large amount of gas if the array is large\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasLimitSafe {\n    uint256[] public data;\n    uint256 public constant MAX_BATCH = 100;\n\n    function addData(uint256[] memory newData) public {\n        require(newData.length &lt;= MAX_BATCH, \"Batch too large; split into smaller calls\");\n        for (uint256 i = 0; i &lt; newData.length; i++) {\n            data.push(newData[i]);\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/","title":"SCWE-059: Insufficient Gas Griefing","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#description","title":"Description","text":"<p>Insufficient gas griefing occurs when an attacker intentionally sends a transaction with insufficient gas to force the contract to fail. This can lead to resource consumption issues and potential denial of service for the contract or other users. If a contract relies on external calls or interacts with other contracts and does not properly handle gas estimation, it may be vulnerable to such attacks.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that gas estimation and proper gas limits are handled when performing contract calls, especially when interacting with other contracts. Additionally, use mechanisms to handle failures gracefully, such as revert messages and checks for sufficient gas before initiating important operations.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasGriefing {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferFunds(address payable recipient, uint256 amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        recipient.transfer(amount);  // Potential for griefing with insufficient gas\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasGriefingSafe {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferFunds(address payable recipient, uint256 amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/","title":"SCWE-077: Lack of Rate Limiting","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#relationships","title":"Relationships","text":"<ul> <li>CWE-770: Allocation of Resources Without Limits or Throttling https://cwe.mitre.org/data/definitions/770.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#description","title":"Description","text":"<p>Lack of rate limiting in a smart contract can lead to Denial of Service (DoS) attacks, excessive gas consumption, or contract state bloating. Without a mechanism to restrict the frequency of function calls, an attacker can flood the contract with transactions, causing delays, increased gas fees, or complete unavailability of critical functions.  </p> <p>This vulnerability is particularly dangerous in DeFi protocols, where unlimited function calls could drain funds, abuse governance mechanisms, or overload on-chain processing.  </p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#remediation","title":"Remediation","text":"<ul> <li>Implement rate-limiting mechanisms such as time-based constraints (e.g., requiring a cooldown period between calls).  </li> <li>Use counters with expiration timestamps to track and restrict repetitive actions.  </li> <li>Introduce gas fees or staking requirements to deter spam transactions.  </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint) public userRequests;\n\n    // \u274c No rate limiting: users can spam this function indefinitely\n    function request() public {\n        userRequests[msg.sender]++;\n        // No restrictions or cooldowns, allowing abuse\n    }\n}\n</code></pre> <p>Why is this vulnerable? - No restrictions on how frequently a user can call <code>request()</code>. - An attacker can spam transactions, leading to high gas costs and DoS. - Storage bloat from excessive <code>userRequests</code> mappings.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>contract SecureExample {\n    struct RequestData {\n        uint count;\n        uint lastReset;\n    }\n\n    mapping(address =&gt; RequestData) public userRequests;\n    uint public constant REQUEST_LIMIT = 5;\n    uint public constant TIME_WINDOW = 1 hours;\n\n    // \u2705 Implement rate limiting with a cooldown period\n    function request() public {\n        RequestData storage requestData = userRequests[msg.sender];\n\n        if (block.timestamp &gt; requestData.lastReset + TIME_WINDOW) {\n            requestData.count = 0;  // Reset count after time window\n            requestData.lastReset = block.timestamp;\n        }\n\n        require(requestData.count &lt; REQUEST_LIMIT, \"Rate limit exceeded\");\n        requestData.count++;\n    }\n}\n</code></pre> Why is this safe? - Tracks request timestamps, resetting counts after a fixed period. - Restricts excessive calls, preventing abuse and DoS attacks. - Efficient state management, reducing unnecessary storage costs.</p> <p>By enforcing rate limits, contracts can prevent spam attacks and ensure fair access to on-chain resources.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/","title":"SCWE-082: Lack of Proper Gas Management","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#description","title":"Description","text":"<p>Gas management is crucial in smart contracts to ensure that they do not run out of gas or cause excessive consumption. If gas consumption is not properly controlled, a contract can fail to execute or can be exploited by attackers to cause denial of service (DoS).</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#remediation","title":"Remediation","text":"<p>Properly estimate the gas required for functions and set appropriate gas limits. Use <code>require</code> or other mechanisms to handle gas consumption failures and ensure that gas usage remains within acceptable bounds.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    function execute() public {\n        while (true) { \n            // Excessive gas consumption, no limit set\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    uint public counter;\n\n    function execute(uint _iterations) public {\n        require(_iterations &lt;= 100, \"Too many iterations\"); // Limit iterations to avoid excessive gas usage\n        for (uint i = 0; i &lt; _iterations; i++) {\n            counter++;\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/","title":"SCWE-109: Unbounded Loops on Untrusted Input","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/#relationships","title":"Relationships","text":"<ul> <li>CWE-834: Excessive Iteration https://cwe.mitre.org/data/definitions/834.html</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/#description","title":"Description","text":"<p>Iterating over user-controlled arrays or mappings without bounds lets attackers submit large inputs that exhaust gas, causing denial of service. Functions like batch withdrawals, reward distribution, or liquidations may become permanently unusable.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/#remediation","title":"Remediation","text":"<ul> <li>Impose upper bounds on loop iterations or batch sizes.</li> <li>Use pagination/iterative processing with checkpoints.</li> <li>Avoid on-chain iteration over untrusted lists; rely on off-chain aggregation with verifiable proofs (Merkle leaves).</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Distributor {\n    function airdrop(address[] calldata users) external {\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            (bool ok, ) = payable(users[i]).call{value: 1 ether}(\"\");\n            require(ok, \"Transfer failed\"); // can run out of gas with large arrays\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-109/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Distributor {\n    uint256 public last;\n\n    function airdrop(address[] calldata users, uint256 max) external {\n        uint256 end = last + max;\n        if (end &gt; users.length) end = users.length;\n        for (uint256 i = last; i &lt; end; i++) {\n            (bool ok, ) = payable(users[i]).call{value: 1 ether}(\"\");\n            require(ok, \"Transfer failed\");\n        }\n        last = end;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/","title":"SCWE-116: Missing Supply Cap Enforcement","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/#relationships","title":"Relationships","text":"<ul> <li>CWE-693: Protection Mechanism Failure https://cwe.mitre.org/data/definitions/693.html</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/#description","title":"Description","text":"<p>Tokens or lending systems without hard supply caps allow privileged accounts or flawed logic to mint unlimited units, inflating supply and draining collateralized protocols. Lack of caps also breaks price assumptions in AMMs and oracles.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/#remediation","title":"Remediation","text":"<ul> <li>Define immutable max supply and enforce it on every mint path.</li> <li>Separate minting roles with multi-sig and timelock; emit events for mint changes.</li> <li>Include cap checks in upgrades and cross-chain minting/bridging logic.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Token {\n    address public owner;\n    uint256 public totalSupply;\n\n    function mint(address to, uint256 amount) external {\n        require(msg.sender == owner, \"not owner\");\n        totalSupply += amount; // no cap\n        // mint tokens...\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-116/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Token {\n    address public owner;\n    uint256 public totalSupply;\n    uint256 public constant MAX_SUPPLY = 1_000_000 ether;\n\n    function mint(address to, uint256 amount) external {\n        require(msg.sender == owner, \"not owner\");\n        require(totalSupply + amount &lt;= MAX_SUPPLY, \"cap exceeded\");\n        totalSupply += amount;\n        // mint tokens...\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/","title":"SCWE-125: Missing Post-Operation Health Check","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/754.html</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/#description","title":"Description","text":"<p>Lending/borrowing protocols that do not re-evaluate health factors after actions (borrow, withdraw, leverage) allow users to exit with unhealthy positions. Attackers can drain collateral or avoid liquidation by skipping post-operation solvency checks.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/#remediation","title":"Remediation","text":"<ul> <li>Recompute health factor after every state-changing action and revert if below threshold.</li> <li>Lock price/oracle reads during the operation to avoid mid-tx manipulation.</li> <li>Add invariant/fuzz tests to ensure every path enforces solvency.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/#vulnerable","title":"Vulnerable","text":"<pre><code>function borrow(uint256 amount) external {\n    _issueDebt(msg.sender, amount);\n    // no health check after debt increase\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-125/#fixed","title":"Fixed","text":"<pre><code>function borrow(uint256 amount) external {\n    _issueDebt(msg.sender, amount);\n    require(_health(msg.sender) &gt;= MIN_HF, \"insolvent\");\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/","title":"SCWE-126: Unbounded Withdrawal Queue Growth","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/#description","title":"Description","text":"<p>Protocols that queue withdrawals without bounding length or processing batches can face gas exhaustion when executing large queues. Attackers can spam small requests to DoS withdrawal execution or force users to accept delays.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/#remediation","title":"Remediation","text":"<ul> <li>Cap queue size or use batched/paged processing with upper gas limits.</li> <li>Charge fees or require minimum amounts to discourage spam.</li> <li>Allow users to cancel/claim in smaller chunks rather than processing the entire queue at once.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/#vulnerable","title":"Vulnerable","text":"<pre><code>function processAll() external {\n    for (uint256 i = 0; i &lt; queue.length; i++) {\n        _pay(queue[i]);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-126/#fixed","title":"Fixed","text":"<pre><code>function processBatch(uint256 start, uint256 max) external {\n    uint256 end = start + max;\n    if (end &gt; queue.length) end = queue.length;\n    for (uint256 i = start; i &lt; end; i++) {\n        _pay(queue[i]);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/","title":"SCWE-148: Gas Exhaustion via Unbounded Loops with External Calls","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/#description","title":"Description","text":"<p>Loops that iterate over user-controlled arrays and perform external calls (transfers, approvals, or other contract calls) in each iteration can exhaust gas when the array is large. Each external call consumes gas; unbounded loops cause the transaction to hit the block gas limit and revert, resulting in denial of service. SCWE-109 covers unbounded loops generally; this weakness focuses on loops that perform external calls.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/#remediation","title":"Remediation","text":"<ul> <li>Impose an upper bound on loop iterations or batch size.</li> <li>Use pull-based patterns: let users claim individually instead of pushing to many addresses in one tx.</li> <li>Process in chunks with pagination or checkpoints.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Airdrop {\n    function distribute(address[] calldata recipients, uint256 amount) external {\n        for (uint256 i = 0; i &lt; recipients.length; i++) {\n            (bool ok, ) = recipients[i].call{value: amount}(\"\");\n            require(ok, \"Transfer failed\");\n        }\n    }\n}\n</code></pre> Why vulnerable: Large <code>recipients.length</code> causes out-of-gas; one failed transfer reverts the entire batch.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-148/#fixed","title":"Fixed","text":"<pre><code>uint256 public constant MAX_BATCH = 100;\n\nfunction distribute(address[] calldata recipients, uint256 amount) external {\n    require(recipients.length &lt;= MAX_BATCH, \"Batch too large\");\n    for (uint256 i = 0; i &lt; recipients.length; i++) {\n        (bool ok, ) = recipients[i].call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/","title":"SCWE-151: Add/Remove Liquidity Without Minimum Output Validation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/#description","title":"Description","text":"<p>Adding or removing liquidity in AMMs (e.g., Uniswap, Curve) without enforcing a minimum amount of LP tokens or underlying assets received can expose users to sandwich attacks or unfavorable execution. Similar to swap slippage (SCWE-090), LP operations can be front-run: an attacker manipulates the pool before the user's add/remove, then reverses after. Without <code>amountMin</code> or equivalent checks, users may receive far less than expected.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/#remediation","title":"Remediation","text":"<ul> <li>Accept <code>amountMin</code> (or <code>minLPTokens</code>, <code>minAmounts</code>) from users and enforce it when adding/removing liquidity.</li> <li>Use deadline parameters (SCWE-141) in addition to slippage protection.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface IUniswapV2Router {\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n}\n\ncontract LiquidityManager {\n    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external {\n        IUniswapV2Router(router).addLiquidity(\n            tokenA, tokenB,\n            amountA, amountB,\n            0, 0,  // amountAMin, amountBMin = 0: no slippage protection\n            msg.sender,\n            block.timestamp\n        );\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-151/#fixed","title":"Fixed","text":"<pre><code>function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB, uint256 amountAMin, uint256 amountBMin, uint256 deadline) external {\n    require(block.timestamp &lt;= deadline, \"Expired\");\n    IUniswapV2Router(router).addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin, msg.sender, deadline);\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/","title":"SCWE-012: Lack of Multisig Governance","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#relationships","title":"Relationships","text":"<ul> <li>CWE-285: Improper Authorization https://cwe.mitre.org/data/definitions/285.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#description","title":"Description","text":"<p>Lack of multisig governance occurs when critical smart contract functions, such as upgrades, fund withdrawals, or parameter changes, are controlled by a single entity. This creates a single point of failure, increasing the risk of compromise, insider abuse, or unauthorized access. Without multisig governance, attackers or malicious actors can easily exploit privileged functions if the private key of a single administrator is compromised.</p> <p>Key risks associated with missing multisig governance: - Centralization Risk: A single entity can control and modify key contract parameters. - Single Point of Failure: Loss or compromise of the owner's private key can result in catastrophic consequences. - Unauthorized Access: An attacker gaining control of the private key can execute privileged functions without approval. - Lack of Accountability: Decisions are made unilaterally, reducing transparency and security.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#remediation","title":"Remediation","text":"<ul> <li>Implement a Multisig Wallet: Use multisignature schemes (e.g., Gnosis Safe) to require multiple signers for critical transactions.</li> <li>Role-Based Access Control (RBAC): Assign multiple roles with different privileges to prevent centralized control.</li> <li>Timelocks for Critical Functions: Introduce a delay for privileged actions, allowing time for community intervention if needed.</li> <li>On-Chain Governance Mechanisms: Decentralize decision-making using DAO-based governance where applicable.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#example-of-a-contract-without-multisig-governance-centralized-owner","title":"Example of a Contract Without Multisig Governance (Centralized Owner)","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract CentralizedGovernance {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function upgradeContract(address newContract) public {\n        require(msg.sender == owner, \"Only owner can upgrade\");\n        // Only a single owner can perform critical actions\n    }\n\n    function withdrawFunds(address payable recipient, uint256 amount) public {\n        require(msg.sender == owner, \"Only owner can withdraw funds\");\n        (bool ok, ) = recipient.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\"); // \u274c No multisig verification\n    }\n}\n</code></pre> <ul> <li>In this example, all governance actions depend on a single owner, making it a high-risk design.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#refactored-to-use-multisig-governance","title":"Refactored to Use Multisig Governance","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface IMultiSig {\n    function submitTransaction(address destination, uint256 value, bytes calldata data) external;\n}\n\ncontract SecureGovernance {\n    IMultiSig public multisigWallet;\n\n    constructor(address _multisigWallet) {\n        multisigWallet = IMultiSig(_multisigWallet);\n    }\n\n    function upgradeContract(address newContract) public {\n        bytes memory data = abi.encodeWithSignature(\"upgradeTo(address)\", newContract);\n        multisigWallet.submitTransaction(address(this), 0, data); // \u2705 Requires multisig approval\n    }\n\n    function withdrawFunds(address payable recipient, uint256 amount) public {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount);\n        multisigWallet.submitTransaction(address(this), 0, data); // \u2705 Multisig verification for withdrawals\n    }\n}\n</code></pre> <ul> <li>This improved version delegates authority to a multisig wallet, requiring multiple approvals before executing critical actions.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/","title":"SCWE-015: Poor Governance Documentation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#relationships","title":"Relationships","text":"<ul> <li> <p>CWE-933: Security Misconfiguration https://cwe.mitre.org/data/definitions/933.html</p> </li> <li> <p>CWE-1118: Insufficient Documentation of Error Handling Techniques     https://cwe.mitre.org/data/definitions/1118.html</p> </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#description","title":"Description","text":"<p>Poor governance documentation refers to the lack of clear, transparent, and publicly accessible records regarding a smart contract system\u2019s decision-making processes, upgrade mechanisms, and role-based permissions. Without proper documentation, users, developers, and auditors struggle to understand the governance model, leading to reduced trust, misconfigurations, and potential security vulnerabilities.</p> <p>Key risks associated with poor governance documentation: - Unclear Decision-Making Process: Users may not understand how governance proposals are initiated, approved, or executed. - Hidden Centralization Risks: Critical governance powers may be concentrated in a small group without public awareness. - Lack of Upgradeability Transparency: If upgrade procedures are not well-documented, malicious or unintended changes may go unnoticed. - Poor Incident Response Handling: Without clear emergency protocols, governance failures can lead to slow or inadequate responses to attacks.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#remediation","title":"Remediation","text":"<ul> <li>Comprehensive Governance Documentation: Clearly outline roles, permissions, voting mechanisms, and upgradeability in technical and non-technical formats.</li> <li>Public Governance Reports: Regularly publish governance decisions, major votes, and protocol updates in a transparent manner.</li> <li>Well-Defined Emergency Procedures: Establish and document response plans for governance failures, protocol attacks, or keyholder compromises.</li> <li>On-Chain Governance Visibility: Ensure that governance smart contracts expose relevant functions for transparency and accountability.</li> <li>Third-Party Audits of Governance Mechanisms: Periodically review governance documentation and processes through independent audits.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#examples","title":"Examples","text":"<p>Unlike code vulnerabilities, poor governance documentation is a process failure rather than a direct coding flaw. However, its consequences can be illustrated with real-world governance failures:</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#example-unclear-upgradeability-policy-leads-to-a-security-breach","title":"Example: Unclear Upgradeability Policy Leads to a Security Breach","text":"<p>A DeFi protocol allows smart contract upgrades but fails to document the governance process for approving upgrades. A small group of developers, holding majority control over the governance multisig, pushes an unreviewed upgrade that introduces a critical vulnerability, resulting in a protocol exploit.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#fixed-ensuring-transparent-upgradeability-policies","title":"Fixed: Ensuring Transparent Upgradeability Policies","text":"<p>Protocols should establish a clear and documented upgradeability framework outlining who can propose, review, and approve upgrades. Implementing timelocks, community review periods, and independent security audits ensures upgrades are thoroughly vetted before execution. Additionally, maintaining an on-chain governance audit log enhances accountability and prevents unauthorized changes.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#example-lack-of-transparency-in-governance-voting","title":"Example: Lack of Transparency in Governance Voting","text":"<p>A DAO implements an opaque governance process, where voting power is controlled by a few insiders without a clear framework on how votes are counted or executed. Community members later discover that critical protocol changes were pushed without public discussion, leading to governance disputes and loss of user trust.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#enhancing-transparency-in-governance-voting","title":"Enhancing Transparency in Governance Voting","text":"<p>Governance processes should be transparent, well-documented, and resistant to centralization risks to maintain trust. Clearly defining voting mechanisms, proposal review procedures, and decision-making criteria prevents manipulation and governance capture. Public governance discussions, decentralized voting structures, and immutable records of voting outcomes further enhance credibility and community trust.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/","title":"SCWE-037: Insufficient Protection Against Front-Running","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#description","title":"Description","text":"<p>Insufficient protection against front-running refers to vulnerabilities that allow malicious actors to exploit the order of transactions for profit. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract\u2019s logic.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#remediation","title":"Remediation","text":"<ul> <li>Use commit-reveal schemes: Implement commit-reveal mechanisms to hide transaction details until they are finalized.</li> <li>Add delays: Introduce time delays for critical operations to reduce the risk of front-running.</li> <li>Test thoroughly: Conduct extensive testing to ensure front-running protection is effective.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#examples","title":"Examples","text":"<ul> <li>Vulnerable to Front-Running <pre><code>pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract FrontRunningVulnerable {\n    IERC20 public token;\n    uint256 public price = 1 ether; // 1 token = 1 ETH\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function buyTokens(uint256 amount) public payable {\n        require(msg.value &gt;= amount * price, \"Insufficient ETH\");\n        token.transferFrom(address(this), msg.sender, amount);\n    }\n}\n</code></pre> Why is this vulnerable?</li> <li>Attackers see the transaction in the mempool and execute a transaction to buy first, raising the price.</li> <li>Victim's transaction executes at a higher price or fails due to slippage.</li> <li> <p>Attacker sells at a profit, exploiting sandwich attacks.</p> </li> <li> <p>Protected Against Front-Running-  Commit-Reveal to Hide Trade Intent <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureTrade {\n    mapping(address =&gt; bytes32) public commitments;\n    uint256 public price = 1 ether; // 1 token = 1 ETH\n\n    function commitTrade(bytes32 hash) public {\n        commitments[msg.sender] = hash;\n    }\n\n    function executeTrade(uint256 amount, bytes32 secret) public payable {\n        require(commitments[msg.sender] == keccak256(abi.encodePacked(amount, secret)), \"Invalid commitment\");\n        require(msg.value &gt;= amount * price, \"Insufficient ETH\");\n\n        commitments[msg.sender] = 0; // Prevent reusing commitment\n        // Execute trade after revealing the commitment\n    }\n}\n</code></pre> Why is this better?</p> </li> <li>Traders commit to the trade off-chain before revealing the amount, preventing mempool sniping.</li> <li>Transactions cannot be front-run because attackers don\u2019t know the amount until revealed.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/","title":"SCWE-043: Insecure Use of Fallback Functions","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#relationships","title":"Relationships","text":"<ul> <li>CWE-250: Execution with Unnecessary Privileges CWE-250 Link</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#description","title":"Description","text":"<p>Insecure use of fallback functions refers to vulnerabilities that arise when fallback functions are used improperly. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data due to unintended execution. - Exploitation of contract logic if the fallback function allows arbitrary interactions.</p> <p>Fallback functions are triggered when a contract receives a call with no matching function signature. They can be used to handle Ether transfers or proxy unknown function calls. If misconfigured, they may enable unintended behaviors, such as unauthorized access or fund loss.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#remediation","title":"Remediation","text":"<ul> <li>Restrict logic execution in fallback functions: Avoid placing critical execution logic inside fallback functions unless necessary.  </li> <li>Separate Ether reception: Use <code>receive()</code> explicitly to handle Ether transfers instead of overloading <code>fallback()</code>.  </li> <li>Validate calls: Ensure fallback functions do not execute unintended behavior. If required, use access control for specific use cases (e.g., controlled proxy calls).  </li> <li>Use explicit function definitions: Instead of relying on fallback functions for critical operations, define explicit functions with proper access control.  </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#insecure-fallback-function","title":"\ud83d\udea8 Insecure Fallback Function","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#problem-no-access-control-or-validation-allowing-unintended-execution","title":"Problem: No access control or validation, allowing unintended execution.","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureFallback {\n    fallback() external {\n        // No access control or validation\n    }\n}\n</code></pre> - This contract allows any call with an unknown function signature to trigger the fallback function, which could result in unintended behavior.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#secure-fallback-function-safe-handling-of-ether","title":"Secure Fallback Function (Safe Handling of Ether)","text":"<ul> <li>Solution: Explicitly handle Ether transfers using receive()</li> </ul> <p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureFallback {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    // Explicitly define a receive function to safely accept Ether\n    receive() external payable {}\n\n    // Safe fallback function (does nothing if unintentionally called)\n    fallback() external payable {\n        // Optional: Log unexpected calls for security monitoring\n    }\n}\n</code></pre> This version properly separates Ether reception from fallback execution, preventing unintended behavior.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/","title":"SCWE-044: Insecure Use of Storage","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#description","title":"Description","text":"<p>Insecure use of storage refers to vulnerabilities that arise when storage variables are improperly managed. This can lead to: - Unauthorized access to sensitive data. - Loss of funds or data. - Exploitation of vulnerabilities in contract logic.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#remediation","title":"Remediation","text":"<ul> <li>Encrypt sensitive data: Encrypt sensitive data before storing it.</li> <li>Validate inputs: Ensure all storage updates are properly validated.</li> <li>Test thoroughly: Conduct extensive testing to ensure storage is secure.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#examples","title":"Examples","text":"<ul> <li> <p>Insecure Storage Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureStorage {\n    uint public balance;\n\n    function updateBalance(uint newBalance) public {\n        balance = newBalance; // No validation\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Storage Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureStorage {\n    uint public balance;\n\n    function updateBalance(uint newBalance) public {\n        require(newBalance &gt; 0, \"Invalid balance\"); // Input validation\n        balance = newBalance;\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/","title":"SCWE-075: Incorrect Ether Balance Tracking","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#relationships","title":"Relationships","text":"<ul> <li>CWE-852: Untrusted Control Sphere https://cwe.mitre.org/data/definitions/852.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#description","title":"Description","text":"<p>Incorrect Ether balance tracking occurs when a contract manually maintains an internal balance variable instead of relying on <code>address(this).balance</code>. This creates inconsistencies when Ether is received outside of expected functions (e.g., via <code>selfdestruct()</code>, <code>transfer()</code>, or direct deposits).  </p> <p>Attackers can exploit this by artificially inflating the contract's perceived balance, leading to unauthorized withdrawals or failed transactions. This issue is common in poorly designed deposit/withdraw systems that do not properly verify the actual contract balance.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#attack-scenario","title":"Attack Scenario","text":"<p>An attacker sends Ether to the contract using <code>selfdestruct()</code>, increasing its actual balance without updating the internal tracking variable. Later, a user tries to withdraw funds, but the contract incorrectly assumes it has more Ether than it actually does, causing unexpected failures or exploits.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#remediation","title":"Remediation","text":"<ul> <li>Use <code>address(this).balance</code> instead of manually tracking Ether balance.</li> <li>Prevent external Ether deposits by disabling the fallback function unless explicitly needed.</li> <li>Ensure proper accounting by always reconciling balances before allowing withdrawals.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>// \u274c Vulnerable to incorrect balance tracking due to external Ether deposits\ncontract IncorrectBalanceTracking {\n    uint public balance;  // \u274c Manually tracking Ether balance\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balance &gt;= _amount, \"Insufficient funds\");\n        payable(msg.sender).transfer(_amount);\n        balance -= _amount;\n    }\n}\n</code></pre> Why is this vulnerable? - The contract does not account for direct Ether transfers outside deposit(). - An attacker can send Ether via <code>selfdestruct()</code>, inflating the contract balance without updating balance. - This can lead to withdrawals being blocked or excessive withdrawals.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\n// \u2705 Secure implementation: per-user accounting + address(this).balance for consistency\ncontract CorrectBalanceTracking {\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient funds\");\n        require(address(this).balance &gt;= _amount, \"Contract balance insufficient\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    receive() external payable {\n        revert(\"Direct deposits not allowed\");\n    }\n}\n</code></pre> Why is this secure? - Per-user <code>balances</code> mapping ensures only depositors can withdraw their funds. - Reconciles with <code>address(this).balance</code> before transfer to detect unexpected inflows (e.g. <code>selfdestruct</code>). - Uses <code>call{value}</code> for flexible gas; <code>receive()</code> reverts on direct deposits.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/","title":"SCWE-078: Improper Handling of Ether Transfers","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#relationships","title":"Relationships","text":"<ul> <li>CWE-703: Improper Check or Handling of Exceptional Conditions https://cwe.mitre.org/data/definitions/703.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#description","title":"Description","text":"<p>Improper handling of Ether transfers in Solidity can lead to unexpected behaviors, such as failed transactions or loss of funds. For instance, when using <code>transfer()</code> or <code>send()</code>, failure to check for successful execution or not handling exceptions correctly can cause Ether to be locked or lost in the contract.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#remediation","title":"Remediation","text":"<p>Always handle exceptions properly when transferring Ether. Ensure that you check for success or failure using <code>require()</code> or <code>assert()</code> after Ether transfers. Additionally, use <code>call()</code> with a specified gas limit for greater flexibility and error handling.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function transferEther(address payable _to) public payable {\n        // Fails silently if transfer fails\n        _to.transfer(msg.value);  // No error handling, can cause issues\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function transferEther(address payable _to) public payable {\n        (bool success, ) = _to.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/","title":"SCWE-079: Insecure Use of Transfer and Send","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#description","title":"Description","text":"<p>The use of <code>.transfer()</code> and <code>.send()</code> for Ether transfers in Solidity is insecure because they impose a fixed gas limit of 2300 gas. This restriction can cause transactions to fail unexpectedly when the receiving contract has complex logic that requires more gas. Additionally, it can result in a Denial of Service (DoS) vulnerability if the receiving contract cannot execute due to insufficient gas.</p> <p>This issue is especially problematic in upgradable smart contracts or protocol interactions, where the gas requirements of a receiving contract might change over time.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#remediation","title":"Remediation","text":"<p>Instead of <code>.transfer()</code> and <code>.send()</code>, use <code>.call{value: msg.value}(\"\")</code>, which allows more flexible gas allocation and prevents DoS risks. Always check for the return value of <code>.call()</code> to ensure the transfer was successful.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function transferEther(address payable _to) public payable {\n        // Fixed gas limit of 2300 gas can cause unintended failures\n        _to.transfer(msg.value);  \n    }\n}\n</code></pre> Problem: - If <code>_to</code> is a contract that requires more than <code>2300 gas</code> (e.g., it has a fallback function with state changes), this transfer will fail. - The contract has no error handling, meaning the sender won't be aware of the failure.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Example {\n    function transferEther(address payable _to) public payable {\n        // Use call() for better gas flexibility and proper error handling\n        (bool success, ) = _to.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre> Why is this better? - <code>.call{value: msg.value}(\"\")</code> does not impose a gas limit, allowing the receiving contract to execute as needed. - It includes a <code>require(success, \"Transfer failed\");</code> check, ensuring failures are properly handled.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/","title":"SCWE-081: Improper Handling of Nonce","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#description","title":"Description","text":"<p>Nonce values are used to ensure that transactions are processed in the correct order and prevent replay attacks. Improper handling or validation of nonces can lead to issues such as transaction replay or improper sequencing of transactions, which can be exploited by attackers.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#remediation","title":"Remediation","text":"<p>Always validate nonce values to ensure that they are correctly incremented and avoid reusing nonces. Ensure that nonce handling is robust, especially in cases where external calls are involved, to prevent replay attacks or transaction malleability.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint256) public nonces;\n\n    function transfer(address _to, uint256 _amount) public {\n        uint256 nonce = nonces[msg.sender]; // Nonce is not validated properly\n        nonces[msg.sender] = nonce + 1;     // This could allow replay attacks\n        // Transfer logic\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SecureExample {\n    mapping(address =&gt; uint256) public nonces;\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        uint256 _nonce,\n        bytes memory _signature\n    ) public {\n        require(_nonce == nonces[msg.sender], \"Invalid nonce\");\n\n        // Hash the message\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, _to, _amount, _nonce));\n        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\n\n        // Recover the signer's address\n        address signer = recoverSigner(ethSignedMessageHash, _signature);\n        require(signer == msg.sender, \"Invalid signature\");\n\n        nonces[msg.sender] = _nonce + 1;\n        // Transfer logic\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"Invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n}\n</code></pre> <p>Why is this better? - Nonce is no longer user input: It is validated as part of a signed message, preventing arbitrary replay attempts. - Prevents transaction replay attacks: By signing the message, an attacker cannot reuse an old transaction because the signature includes the nonce. - Ensures integrity &amp; authenticity: The contract only processes the transaction if the signed message is valid and matches the expected sender.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/","title":"SCWE-100: Missing Quorum Validation in Governance Execution","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/754.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/#description","title":"Description","text":"<p>Governance systems that allow proposal execution based solely on vote counts (e.g., \"for\" &gt; \"against\") without enforcing a minimum participation threshold (quorum) can execute proposals with negligible community participation. A proposal may \"pass\" with only a handful of votes if quorum is not checked, allowing a small group or attacker with accumulated tokens to push through changes that lack legitimate community mandate.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/#remediation","title":"Remediation","text":"<ul> <li>Enforce a minimum quorum (e.g., percentage of total supply or voting power) before allowing execution.</li> <li>Require both vote majority and quorum to be satisfied; revert execution if quorum is not met.</li> <li>Consider time-weighted or participation-based quorum to prevent last-block manipulation.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract VulnerableGov {\n    mapping(uint256 =&gt; uint256) public forVotes;\n    mapping(uint256 =&gt; uint256) public againstVotes;\n    uint256 public totalSupply;\n\n    function execute(uint256 proposalId) external {\n        require(forVotes[proposalId] &gt; againstVotes[proposalId], \"proposal failed\");\n        // No quorum check \u2014 can execute with 2 for, 1 against even if totalSupply is 1M\n        _executeProposal(proposalId);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-100/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureGov {\n    mapping(uint256 =&gt; uint256) public forVotes;\n    mapping(uint256 =&gt; uint256) public againstVotes;\n    uint256 public totalSupply;\n    uint256 public constant QUORUM_BPS = 400; // 4%\n\n    function execute(uint256 proposalId) external {\n        uint256 totalVotes = forVotes[proposalId] + againstVotes[proposalId];\n        require(forVotes[proposalId] &gt; againstVotes[proposalId], \"proposal failed\");\n        require(totalVotes * 10000 &gt;= totalSupply * QUORUM_BPS, \"quorum not met\");\n        _executeProposal(proposalId);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/","title":"SCWE-101: Flash-Loan-Fueled Governance Manipulation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/#relationships","title":"Relationships","text":"<ul> <li>CWE-367: Time-of-Check Time-of-Use (TOCTOU) Race Condition https://cwe.mitre.org/data/definitions/367.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/#description","title":"Description","text":"<p>If voting power is measured at execution time without historical snapshots or locking, an attacker can borrow a large balance via flash loan, pass a proposal, and return the loan in the same transaction. Governance decisions then depend on transient liquidity rather than long-term stake.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/#remediation","title":"Remediation","text":"<ul> <li>Use token balance snapshots at a fixed block for voting power.</li> <li>Require vote escrow/locking or minimum voting period spanning multiple blocks.</li> <li>Set quorum and proposal thresholds based on historical supply, not instantaneous balances.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SimpleGov {\n    IERC20 public token;\n    mapping(uint256 =&gt; bool) public proposals;\n\n    function vote(uint256 id, bool support) external {\n        require(token.balanceOf(msg.sender) &gt; 1_000_000 ether, \"low power\");\n        if (support) { proposals[id] = true; }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-101/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\n\ncontract SnapshotGov {\n    ERC20Snapshot public token;\n    mapping(uint256 =&gt; uint256) public snapshotId;\n\n    function openProposal(uint256 id) external {\n        snapshotId[id] = token.snapshot();\n    }\n\n    function vote(uint256 id, bool support) external {\n        uint256 power = token.balanceOfAt(msg.sender, snapshotId[id]);\n        require(power &gt; 1_000_000 ether, \"low power\");\n        // record vote...\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/","title":"SCWE-102: Missing Checks-Effects-Interactions Pattern","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/#relationships","title":"Relationships","text":"<ul> <li>CWE-841: Improper Enforcement of Behavioral Workflow https://cwe.mitre.org/data/definitions/841.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/#description","title":"Description","text":"<p>Calling external contracts before updating local state breaks the checks-effects-interactions (CEI) pattern. Attackers can reenter or observe stale state to perform double-withdrawals, bypass limits, or corrupt accounting.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/#remediation","title":"Remediation","text":"<ul> <li>Perform input validation and state updates before external calls.</li> <li>Use reentrancy guards on functions that transfer value or call untrusted contracts.</li> <li>Prefer pull-based withdrawals to avoid pushing funds inside complex flows.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Payout {\n    mapping(address =&gt; uint256) public balances;\n\n    function withdraw() external {\n        (bool ok, ) = msg.sender.call{value: balances[msg.sender]}(\"\");\n        require(ok, \"send failed\");       // external call first\n        balances[msg.sender] = 0;         // state updated after\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-102/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; // OZ 5.x: utils/ReentrancyGuard.sol\n\ncontract Payout is ReentrancyGuard {\n    mapping(address =&gt; uint256) public balances;\n\n    function withdraw() external nonReentrant {\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;         // effects first\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"send failed\");       // interaction last\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/","title":"SCWE-136: Unbounded Proposal Execution Gas","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/#description","title":"Description","text":"<p>Governance proposals that execute arbitrary call lists without gas limits or batching can exceed block gas, making proposals unexecutable (DoS). Attackers can submit proposals with expensive calls to jam governance or brick queued actions.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/#remediation","title":"Remediation","text":"<ul> <li>Enforce per-call and total gas limits; split proposals into bounded batches.</li> <li>Allow graceful skipping of failed subcalls with clear status, or pre-validate gas cost.</li> <li>Add simulation checks before queuing and block proposals that exceed safe gas budgets.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/#vulnerable","title":"Vulnerable","text":"<pre><code>function execute(bytes[] calldata calls) external {\n    for (uint i; i &lt; calls.length; i++) {\n        target.call(calls[i]); // no gas limit\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-136/#fixed","title":"Fixed","text":"<pre><code>function execute(bytes[] calldata calls, uint256 gasPerCall) external {\n    for (uint i; i &lt; calls.length; i++) {\n        (bool ok,) = target.call{gas: gasPerCall}(calls[i]);\n        require(ok, \"subcall failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/","title":"SCWE-140: Ether Locked Due to Missing Withdrawal Path","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/#relationships","title":"Relationships","text":"<ul> <li>CWE-404: Improper Resource Shutdown or Release https://cwe.mitre.org/data/definitions/404.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/#description","title":"Description","text":"<p>Contracts can receive ETH via <code>receive()</code>, <code>fallback()</code>, <code>selfdestruct</code> from another contract, or accidental sends. If the contract has no function to withdraw or forward this ETH, the funds become permanently locked. This can occur when a contract was not designed to hold ETH, when the withdrawal function is restricted to a role that no longer exists, or when the contract lacks a rescue/withdraw mechanism for unexpected inflows.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/#remediation","title":"Remediation","text":"<ul> <li>Implement a withdrawal or rescue function for authorized roles to recover stuck ETH.</li> <li>If the contract should not accept ETH, use <code>receive() external payable { revert(\"ETH not accepted\"); }</code>.</li> <li>Document how unexpected ETH (e.g., from <code>selfdestruct</code>) is handled.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    mapping(address =&gt; uint256) public balances;\n\n    function buyTokens() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawTokens() external {\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Why vulnerable: If ETH is sent via <code>selfdestruct</code> or a plain transfer, it increases <code>address(this).balance</code> but not any user's <code>balances</code>. That ETH cannot be withdrawn by anyone and is locked.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-140/#fixed","title":"Fixed","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address public owner;\n    uint256 public totalDeposits;\n    mapping(address =&gt; uint256) public balances;\n\n    constructor() { owner = msg.sender; }\n\n    function buyTokens() external payable {\n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n    }\n\n    function withdrawTokens() external {\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        totalDeposits -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    function rescueStuckETH() external {\n        require(msg.sender == owner, \"Not owner\");\n        uint256 excess = address(this).balance - totalDeposits;\n        require(excess &gt; 0, \"No excess\");\n        (bool ok, ) = owner.call{value: excess}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Fix: Track <code>totalDeposits</code> and only rescue ETH in excess of user deposits (e.g., from <code>selfdestruct</code>). <code>withdrawTokens</code> lets users claim their deposits; <code>rescueStuckETH</code> recovers only excess ETH.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/","title":"SCWE-142: Extractable Value from Predictable Transaction Ordering","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/#relationships","title":"Relationships","text":"<ul> <li>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') https://cwe.mitre.org/data/definitions/362.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/#description","title":"Description","text":"<p>Contracts that create predictable, orderable state changes expose value to block builders and searchers (MEV). Sandwich attacks, backrunning, and liquidation front-running are examples. When a user's transaction has a predictable effect (e.g., large swap moving price), an attacker can place transactions before and after to extract value. SCWE-037 covers front-running; this weakness addresses the broader MEV surface\u2014design choices that make extraction easy.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/#remediation","title":"Remediation","text":"<ul> <li>Use private mempools or commit-reveal schemes for sensitive transactions.</li> <li>Implement slippage protection (SCWE-090) and deadline parameters (SCWE-141).</li> <li>Consider batch auctions, fair ordering, or MEV-aware design (e.g., CoW Protocol) where applicable.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SimpleSwap {\n    function swap(uint256 amountIn, uint256 minOut) external {\n        // Predictable: searcher sees large amountIn, sandwiches with buy-before and sell-after\n        uint256 out = getAmountOut(amountIn);\n        require(out &gt;= minOut, \"Slippage\");\n        transferOut(msg.sender, out);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-142/#fixed","title":"Fixed","text":"<p><pre><code>function swap(uint256 amountIn, uint256 minOut, uint256 deadline) external {\n    require(block.timestamp &lt;= deadline, \"Expired\");\n    uint256 out = getAmountOut(amountIn);\n    require(out &gt;= minOut, \"Slippage\");\n    transferOut(msg.sender, out);\n}\n</code></pre> Fix: User-supplied <code>deadline</code> and <code>minOut</code> limit MEV extraction. Use DEX aggregators or private order flow for additional protection.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/","title":"SCWE-156: Missing Emergency Circuit Breaker for Critical Operations","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/#relationships","title":"Relationships","text":"<ul> <li>CWE-693: Protection Mechanism Failure https://cwe.mitre.org/data/definitions/693.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/#description","title":"Description","text":"<p>A circuit breaker is a threshold-based or condition-based halt mechanism that stops critical operations when anomalies are detected (e.g., TVL drop &gt;X%, unusual withdrawal volume, oracle deviation). Unlike simple pausability (SCWE-014), a circuit breaker automatically or semi-automatically triggers based on predefined conditions, providing an additional safety layer during attacks or market stress.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/#remediation","title":"Remediation","text":"<ul> <li>Implement circuit breakers that halt deposits, withdrawals, or swaps when thresholds are exceeded.</li> <li>Use oracle-based triggers (e.g., price deviation) or rate-limit triggers.</li> <li>Ensure the circuit breaker can be reset by governance or after cooldown.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/#vulnerable","title":"Vulnerable","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract LendingPool {\n    mapping(address =&gt; uint256) public balances;\n    uint256 public totalDeposits;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient\");\n        balances[msg.sender] -= amount;\n        totalDeposits -= amount;\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> Gap: No circuit breaker. A flash loan or oracle attack could drain funds before anyone can pause.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-156/#mitigation","title":"Mitigation","text":"<pre><code>uint256 public maxWithdrawalPerTx = 100 ether;\nuint256 public lastWithdrawalTime;\nuint256 public constant WITHDRAWAL_COOLDOWN = 1 hours;\n\nfunction withdraw(uint256 amount) external {\n    require(amount &lt;= maxWithdrawalPerTx, \"Circuit breaker: amount too high\");\n    require(block.timestamp &gt;= lastWithdrawalTime + WITHDRAWAL_COOLDOWN, \"Cooldown\");\n    lastWithdrawalTime = block.timestamp;\n    // ... rest of logic\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/","title":"SCWE-028: Price Oracle Manipulation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#description","title":"Description","text":"<p>Price Oracle manipulation refers to the exploitation of vulnerabilities in price oracles to manipulate contract logic. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#remediation","title":"Remediation","text":"<ul> <li>Use decentralized oracles: Leverage multiple decentralized oracles for price data.</li> <li>Validate inputs: Ensure all oracle data is properly validated before use.</li> <li>Implement circuit breakers: Add mechanisms to halt operations in case of suspicious activity.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable to Oracle Manipulation- Exploiting Weak Price Feeds</p> </li> <li> <p>Flash Loan-Based Price Manipulation</p> <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract VulnerableLending {\n    Oracle public priceOracle;\n    mapping(address =&gt; uint) public balances;\n\n    constructor(address _oracle) {\n        priceOracle = Oracle(_oracle);\n    }\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value * priceOracle.getPrice();\n    }\n\n    function withdraw(uint amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        (bool ok, ) = msg.sender.call{value: amount / priceOracle.getPrice()}(\"\"); // Uses current price\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> </li> </ul> <p>Why is this vulnerable?</p> <ul> <li>Flash loan attack: The attacker can manipulate the price before calling withdraw(), draining funds.</li> <li> <p>No validation mechanism to reject manipulated prices.</p> </li> <li> <p>Protected Against Oracle Manipulation \u2014 Fixed Code: Price Deviation Guards</p> <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract SecureLending {\n    Oracle public priceOracle;\n    mapping(address =&gt; uint) public balances;\n    uint public lastValidPrice;\n\n    constructor(address _oracle) {\n        priceOracle = Oracle(_oracle);\n        lastValidPrice = priceOracle.getPrice();\n    }\n\n    function updatePrice() external {\n        uint newPrice = priceOracle.getPrice();\n        require(newPrice &gt; lastValidPrice * 95 / 100 &amp;&amp; newPrice &lt; lastValidPrice * 105 / 100, \"Price deviation too high\");\n        lastValidPrice = newPrice;\n    }\n\n    function deposit() external payable {\n        updatePrice(); // refresh price before use\n        balances[msg.sender] += msg.value * lastValidPrice;\n    }\n\n    function withdraw(uint amount) external {\n        updatePrice(); // refresh price before use\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        (bool ok, ) = msg.sender.call{value: amount / lastValidPrice}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n}\n</code></pre> </li> </ul> <p>Fixes: - Implements price deviation guards (5% max change) to reject manipulated or stale prices. - Calls <code>updatePrice()</code> before deposit/withdraw to ensure <code>lastValidPrice</code> is current.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/","title":"SCWE-029: Lack of Decentralized Oracle Sources","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#description","title":"Description","text":"<p>Lack of decentralized oracle sources refers to the reliance on a single oracle for critical data, which can be manipulated or compromised. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#remediation","title":"Remediation","text":"<ul> <li>Use multiple oracles: Leverage multiple decentralized oracles for critical data.</li> <li>Validate inputs: Ensure all oracle data is properly validated before use.</li> <li>Implement fallback mechanisms: Use fallback oracles in case of failure.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#examples","title":"Examples","text":"<ul> <li>Single Oracle Source/ Single Point of Failure <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract SingleOracle {\n    Oracle public priceOracle;\n\n    constructor(address _oracle) {\n        priceOracle = Oracle(_oracle);\n    }\n\n    function getPrice() public view returns (uint) {\n        return priceOracle.getPrice(); // Single source of truth\n    }\n}\n</code></pre></li> </ul> <p>Why is this vulnerable? - If the oracle fails, is compromised, or is manipulated, the contract has no fallback. - Attackers could hijack the single oracle and return malicious data.</p> <ul> <li>Decentralized Oracle Sources- Using Multiple Oracles &amp; Fallbacks <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract MultiOracle {\n    Oracle[] public priceOracles;\n\n    constructor(address[] memory _oracles) {\n        for (uint i = 0; i &lt; _oracles.length; i++) {\n            priceOracles.push(Oracle(_oracles[i]));\n        }\n    }\n\n    function getPrice() public view returns (uint) {\n        uint totalPrice = 0;\n        for (uint i = 0; i &lt; priceOracles.length; i++) {\n            totalPrice += priceOracles[i].getPrice();\n        }\n        return totalPrice / priceOracles.length; // Averaging multiple oracles\n    }\n}\n</code></pre> Fixes:</li> <li>Uses multiple oracles and computes an average to prevent manipulation.</li> <li>If one oracle fails or gets compromised, the contract still functions correctly.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/","title":"SCWE-030: Insecure Oracle Data Updates","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#description","title":"Description","text":"<p>Insecure oracle data updates refer to the failure to properly validate or secure updates to oracle data. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#remediation","title":"Remediation","text":"<ul> <li>Validate updates: Ensure all oracle data updates are properly validated.</li> <li>Restrict access: Restrict update permissions to trusted addresses.</li> <li>Implement timelocks: Add delays to oracle updates to allow for review.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#examples","title":"Examples","text":"<ul> <li> <p>Insecure Oracle Updates <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureOracleUpdates {\n    function updatePrice(address oracle, uint newPrice) public {\n        Oracle(oracle).updatePrice(newPrice); // No validation\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Oracle Updates <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureOracleUpdates {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\");\n        _;\n    }\n\n    function updatePrice(address oracle, uint newPrice) public onlyAdmin {\n        Oracle(oracle).updatePrice(newPrice); // Restricted to admin\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/","title":"SCWE-085: Misuse of Oracle Min/Max Price Band Without Validation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity</li> <li>CWE-20:  Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#description","title":"Description","text":"<p>This weakness occurs when smart contracts consume price oracle data (e.g., from Chainlink) without verifying whether the returned price falls within an expected or trusted range (e.g., <code>minPrice</code>/<code>maxPrice</code>). Oracles may return fallback floor or ceiling values when actual prices exceed internal limits or when the feed encounters data instability.</p> <p>Failing to detect and reject such edge-case values can result in incorrect or exploitable logic paths in smart contracts. This weakness may allow attackers to:</p> <ul> <li>Trigger mispriced swaps or asset conversions.</li> <li>Exploit collateralization thresholds.</li> <li>Manipulate auction pricing or tiered reward structures.</li> <li>Influence governance systems based on price weightings.</li> </ul> <p>These issues are especially dangerous during periods of high volatility or partial oracle outages, where fallback values may be automatically returned.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#remediation","title":"Remediation","text":"<p>To mitigate this risk:</p> <ul> <li>Always verify that the oracle-provided price lies within an expected range.</li> <li>Check whether the returned value is a fallback boundary by comparing it against known <code>minPrice</code>/<code>maxPrice</code> values.</li> <li>Monitor and log unusual oracle values for off-chain alerts and incident response.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#example","title":"Example","text":"<ul> <li>Vulnerable contract </li> </ul> <p><pre><code>(int256 price,,,) = AggregatorV3Interface(oracle).latestRoundData();\n\n// Uses price directly without checking for boundary values\nuint256 tokenAmount = uint256(price) * userInput;\n</code></pre> - Fixed Contract </p> <p><pre><code>(int256 price,,,) = AggregatorV3Interface(oracle).latestRoundData();\n\n// Validate that the price is within trusted bounds\nrequire(price &gt; minPrice &amp;&amp; price &lt; maxPrice, \"Price out of expected bounds\");\n\nuint256 tokenAmount = uint256(price) * userInput;\n</code></pre> This ensures that the contract rejects unexpected oracle values that might be returned during errors or manipulation attempts.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#references","title":"References","text":"<ul> <li>Chainlink Docs: Chainlink Price Feeds Documentation</li> <li>CWE-345: Insufficient Verification of Data Authenticity</li> <li>CWE-20:  Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/","title":"SCWE-086: Missing Validation of Oracle Response Fields (Stale or Incomplete Data)","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity</li> <li>CWE-20:  Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#description","title":"Description","text":"<p>This weakness occurs when smart contracts consume data from oracles (e.g., Chainlink) without validating critical fields in the response such as <code>answeredInRound</code>, <code>timestamp</code>, or even the <code>answer</code> itself. Failing to validate these fields can lead to:</p> <ul> <li>Use of stale price data from old oracle rounds.</li> <li>Acceptance of incomplete oracle responses (e.g., <code>timestamp == 0</code>).</li> <li>Execution based on invalid or zero-priced data.</li> </ul> <p>This can severely affect the security of DeFi protocols or any smart contract relying on accurate, fresh data feeds.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#remediation","title":"Remediation","text":"<ul> <li>Validate <code>answer</code> field: Ensure the value returned is greater than zero and not malformed.</li> <li>Check <code>answeredInRound &gt;= roundId</code>: Confirms that the data is not from a stale round.</li> <li>Verify <code>timestamp != 0</code>: Ensures that the oracle actually returned a complete result.</li> </ul> <p>Additional best practices include: - Using fallback mechanisms or thresholds for deviation checks. - Halting sensitive functions if oracle data is suspect or missing.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#examples","title":"Examples","text":"<ul> <li> <p>\u274c Vulnerable Code (No Response Validation) <pre><code>(, int256 answer,,,) = AggregatorV3Interface(oracle).latestRoundData();\nrequire(uint256(answer) &gt; 0, \"Zero price\"); // Minimal check only\n</code></pre></p> </li> <li> <p>\u2705 Secure Code (With Full Oracle Validation) <pre><code>(uint80 roundID, int256 answer,, uint256 timestamp, uint80 answeredInRound) = \n    AggregatorV3Interface(oracle).latestRoundData();\n\nrequire(answer &gt; 0, \"Invalid price: &lt;= 0\");\nrequire(answeredInRound &gt;= roundID, \"Stale round data\");\nrequire(timestamp != 0, \"Incomplete oracle response\");\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#references","title":"References","text":"<ul> <li>Chainlink Oracle Security Best Practices</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/","title":"SCWE-088: Improper Decimal Normalization in Price-Based Calculations","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#relationships","title":"Relationships","text":"<ul> <li>CWE-681:  Incorrect Conversion between Numeric Types</li> <li>CWE-682:  Incorrect Calculation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#description","title":"Description","text":"<p>This issue arises when smart contracts perform arithmetic involving token values and price feeds without properly aligning decimal places across different sources (e.g. ERC-20 tokens with varying decimals and Chainlink oracles with fixed 8-decimal prices). Failing to normalize decimals before calculations can lead to severely inflated or deflated results, causing users to be overcharged, underpaid, or otherwise economically exploited.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#impact","title":"Impact","text":"<p>Smart contracts often rely on cross-asset conversions, such as paying fees in tokens or using collateralization logic involving price feeds. Improper decimal handling in these calculations may: - Lead to gross overcharging or underpayment. - Introduce systemic financial imbalances in vaults or accounting logic. - Enable economic exploits by arbitraging rounding errors or precision gaps. - Remain undetected during tests if decimals coincidentally align. This issue is especially critical when: - ERC-20 tokens with non-18 decimals (e.g., USDC = 6) are involved. - Chainlink oracles return 8-decimal fixed-point prices. - Arithmetic mixes native ETH values (in 18 decimals) with token values or prices.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#remediation","title":"Remediation","text":"<ul> <li>Always normalize decimals across all involved assets and feeds.</li> <li>Use centralized utility functions for all price/token conversions.</li> <li>Add sanity checks to detect outlier results (e.g., revert if output is &gt;1000x expected range).</li> <li>When possible, emit intermediate calculation steps for auditing.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#examples","title":"Examples","text":"<ul> <li> <p>\u274c Vulnerable Code (Missing Decimal Normalization) <pre><code>// Assume ETH/USD = 3000e8 (8 decimals), Token/USD = 1e8, and token has 6 decimals\nuint256 tokenAmount = (ethAmountInWei * ethPriceInUsd) / tokenPriceInUsd;\n// Result is in 18-decimal scale, not adjusted for the 6-decimal USDC token\n</code></pre></p> </li> <li> <p>\u2705 Safe Code (With Proper Decimal Alignment) <pre><code>uint8 tokenDecimals = IERC20(token).decimals();\n\nuint256 rawAmount = (ethAmountInWei * ethPriceInUsd) / tokenPriceInUsd;\nuint256 adjustedAmount = rawAmount / (10 ** (18 - tokenDecimals));\n// Now 'adjustedAmount' is in correct units for the target token\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#realistic-exploit-example","title":"Realistic Exploit Example","text":"<p>Assumptions:</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#registrar-fee-001-eth-1e16-wei-ethusd-price-3000-1e8-300000000000-usdcusd-price-1-1e8-100000000-usdc-has-6-decimals-faulty-calculation-result-1e16-300000000000-100000000-3e19-return-result-1e6-3e13-30-trillion-base-units-30-million-usdc-expected-001-eth-3000-30-30-1e6-30000000-usdc-units-overcharge-actual-charged-30000000-usdc-expected-30-usdc-overcharge-999900x","title":"<pre><code>Registrar fee = 0.01 ETH = 1e16 wei\n\nETH/USD price = 3000 * 1e8 = 300000000000\n\nUSDC/USD price = 1 * 1e8 = 100000000\n\nUSDC has 6 decimals\n\nFaulty Calculation:\n\nresult = (1e16 * 300000000000) / 100000000 = 3e19\nreturn result / 1e6 = 3e13 (30 trillion base units = 30 million USDC)\nExpected:\n\n0.01 ETH * $3,000 = $30\n\u2192 30 * 1e6 = 30,000,000 USDC units\n\nOvercharge:\n\nActual charged: 30,000,000 USDC\nExpected: 30 USDC\nOvercharge: 999,900x\n</code></pre>","text":"","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/","title":"SCWE-112: Reliance on Low-Liquidity Spot Prices","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/#relationships","title":"Relationships","text":"<ul> <li>CWE-346: Origin Validation Error https://cwe.mitre.org/data/definitions/346.html</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/#description","title":"Description","text":"<p>Using a single on-chain DEX spot price from an illiquid pool lets attackers move the price with small trades or flash loans, then exploit inflated/deflated valuations for lending, liquidations, or swaps.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/#remediation","title":"Remediation","text":"<ul> <li>Require minimum liquidity thresholds and sanity bounds before trusting a pool.</li> <li>Use robust oracles (Chainlink, TWAP, median of multiple feeds) instead of raw spot prices.</li> <li>Apply deviation checks against reference feeds and revert when deviation exceeds limits.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Lending {\n    IUniswapV2Pair public pair;\n\n    function getPrice() public view returns (uint256) {\n        (uint112 r0, uint112 r1,) = pair.getReserves();\n        return uint256(r1) * 1e18 / r0; // trusts small pool\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-112/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Lending {\n    IAggregatorV3 public chainlink;\n\n    function getPrice() public view returns (uint256) {\n        (, int256 price,,,) = chainlink.latestRoundData();\n        require(price &gt; 0, \"stale\");\n        return uint256(price);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/","title":"SCWE-113: Insufficient TWAP Window or Single Observation","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/#relationships","title":"Relationships","text":"<ul> <li>CWE-346: Origin Validation Error https://cwe.mitre.org/data/definitions/346.html</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/#description","title":"Description","text":"<p>TWAP oracles that use very short windows or a single cumulative observation can be manipulated within a block or a few trades. Attackers can swing the average price temporarily to borrow, liquidate, or mint at a favorable rate.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/#remediation","title":"Remediation","text":"<ul> <li>Use sufficiently long averaging windows and multiple observations with minimum elapsed time.</li> <li>Enforce maximum per-block updates to prevent same-block manipulation.</li> <li>Cross-check TWAP output against external reference feeds or deviation thresholds.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/#vulnerable","title":"Vulnerable","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface IUniswapV3Pool {\n    function observe(uint32[] calldata secondsAgos)\n        external view returns (int56[] memory tickCumulatives, uint160[] memory);\n}\n\ncontract PriceFeed {\n    IUniswapV3Pool public pool;\n\n    function twap() external view returns (int56) {\n        uint32[] memory secondsAgos = new uint32[](1);\n        secondsAgos[0] = 0; // single observation at current block \u2014 manipulatable in same block\n        (int56[] memory tickCumulatives,) = pool.observe(secondsAgos);\n        return tickCumulatives[0];\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-113/#fixed","title":"Fixed","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface IUniswapV3Pool {\n    function observe(uint32[] calldata secondsAgos)\n        external view returns (int56[] memory tickCumulatives, uint160[] memory);\n}\n\ncontract PriceFeed {\n    IUniswapV3Pool public pool;\n    uint32 public constant TWAP_WINDOW = 1 hours;\n\n    function twap() external view returns (int24) {\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = TWAP_WINDOW; // start of window\n        secondsAgos[1] = 0;           // current block\n        (int56[] memory tickCumulatives,) = pool.observe(secondsAgos);\n        int56 tickDelta = tickCumulatives[1] - tickCumulatives[0];\n        return int24(tickDelta / int56(uint56(TWAP_WINDOW)));\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/","title":"SCWE-130: Admin-Write Oracle Without Delay","text":"Stable Version v1.0 <p>This content is in the version-(v1.0) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/#relationships","title":"Relationships","text":"<ul> <li>CWE-346: Origin Validation Error https://cwe.mitre.org/data/definitions/346.html</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/#description","title":"Description","text":"<p>Price feeds that allow an admin to push arbitrary values immediately (no delay or quorum) let insiders force liquidations, manipulate collateralization, or drain AMMs. Even trusted operators can be compromised.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/#remediation","title":"Remediation","text":"<ul> <li>Require multi-sig + timelock for manual price pushes; emit events for monitoring.</li> <li>Use decentralized oracles with aggregation/quorum instead of single-writer feeds.</li> <li>Enforce bounds/deviation checks against reference feeds and reject outliers.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/#vulnerable","title":"Vulnerable","text":"<pre><code>function setPrice(uint256 p) external onlyOwner {\n    price = p; // immediate effect\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-130/#fixed","title":"Fixed","text":"<pre><code>function queuePrice(uint256 p) external onlyGuardian {\n    queued = Price({val:p, eta:block.timestamp + delay});\n}\nfunction execute() external {\n    require(block.timestamp &gt;= queued.eta, \"too early\");\n    price = queued.val;\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"contributing/1_How_Can_You_Contribute/","title":"How Can You Contribute?","text":"<p>You can directly contribute to the SCSVS or SCSTG in many different ways! First, go ahead and create a GitHub account for free on the GitHub homepage.</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#contribution-flow","title":"Contribution Flow","text":"<pre><code>flowchart LR\n    A(Open Discussion) --&gt;|discuss| C{qualifies?}\n    C --&gt;|Yes| D(Issue)\n    C --&gt;|No| E[Close]\n    D --&gt;|open PR| F(Pull Request)\n    F --&gt;|review| G{approved?}\n    F --&gt;|make changes| F\n    G --&gt;|Yes| H[Merge]\n    G --&gt;|No| I[Close]</code></pre>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#participate-in-discussions","title":"\ud83d\udcac Participate in Discussions","text":"<p>Our GitHub Discussions are the first place to go to ask questions, give feedback, and propose new ideas. If your proposal qualifies for the SCSTG/SCSVS, we'll convert it into an \"Issue\" (the discussion might take a while).</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#create-issues","title":"\ud83c\udfaf Create Issues","text":"<p>Before creating a PR, first create an Issue to be discussed for missing requirements, content or errors.</p> <ul> <li>To avoid multiple people duplicating effort on the same issue, project leaders will assign it to only a few that will own it.</li> <li>Explain what you think is missing in the issue, including references (if available) and suggest where it could be added.</li> </ul>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#open-a-pull-request","title":"\ud83d\udcdd Open a Pull Request","text":"<p>You can contribute with content or corrections by opening a Pull Request (PR).</p> <ul> <li>Your PR may be merged after review.</li> <li>Be sure to follow our style guide when writing content.</li> </ul> <p>Learn how to open a PR here.</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#become-a-reviewer","title":"\u2705 Become a Reviewer","text":"<p>You can Review Pull Requests (PRs) and also gain contributions. If you are a fluent speaker in any of the different languages that the SCSVS is available in, feel free to give feedback on any of the submitted PRs.</p> <p>After your PR or issue has been submitted, we will review it as quickly as possible which typically only takes a few days. If you think we have forgotten about it, feel free to give us a nudge after 7 days have passed.</p> <p>Learn how to review a PR here.</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#proof-reading","title":"\ud83d\udd0e Proof-reading","text":"<p>If you do proof-reading, these are the things we\u2019re looking for:</p> <ul> <li>Content cohesion &amp; coherence<ul> <li>is there a good linkage of ideas?</li> <li>does the paragraph make sense?</li> <li>does it make sense with the next one? Think that hundreds of people have written in here, often without considering the surroundings of the text they were including.</li> </ul> </li> <li>Reducing the content to a minimum (people tend to be very verbose/wordy) and in such a document we need clear and short/concise statements</li> <li>Optimize for scannability (maybe instead of a big paragraph it would be better to have a bullet point list).</li> <li>Any passive voice sentences? Convert to active voice.</li> <li>Does each paragraph focus on a single topic?</li> <li>Are key points stated at the start of each section?</li> <li>Are commas, parentheses, colons, em-dashes, and semicolons used properly?</li> </ul> <p>Refer to Google Technical Writing trainings for more info:</p> <ul> <li>Google Technical Writing One</li> <li>Google Technical Writing Two</li> </ul>","tags":[]},{"location":"contributing/2_Getting_Started/","title":"Getting Started","text":"<p>First of all Create a GitHub account (a free one is enough) by following these steps.</p> <p>Our workflow is like this:</p> <ol> <li>Open a Discussion (for ideas and proposals) If your proposal qualifies for the SCSTG/SCSVS we'll convert it into an \"Issue\" (the discussion might take a while).</li> <li>SCSVS Example: \"Add a SCSVS-CODE requirement on Key rotation\"</li> <li> <p>SCSTG Example: \"Add a Test case for key rotation\"</p> </li> <li> <p>Open an Issue (for concrete actionable things that have to / could be done) For instance, there's a typo, or it's clear that a certain Test case doesn't have e.g. \"Dynamic Analysis\" and it should be added.</p> </li> <li>Open a PR (to add actual content) This could be the fix for the mentioned typo, a whole new section or some other content. Usually a PR has a \"closes\" sentence in its description. For example \"Closes #543\" so that we (and GitHub) know which Issue(s) is being addressed on that PR.</li> </ol> <p>Normally, contributors should follow the whole flow. But sometimes it's clear what's needed so we directly go to 2 (open an issue) or even to 3 (open a PR). We recommend starting with a discussion or directly contacting us to save you the hurdle of writing and submitting new content that does not qualify so we have to reject it after the work is done.</p> <p>If you just have an specific question you can post it to (you need a GitHub Account):</p> <ul> <li>https://github.com/OWASP/www-project-smart-contract-security-verification-standard/discussions/categories/q-a</li> <li>https://github.com/OWASP/www-project-smart-contract-security-testing-guide/discussions/categories/q-a</li> </ul> <p>\"GitHub Discussions\" are re-posted to our Slack channel.</p> <p>Once you get your answer please mark it as answered. When you mark a question as an answer, GitHub will highlight the comment and replies to the comment to help visitors quickly find the answer.</p>","tags":[]},{"location":"contributing/2_Getting_Started/#contribute-online","title":"Contribute Online","text":"<p>GitHub makes this extremely easy.</p> <p>For small changes in one file:</p> <ol> <li>Go to the file you'd like to modify and click on \"Edit\".</li> <li>Do your changes and commit them. GitHub will guide you and suggest to open a Pull Request.</li> </ol> <p>For more complex changes or across files:</p> <ol> <li>Press <code>.</code> while browsing the repo or pull request.</li> <li>You'll be welcomed with a \"github.dev Web-based Editor\" where you can work using an online Visual Studio.</li> <li>Do your changes, commit and push them as you'd do locally.</li> </ol> <p></p> <p>Learn more about the github.dev Web-based Editor in \"GitHub Docs\".</p>","tags":[]},{"location":"contributing/2_Getting_Started/#contribute-offline","title":"Contribute Offline","text":"<p>For this you need an IDE or text editor and git on your machine. We recommend using the free Visual Studio Code editor with the markdownlint extension.</p> <ol> <li>Fork the repo. Forking the repo allows you to make your changes without affecting the original project until you're ready to merge them.</li> <li> <p>Clone your fork repo and add the remote upstream repo, e.g. for www-project-smart-contract-security-verification-standard:</p> <pre><code>$ git clone https://github.com/&lt;your_github_user&gt;/www-project-smart-contract-security-verification-standard.git\n$ cd www-project-smart-contract-security-verification-standard/\n$ git remote add upstream git@github.com:OWASP/www-project-smart-contract-security-verification-standard.git\n</code></pre> </li> <li> <p>Create a branch.</p> <pre><code>$ git checkout -b fix-issue-1456\n</code></pre> </li> <li> <p>Make your changes.</p> </li> <li>Commit and push your changes. This can be done by executing the command <code>git add MYFILE</code> for every file you have modified, followed by <code>git commit -m 'Your Commit Message'</code> to commit the modifications and <code>git push</code> to push your modifications to GitHub.</li> <li>Open a PR.</li> </ol>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/","title":"Pull Requests &amp; Reviews","text":"","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#how-to-open-a-pr","title":"How to Open a PR","text":"<p>You can create a Pull Request (PR) by following these steps. Remember that:</p> <ul> <li>The target branch should be <code>master</code>.</li> <li>If your PR closes and issue, write \"Closes <code>#&lt;issue-id&gt;</code>\".</li> </ul> <p>Your PR will be reviewed soon (refer to this page to learn more about reviews).</p> <p>Before opening a PR please self-review your changes in GitHub and ensure that you follow our style guide to speed up the review process\u26a1</p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#how-to-incorporate-the-reviewers-feedback-to-your-pr","title":"How to Incorporate the Reviewer's Feedback to your PR","text":"<p>It might be directly approved and merged or one of our reviewers will send you some comments and suggested changes.</p> <p>When reviewers suggest changes in a pull request, you can automatically incorporate the changes into your PR.</p> <ul> <li>Apply any Suggested Changes using the \"Commit suggestions\" button.</li> <li>In order to process a comment, simply make modifications directly to your branch and push normally. GitHub will automatically detect these changes and add them to your existing PR.</li> <li>As you update your PR and apply changes, mark each conversation as resolved.</li> <li>If you run into any merge issues, refer to this page to learn how to resolve them.</li> </ul> <p>NOTE: Remember to regularly sync your fork with the upstream repo: <code>git pull upstream/master</code></p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#how-to-review-a-pr","title":"How to Review a PR","text":"<p>If you'd like to review an open PR please follow these steps:</p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#step-1-comment-and-suggest-changes","title":"Step 1: Comment and Suggest Changes","text":"<p>You can enter single or multi-line comments (click and drag to select the range of lines):</p> <p></p> <p>Always prefer making \"Suggested Changes\" using the <code>\u00b1</code> button:</p> <p></p> <p>If the suggestion you'd like to make cannot be expressed using \"suggested changes\" please enter a clear comment explaining what should be fixed (e.g. some paragraphs don't link properly or some essential information cannot be found and should be added).</p> <p>Using \"Suggested Changes\" saves you as a reviewer and the PR author a lot of time. And you get points (attributions) for the changes that you suggested (if the author commits them you become a co-author of those commits). If you're constant with your reviewer work you can apply to be recognize as an official reviewer in our Acknowledgements page.</p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#step-2-submit-your-review","title":"Step 2: Submit your Review","text":"<p>Once you went through the whole PR you can submit your review</p> <ol> <li>Click on \"Review changes\".</li> <li>Enter a comment for the contributor.</li> <li>Select the type of review you'd like to leave (Comment, Approve or Request Changes).</li> <li>Click on \"Submit review\".</li> </ol> <p>Learn more: \"(GitHub Docs) Reviewing proposed changes in a pull request\".</p>","tags":[]},{"location":"contributing/4_Add_new_Language/","title":"Add a New Language","text":"","tags":[]},{"location":"contributing/4_Add_new_Language/#scstg-translations","title":"SCSTG Translations","text":"<p>The SCSTG is a living document that changes and adapts to the most recent security recommendations every day. While we do want to reach the maximum audience possible, our past experience shows that maintaining translations has proven to be an extremely challenging task. Therefore, please understand that any PRs containing SCSTG translations will be declined, but you're free to do them on your own forks.</p>","tags":[]},{"location":"contributing/4_Add_new_Language/#scsvs-translations","title":"SCSVS Translations","text":"","tags":[]},{"location":"contributing/5_Style_Guide/","title":"Style Guide","text":"<p>The following rules are meant to ensure consistency of the SCSTG:</p> <ol> <li>Keep the content factual, brief and focused. Avoid duplicating other sections of the guide;</li> <li>Refrain from advertising commercial tools or services;</li> <li>When giving technical instructions, address the reader in the second person.</li> </ol> <p>Technical Writing</p> <p>We recommend you to take these free Google courses when writing or reviewing content for the SCS project:</p> <ul> <li>Technical Writing One</li> <li>Technical Writing Two</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#1-how-to-write-content","title":"1. How to Write Content","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#amount-of-content","title":"Amount of Content","text":"<p>The primary measure for amount of content on a page should be based on the purpose it serves.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#use-short-pages","title":"Use short pages","text":"<p>Those containing one or two screens of text at most. Users are scanning for link choices. Use longer pages (those that require more scrolling or reading) deeper within the chapter where content can be printed and read later.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#for-very-large-sections-of-information","title":"For very large sections of information","text":"<p>Consider creating a supporting document and linking to it from the page rather than displaying all the information directly on the page.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#gender-neutrality","title":"Gender Neutrality","text":"<p>The SCSTG reaches all kind of people all over the world. To ensure inclusiveness and diversity, please refrain from using the following throughout the book:</p> <ul> <li>she / her / hers / herself</li> <li>he / him / his / himself</li> </ul> <p>Or any other constructions like \"he/she\", \"s/he\", \"his or her\". Instead, use the following gender-neutral alternatives:</p> <ul> <li>Omit the pronoun if possible: \"The user authenticates himself using ...\" -&gt; \"The user authenticates using ...\"</li> <li>Replace pronouns with \"the or \"a\": \"When the user enters his password ...\" -&gt; \"When the user enters the password ...\"</li> <li>Use plural nouns and pronouns: \"An attacker will use his jailbroken device ...\" -&gt; \"Attackers will use their jailbroken devices ...\"</li> <li>Use the second person: \"If the attacker runs this code, he can bypass ...\" -&gt; \"If you run this code, you can bypass ...\"</li> <li>Use the imperative: \"A developer should never use ... in his code\" -&gt; \"Never use ... in your code!\"</li> </ul> <p>There is one exception: We are still using \"man in the middle\", as it is simply a common term in the industry and there is no common replacement for it.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#timeliness-of-content","title":"Timeliness of Content","text":"<p>Keeping accurate and timely content establishes the OWASP SCS deliverables as a credible and trustworthy source of information.</p> <p>When using statistical data on your page, ensure that the information is current and up-to-date and is accompanied by the source from which it was derived, along with the date the data was compiled.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#content-for-the-digital-platform-versus-for-print","title":"Content for the Digital Platform Versus for Print","text":"<p>Write concise content that the user can read quickly and efficiently. For digital content - create shorter pages that are cross-linked. If your content is likely to be printed, create one long page.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#audience","title":"Audience","text":"<p>Write for an international audience with a basic level of technical understanding i.e. they have a mobile phone and know how to install an app. Avoid hard-to-translate slang words/phrases to ensure content is accessible to readers who aren't native English speakers.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#context-and-orientation","title":"Context and Orientation","text":"<p>Let the users know where they are on every page. Establish the topic by using a unique page heading.</p> <p>Include a clear and concise introduction where possible.</p> <p>Link to background information where necessary.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#write-so-people-will-read-with-joy","title":"Write so People Will Read with Joy","text":"<p>Use the following methods to increase scannability:</p> <ul> <li>Use left alignment for headings, subheadings, and text</li> <li>Link where appropriate</li> <li>Use lists rather than paragraphs wherever possible</li> <li>Use dashes <code>-</code> rather than asterisks <code>*</code> for lists</li> <li>Include only one main idea in each paragraph</li> <li>Put the most important information at the top</li> <li>Start the page with the conclusion as well as a short summary of the remaining content</li> <li>Use headings where applicable</li> <li>Use short, simple words that are to the point</li> <li>Be concise and focused</li> </ul> <p>For longer pages, use the following tools to make the page easily scannable:</p> <ul> <li>Anchor links</li> <li>Subheadings and relevant links</li> <li>Bulleted copy</li> <li>Meaningful graphics, or pull quotes, to break up larger blocks of text</li> <li>End links</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#effective-use-of-lists","title":"Effective Use of Lists","text":"<p>When presenting your content in a list format:</p> <ul> <li>Use numbered lists when the order of entries is important.</li> <li>Use bulleted lists whenever the order of the entries is not important.</li> <li>Generally, limit the number of items in a single list to no more than nine.</li> <li>Generally, limit lists to no more than two levels: primary and secondary.</li> <li>Punctuate and capitalize list items consistently (CMOS 6.124-6.126).</li> <li>Don't add end punctuation to list items that are not complete sentences unless they complete the sentence that introduces the list.</li> <li>Use appropriate capitalization and end punctuation for list items that individually form complete sentences.</li> <li>If the list items complete an introductory sentence, end each (except the last item) with a comma and do not add \"and\" after the second-to-last item. End the last item with appropriate end punctuation (usu. a period).</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#numbering-conventions","title":"Numbering Conventions","text":"<p>When using a number between zero and ten, spell out the number (e.g., \"three\" or \"ten\").</p> <p>When using any number higher than ten, use the numeric version (e.g., \"12\" or \"300\").</p>","tags":[]},{"location":"contributing/5_Style_Guide/#2-language","title":"2. Language","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#american-spelling-and-terminology","title":"American Spelling and Terminology","text":"<p>Use American spelling and terminology.</p> <p>Change all British spelling and terminology to the American equivalents where applicable. This includes \"toward\" (US) vs. \"towards\" (UK), \"among\" (US) vs. \"amongst\" (UK), \"analyze\" (US) vs. \"analyse\" (UK), \"behavior\" (US) vs \"behaviour\" (UK), etc.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#plurals","title":"Plurals","text":"<p>Adhere to standard grammar and punctuation rules when it comes to pluralization of typical words.</p> <p>The plural of calendar years does not take the apostrophe before the \"s\". For example, the plural form of 1990 is 1990s.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#title-capitalization","title":"Title Capitalization","text":"<p>We follow the title case rules from the \"Chicago Manual of Style\":  </p> <ul> <li>Capitalize the first and last word in a title, regardless of part of speech</li> <li>Capitalize all nouns (app, encryption, package), pronouns (you, she, it), verbs (analyze, compile, inspect), adjectives (active, insecure, weak), adverbs (immediately, quietly), and subordinating conjunctions (as, because, although)</li> <li>Lowercase \"to\" as part of an infinitive</li> <li>Lowercase all articles (a, the), prepositions (to, at, in, with), and coordinating conjunctions (and, but, or)</li> </ul> <p>When in doubt, you can verify proper capitalization on https://titlecaseconverter.com/.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#standardization","title":"Standardization","text":"<p>This is a list of words/abbreviations that are used inconsistently at the moment in the SCSTG and need standardization:</p> <ul> <li>man-in-the-middle attack (MITM)</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#contractions","title":"Contractions","text":"<p>Use the following common contractions:</p> <ul> <li>are not -&gt; aren't  </li> <li>cannot -&gt; can't  </li> <li>could not -&gt; couldn't  </li> <li>did not -&gt; didn't  </li> <li>do not -&gt; don't  </li> <li>does not -&gt; doesn't  </li> <li>has not -&gt; hasn't  </li> <li>had not -&gt; hadn't  </li> <li>have not -&gt; haven't</li> <li>is not -&gt; isn't</li> <li>it is -&gt; it's</li> <li>that is -&gt; that's  </li> <li>there is -&gt; there's  </li> <li>was not -&gt; wasn't  </li> <li>were not -&gt; weren't  </li> <li>will not -&gt; won't  </li> <li>would not -&gt; wouldn't  </li> <li>you are -&gt; you're  </li> <li>you have + verb -&gt; you've + verb</li> <li>you will -&gt; you'll  </li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#abbreviations","title":"Abbreviations","text":"<p>Abbreviations include acronyms, initialisms, shortened words, and contractions.</p> <ul> <li>Spell out the term the first time it's used, followed by the abbreviation in parentheses. Example: OWASP Smart Contract Security Testing Guide (SCSTG). Subsequent usages in the same chapter may include the abbreviation only.</li> <li>If it only appears once in the content, spell out the term instead of using the abbreviation.</li> <li>In titles and headings, use the abbreviation but be sure to properly introduce it (see above) in the text that follows.</li> <li>Use \"a\" or \"an\" depending on the pronunciation of the acronym. Example: a DLL, an APK, a URL, a SQL.</li> <li>Add an \"s\" for the plural form unless the abbreviation already stands for a plural noun. Example: the APIs, CSS (not CSSs).</li> <li>If the abbreviation is better known as its full spelled-out term, use only the abbreviation. Example: PDF, URL, USB, ZIP.</li> </ul> <p>The following snippet demonstrates most of these points:</p> <pre><code>## JAR Files\n\nJAR (Java ARchive) files are [...]\n\nAPKs are packed using the ZIP format. An APK is a variation of a JAR file [...]\n</code></pre> <p>For commonly used file formats such as APK, IPA or ZIP, please do not refer to them as \".apk\", \".ipa\" or \".zip\" unless you're explicitly referring to the file extension.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#referencing-android-versions","title":"Referencing Android versions","text":"<p>Use the following format when referring to an Android version: Android X (API level YY). Usage of the descriptive name (Ex: Oreo) is discouraged.</p> <p>Ex: Android 9 (API level 28)</p>","tags":[]},{"location":"contributing/5_Style_Guide/#addressing-the-reader-in-test-cases","title":"Addressing the Reader in Test Cases","text":"<p>Throughout the guide, you may want to address the readers in order to tell them what to do, or what they should notice. For any such case, use an active approach and simply address the reader using \"you\".</p> <p>Correct: If you open the AndroidManifest.xml file, you will see a main Application tag, with the following attributes: atr1, atr2 and atr3. If you run the following command, you will see that atr1 is actually dangerous: [...].</p> <p>Wrong: The AndroidManifest.xml file contains an Application tag, with the following attributes: atr1, atr2 and atr3. The command below shows that atr1 is dangerous: [...].</p> <p>Wrong: If we open the AndroidManifest.xml file, we will see a main Application tag, with the following attributes: atr1, atr2 and atr3. If we run the following command, we will see that atr1 is actually dangerous: [...].</p>","tags":[]},{"location":"contributing/5_Style_Guide/#3-external-references","title":"3. External References","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#web-links","title":"Web Links","text":"<p>Use markdown's in-line link format (A) <code>[TEXT](URL \"TITLE\")</code> or (B) <code>[TEXT](URL)</code>.</p> <p>For example:</p> <pre><code>The [threat modeling guidelines defined by OWASP](https://owasp.org/www-community/Threat_Modeling \"OWASP Threat Modeling\") are generally applicable to smart contracts.\n</code></pre> <p>When using (A), be sure to escape special characters such as apostrophe (\\') or single quote (`), as otherwise the link will be broken in Gitbook.</p> <p>Wrong usage, see \"iPhone's\":</p> <pre><code>[UDID of your iOS device via iTunes](https://medium.com/@igor_marques/how-to-find-an-iphones-udid-2d157f1cf2b9 \"How to Find Your iPhone's UDID\")\n</code></pre> <p>Right usage, see \"iPhone\\'s\":</p> <pre><code>[UDID of your iOS device via iTunes](https://medium.com/@igor_marques/how-to-find-an-iphones-udid-2d157f1cf2b9 \"How to Find Your iPhone\\'s UDID\")\n</code></pre> <p>When adding links to the \"References\" section at the end of the chapters use <code>- Title - &lt;url&gt;</code>. This is needed to force latex to print URLs properly for the PDF.</p> <p>For example:</p> <pre><code>- adb - &lt;https://developer.android.com/studio/command-line/adb&gt;\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#books-and-papers","title":"Books and Papers","text":"<p>For books and papers, use the following format: <code>[#NAME]</code>.</p> <p>And include the full reference in the \"References\" section at the end of the markdown file manually. Example:</p> <pre><code>An obfuscated encryption algorithm can generate its key (or part of the key)\nusing data collected from the environment [#riordan].\n</code></pre> <p>And under the \"References\" section at the end of the chapters:</p> <pre><code>- [#riordan] -  James Riordan, Bruce Schneier. Environmental Key Generation towards Clueless Agents. Mobile Agents and Security, Springer Verlag, 1998\n</code></pre> <p>Papers:</p> <p>The general form for citing technical reports is to place the name and location of the company or institution after the author and title and to give the report number and date at the end of the reference.</p> <p>Basic Format:</p> <pre><code>- [shortname] J. K. Author, \"Title of report,\" Abbrev. Name of Co., City of Co., Abbrev. State, Rep. xxx, year\n\n- [shortname] \\[Author(s)\\], \\[Title\\] - Link\n</code></pre> <p>Books:</p> <pre><code>- [shortname] \\[Author(s)\\], \\[Title\\], \\[Published\\], \\[Year\\]\n\n- [examplebook] J. K. Author, \"Title of chapter in the book,\" in Title of His Published Book, xth ed. City of Publisher, Country if not USA: Abbrev. of Publisher, year, ch. x, sec. x, pp. xxx-xxx.\n</code></pre> <p>NOTE: Use et al. when three or more names are given</p> <p>e.g.</p> <pre><code>- [klaus] B. Klaus and P. Horn, Robot Vision. Cambridge, MA: MIT Press, 1986.\n- [stein] L. Stein, \"Random patterns,\" in Computers and You, J. S. Brake, Ed. New York: Wiley, 1994, pp. 55-70.\n- [myer] R. L. Myer, \"Parametric oscillators and nonlinear materials,\" in Nonlinear Optics, vol. 4, P. G. Harper and B. S. Wherret, Eds. San Francisco, CA: Academic, 1977, pp. 47-160.\n- [abramowitz] M. Abramowitz and I. A. Stegun, Eds., Handbook of Mathematical Functions (Applied Mathematics Series 55). Washington, DC: NBS, 1964, pp. 32-33.\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#4-references-within-the-guide","title":"4. References Within The Guide","text":"<p>For references to other chapters in the SCSTG, simply name the chapter, e.g.: <code>See also the chapter \"Basic Security Testing\"</code>, <code>See the section \"Apktool\" in the chapter \"Basic Security Testing\"</code> etc. The SCSTG should be convenient to read as a printed book, so use internal references sparingly. Alternatively you can create a link for the specific section:</p> <pre><code>See the section \"[App Bundles](0x05a-Platform-Overview.md#app-bundles)\" in the chapter ...\n</code></pre> <p>Note that in such a case the anchor (everything after the <code>#</code>) should be lowercase, and spaces should be replaced with hyphens.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#5-insert-pictures","title":"5. Insert Pictures","text":"<p>Pictures must always be an HTML <code>&lt;img</code> element instead of the usual markdown image format.</p> <ul> <li><code>src</code> being the first value.</li> <li>a <code>width</code> may be specified.</li> <li>they must be included in the corresponding directory, e.g. in <code>Document/Images/Chapters</code> for SCSTG chapters.</li> </ul> <p>For example:</p> <pre><code>&lt;img src=\"Images/Chapters/0x05b/r2_pd_10.png\" width=\"80%\" /&gt;\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#6-punctuation-conventions","title":"6. Punctuation Conventions","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#lowercase-or-capital-letter-after-a-colon","title":"Lowercase or Capital Letter after a Colon","text":"<p>Chicago Manual of Style (6.61: Lowercase or capital letter after a colon) says: lowercase the first word unless it is a proper noun or the start of at least two complete sentences or a direct question.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#serial-comma-use","title":"Serial Comma Use","text":"<p>Use a serial comma before \"and\" for the last item in a run-in list of three or more items. For example:</p> <p>We bought apples, oranges, and tomatoes from the store.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#quote-marks-and-apostrophes","title":"Quote Marks and Apostrophes","text":"<p>Use straight double quotes, straight single quotes, and straight apostrophes (not curly quotes/apostrophes).</p>","tags":[]},{"location":"contributing/5_Style_Guide/#technical-terms","title":"Technical Terms","text":"<p>Spell/punctuate specific technical terms as they are used by the company (e.g., use the company website).</p> <p>In order of preference, spell/punctuate generic technical terms according to</p> <ol> <li>Merriam Webster's Collegiate Dictionary, 11th edition.</li> <li>Microsoft Manual of Style, 4th edition</li> <li>foldoc.org (Free Online Dictionary of Computing)</li> </ol> Noun Form Adjectival Form App Store NA backend backend Base64 Base64- black box same Bundle ID NA bytecode NA client side client-side codebase same code signing same command line same disassembler NA end users NA file name same macOS NA OS X NA pentest same PhoneGap NA Python NA repackage NA runtime same server side server-side snapshot length NA use case same Wi-Fi same white box same","tags":[]},{"location":"contributing/5_Style_Guide/#7-comments","title":"7. Comments","text":"<p>Markdown blockquotes can be used for comments in the documents by using <code>&gt;</code></p> <pre><code>&gt; This is a blockquote\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#8-code-and-shell-commands","title":"8. Code and Shell Commands","text":"<p>Use code blocks when including sample code, shell commands, and paths. In Markdown, code blocks are denoted by triple backticks (<code>```</code>). GitHub also supports syntax highlighting for a variety of languages. For example, a Java code block should be annotated as follows:</p> <pre><code>```java\npublic static void main(String[] args) { System.out.println(\" Hello World!\"); } } ;\n```\n</code></pre> <p>This produces the following result:</p> <pre><code>public static void main(String[] args) { System.out.println(\" Hello World!\"); } }\n</code></pre> <p>When including shell commands, make sure to use the correct language for syntax highlighting (e.g. <code>shell</code> or <code>bash</code>) and remove any prompt (host name, username, ...) from the commands, e.g.:</p> <pre><code>```shell\necho 'Hello World'\nHello World\n```\n</code></pre> <p>When a command requires parameters that need to be modified by the reader, surround them with angle brackets:</p> <pre><code>adb pull &lt;remote_file&gt; &lt;target_destination&gt;\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#in-text-keywords","title":"In-text Keywords","text":"<p>When they do not occur in a code block, place the following code-related keywords in backticks (<code>``</code>), double straight quote marks (<code>\"\"</code>), or leave unpunctuated according to the table:</p> Backticks Quotation Marks No Punctuation function names section titles application name method names chapter titles folder names commands book titles memory addresses (e.g. 0x100044520) class names flags values (e.g., \"true\", lowercase) block names command options (e.g., \"help\" option) flag names single menu item (e.g., \"Home\" menu) file names system error msgs. package names file paths passwords port numbers binary names method/function arguments method/function argument or return values (e.g., <code>true</code>, <code>0</code>, <code>YES</code>) XML attributes (e.g., <code>get-task-allow</code> on iOS Plists, <code>\"@string/app_name\"</code> on Android Manifests) XML attribute values (e.g., <code>android:label</code> on Android Manifests) property names object names API calls interface names <p>If nouns in backticks are plural, place the \"s\" after the second backtick (e.g. <code>RuntimeException</code>s). Do not add parentheses, brackets, or other punctuation to any keywords that are in backticks (e.g., <code>main</code> not <code>main()</code>).</p>","tags":[]},{"location":"contributing/5_Style_Guide/#navigation","title":"Navigation","text":"<p>When referring to any UI element by name, put its name in boldface, using <code>**&lt;name&gt;**</code> (e.g., Home -&gt; Menu).</p>","tags":[]},{"location":"donate/how_to_donate/","title":"How to Donate","text":"<p>1. Make your Donation:</p> <p></p> <p>Click the button to make your donation directly in the official OWASP website:</p> <p> Fill in the form and be sure to select the option \"Publicly list me as a supporter of OWASP Smart Contract Security\"</p> <p> \ud83e\udd0d Make your Donation </p> <p>2. Register your Donation Package (optional):</p> <p>If your donation is above USD 500 you may opt-in for a Donation Package by registering it. We will then, together with the OWASP Foundation, verify and process it.</p> <p>  Register your Donation </p> <p></p>","tags":[]},{"location":"donate/packages/","title":"Donation Packages","text":"<p>These types of public recognition shall be online no less than one year, or no less than the next major release, whichever is greater.</p> <p> The Donation Packages have a maximum duration, once expired the logos will be removed and the donator will still be listed as supporter on the project website, GitHub and in the printed and digital versions. This can be renewed anytime.</p>  Good Samaritan (USD 500)  Honorable Benefactor (USD 2,000 / 8 Available)  God Mode Donator (USD 4,000 / 5 Available)  Listed as a supporter. Small company logo. 1 year  Listed as a supporter. Medium company logo. 2 years  Listed as a supporter. Large company logo. 3 years <p>Please note that the OWASP Donation Policy has changed since 22-Sept-2020. All details can be found in OWASP Donations Policy page.</p> <p>Contact us if you have any questions regarding your donation.</p>","tags":[]},{"location":"news/","title":"OWASP Official Pages","text":"<ul> <li>OWASP Smart Contract Security Project</li> <li>OWASP Smart Contract Top 10</li> <li>OWASP Smart Contract Security Testing Guide</li> <li>OWASP Smart Contract Security Verification Standard</li> </ul>","tags":[]},{"location":"news/#blogs","title":"Blogs","text":"<ul> <li>OWASP Smart Contract Top 10 Security Risks and Vulnerabilities: A Deep Dive with Real-World Exploits and CredShields Contribution (SolidityScan)</li> <li>OWASP SC Top 10 2025 Breakdown: The Most Critical Smart Contract Risks of 2025 (Resonance Security)</li> <li>OWASP Smart Contract Top 10 2025 (Insecure.in)</li> </ul>","tags":[]},{"location":"news/#security-newsletters","title":"Security Newsletters","text":"<ul> <li>Blockthreat Week 4 2025</li> <li>Cybersecurity News: OWASP Top 10 2025 Smart Contract</li> <li>GBHackers: OWASP Smart Contract Top 10 2025</li> <li>AppSec Newsletter 0040 (Guia de AppSec)</li> </ul>","tags":[]},{"location":"news/#conferences","title":"Conferences","text":"<ul> <li>OWASP Smart Contract Top 10 at DEVWorld Conference (LinkedIn Post)</li> </ul>","tags":[]},{"location":"news/#social-media-highlights","title":"Social Media Highlights","text":"","tags":[]},{"location":"news/#linkedin","title":"LinkedIn","text":"<ul> <li>OWASP Official Announcement</li> <li>Star Brown's Post</li> <li>Cybersecurity News Coverage</li> <li>Community Post</li> <li>Cyber Security Hub Newsletter</li> <li>SolidityScan Announcement</li> <li>Amish Patel's Post</li> </ul>","tags":[]},{"location":"news/#x-twitter","title":"X (Twitter)","text":"<ul> <li>OWASP Official Tweet</li> <li>DeFiHackLabs' Coverage</li> <li>SolidityScan's Tweet</li> <li>CyberboyIndia's Post</li> <li>CredShields Announcement</li> <li>Harshleen Chawla's Post</li> <li>Web3 Security Tweet</li> <li>7h3h4ckv157's Post</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/","title":"SC01:2026 Access Control Vulnerabilities","text":"","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#vulnerability-improper-access-control","title":"Vulnerability: Improper Access Control","text":"","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#description","title":"Description","text":"<p>Improper access control describes any situation where a smart contract does not rigorously enforce who may invoke privileged behavior, under which conditions, and with which parameters. In modern DeFi systems this goes far beyond a single <code>onlyOwner</code> modifier. Governance contracts, multisigs, guardians, proxy admins, and cross\u2011chain routers all participate in enforcing who can mint or burn tokens, move reserves, reconfigure pools, pause or unpause core logic, or upgrade implementations. If any of these trust boundaries are weak or inconsistently applied, an attacker may be able to impersonate a privileged actor or cause the system to treat an untrusted address as if it were authorized.</p> <p>Few areas to focus on:  - Ownership / admin controls (e.g., <code>onlyOwner</code>, governor, multisig) - Upgrade and pause mechanisms (proxy admins, guardians) - Fund movement and accounting (mint/burn, pool reconfiguration, fee routing) - Cross-chain or cross-module trust boundaries (bridges, vault routers, L2 messengers)</p> <p>Attackers exploit:</p> <ul> <li>Missing modifiers or role checks on sensitive functions</li> <li>Incorrect assumption of <code>msg.sender</code> (e.g., via delegate calls or meta-transactions)</li> <li>Unprotected initialization / re-initialization of contracts or proxies</li> <li>Privilege confusion across modules (e.g., off-by-one checks, mistaken trusted addresses)</li> </ul> <p>When combined with other issues (e.g., logic bugs, upgradeability flaws), access control failures can lead to full protocol compromise.</p>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#example-vulnerable-contract","title":"Example (Vulnerable Contract)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract LiquidityPoolVulnerable {\n    address public owner;\n    mapping(address =&gt; uint256) public balances;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Anyone can set a new owner \u2013 critical access control bug\n    function transferOwnership(address newOwner) external {\n        owner = newOwner; // No access control\n    }\n\n    // Intended to be called only by the owner to rescue tokens\n    function emergencyWithdraw(address to, uint256 amount) external {\n        // Missing: require(msg.sender == owner)\n        require(balances[address(this)] &gt;= amount, \"insufficient\");\n        balances[address(this)] -= amount;\n        balances[to] += amount;\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li><code>transferOwnership</code> is callable by anyone, allowing arbitrary takeover.</li> <li><code>emergencyWithdraw</code> lacks any access control, effectively granting any caller the ability to drain the contract\u2019s balance.</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#example-fixed-version-with-role-based-access-control","title":"Example (Fixed Version with Role-Based Access Control)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract LiquidityPoolSecure is AccessControl {\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    mapping(address =&gt; uint256) public balances;\n\n    event EmergencyWithdraw(address indexed to, uint256 amount, address indexed triggeredBy);\n\n    constructor(address governance, address guardian) {\n        _grantRole(DEFAULT_ADMIN_ROLE, governance);\n        _grantRole(GOVERNANCE_ROLE, governance);\n        _grantRole(GUARDIAN_ROLE, guardian);\n    }\n\n    function grantGovernance(address newGov) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _grantRole(GOVERNANCE_ROLE, newGov);\n    }\n\n    function setGuardian(address newGuardian) external onlyRole(GOVERNANCE_ROLE) {\n        _grantRole(GUARDIAN_ROLE, newGuardian);\n    }\n\n    // Only governance or designated guardians can trigger emergency withdrawals\n    function emergencyWithdraw(address to, uint256 amount)\n        external\n        onlyRole(GUARDIAN_ROLE)\n    {\n        require(to != address(0), \"invalid to\");\n        require(balances[address(this)] &gt;= amount, \"insufficient\");\n        balances[address(this)] -= amount;\n        balances[to] += amount;\n\n        emit EmergencyWithdraw(to, amount, msg.sender);\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Explicit RBAC: <code>DEFAULT_ADMIN_ROLE</code>, <code>GOVERNANCE_ROLE</code>, and <code>GUARDIAN_ROLE</code>.</li> <li>Only trusted roles can reconfigure privileges or perform emergency withdrawals.</li> <li>Clear separation between configuration (governance) and emergency response (guardian).</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>Balancer V2 (November 2025, ~$128M loss)   A complex multi-chain pool ecosystem suffered from flawed access control in pool configuration and ownership assumptions. The <code>manageUserBalance</code> function had improper access controls\u2014it checked <code>msg.sender</code> against a user-provided <code>op.sender</code> value, which attackers could set to match <code>msg.sender</code> and bypass protections, allowing them to masquerade as pool controllers and execute unauthorized WITHDRAW_INTERNAL operations. This was chained with a rounding error in <code>_upscaleArray</code> to drain liquidity.   Key lessons:</li> <li>Critical pool operations must be guarded by explicit role checks and on-chain governance.</li> <li>Any cross-chain or cross-module \"owner\" concept must be verified on-chain, not assumed from message origin.  </li> <li>https://www.openzeppelin.com/news/understanding-the-balancer-v2-exploit</li> <li>https://research.checkpoint.com/2025/how-an-attacker-drained-128m-from-balancer-through-rounding-error-exploitation/</li> <li> <p>https://www.halborn.com/blog/post/explained-the-balancer-hack-november-2025</p> </li> <li> <p>Zoth (March 2025, $8.4M loss)   Improper privilege checks around core accounting and administrative functions allowed attackers to perform unauthorized fund movements. The attacker compromised Zoth's deployer wallet (single EOA controlling admin) and performed a malicious upgrade to the USD0PPSubVaultUpgradeable proxy, deploying a malicious implementation to withdraw $8.4M. The protocol relied on brittle assumptions\u2014a single private key controlling critical admin functions.   Key lessons:</p> </li> <li>Avoid implicit trust in addresses (e.g., \"deployer is trusted forever\").</li> <li>Use role-based access control (RBAC) with clear separation between operational, emergency, and upgrade roles.  </li> <li>https://blog.solidityscan.com/zoth-hack-analysis-80ba3ac5076b</li> <li> <p>https://www.halborn.com/blog/post/explained-the-zoth-hack-march-2025</p> </li> <li> <p>Cork Protocol (May 2025, $11\u201312M loss)   The Uniswap V4 hook callbacks (e.g., <code>beforeSwap</code>) lacked proper access control\u2014they did not validate that the caller was the trusted PoolManager. The <code>beforeSwap</code> function had no <code>onlyPoolManager</code> modifier. Attackers called the hook directly with arbitrary parameters, fooling the protocol into crediting them with derivative tokens. The root cause was missing caller validation on hook entry points.   Key lessons:</p> </li> <li>Hook and callback entry points must validate the caller (e.g., onlyPoolManager) explicitly on-chain.  </li> <li>https://dedaub.com/blog/the-11m-cork-protocol-hack-a-critical-lesson-in-uniswap-v4-hook-security/</li> <li>https://www.coindesk.com/business/2025/05/28/a16z-backed-cork-protocol-suffers-usd12m-smart-contract-exploit</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<p>Robust access control starts with using battle\u2011tested primitives such as OpenZeppelin\u2019s <code>Ownable</code> and <code>AccessControl</code> rather than bespoke role systems. Privileged roles should be few, clearly documented, and ideally held by well\u2011secured multisigs or governance modules instead of EOAs. Initialization routines for upgradeable contracts must be locked after first use, with <code>initializer</code>/<code>reinitializer</code> guards and explicit versioning to prevent re\u2011initialization attacks. Upgrade paths for proxies and core components should be tightly controlled and observable, with events emitted for every privilege change or upgrade so that off\u2011chain monitoring can quickly detect abuse. Finally, access control policies should be encoded in tests, fuzzing properties, and, where possible, formal specifications, verifying properties such as \u201cno unprivileged address can ever drain funds or seize admin control.\u201d</p>","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/","title":"SC02:2026 Business Logic Vulnerabilities","text":"","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/#vulnerability-business-logic-vulnerabilities","title":"Vulnerability: Business Logic Vulnerabilities","text":"","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/#description","title":"Description","text":"<p>Business logic vulnerabilities describe any situation where a smart contract\u2019s intended economic or functional behavior can be subverted even though individual low-level checks (e.g., type safety, reentrancy guards, access control) are correct. These are design flaws in how the system\u2019s rules, incentives, state transitions, and invariants are modeled on-chain. Unlike low-level bugs (overflow, reentrancy), business logic flaws arise when the rules themselves are unsafe\u2014the code \u201cdoes what it says\u201d, but what it says permits exploitable outcomes.</p> <p>This applies across all smart contract domains: DeFi (lending, AMMs, vaults, yield strategies), NFTs (minting logic, royalties, marketplace mechanics), DAOs (voting, delegation, proposal execution), bridges (burn/mint asymmetry, liquidity rules), gaming (reward distribution, fairness), and cross-chain/L2 systems where multi-hop state transitions create emergent vulnerabilities.</p> <p>Few areas to focus on:</p> <ul> <li>Invariant violations across modules (e.g., vault \u2194 strategy \u2194 gauge, collateral \u2194 debt, supply \u2194 backing)</li> <li>Reward and fee logic (double-counting, under/over-accrual, wrong beneficiary)</li> <li>Eligibility and limit checks that are bypassable or inconsistently enforced (borrowing caps, mint limits, liquidation thresholds)</li> <li>Path-dependent state machines that allow manipulative action sequences to reach impossible or inconsistent states</li> <li>Cross-module and cross-chain assumptions (e.g., bridge liquidity, L2 finality, message ordering)</li> </ul> <p>Attackers exploit:</p> <ul> <li>Arbitrage between inconsistent accounting (vault vs. strategy, internal vs. external balance)</li> <li>Order-of-operations edge cases (deposit/withdraw/claim sequences that break invariants)</li> <li>Eligibility bypasses (e.g., claiming rewards without stake, liquidating healthy positions)</li> <li>Parameter manipulation (interest curves, fees, collateral factors) that create economically irrational states</li> </ul>","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/#example-vulnerable-lending-logic","title":"Example (Vulnerable Lending Logic)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract VulnerableLending {\n    mapping(address =&gt; uint256) public collateral;\n    mapping(address =&gt; uint256) public debt;\n    uint256 public collateralFactorBps = 7500; // 75%\n\n    function depositCollateral() external payable {\n        collateral[msg.sender] += msg.value;\n    }\n\n    // Vulnerable: calculates borrow capacity using the *new* amount, not total\n    function borrow(uint256 amount) external {\n        uint256 allowed = (amount * collateralFactorBps) / 10_000;\n        require(allowed &gt;= amount, \"not enough collateral\"); // meaningless check\n\n        debt[msg.sender] += amount;\n        // send tokens from pool (omitted)\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li><code>allowed</code> is computed from the requested borrow amount, not the user\u2019s collateral balance.</li> <li>The check <code>allowed &gt;= amount</code> always holds for <code>collateralFactorBps &gt;= 10_000</code>, and is otherwise simply a tautology when misused like this, failing to enforce any economic invariant.</li> </ul>","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/#example-fixed-invariant-based-borrow-logic","title":"Example (Fixed: Invariant-Based Borrow Logic)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPriceOracle {\n    function getCollateralPrice() external view returns (uint256); // 1e18\n}\n\ncontract SaferLending {\n    mapping(address =&gt; uint256) public collateral;\n    mapping(address =&gt; uint256) public debt;\n    uint256 public collateralFactorBps = 7500; // 75%\n    IPriceOracle public oracle;\n\n    constructor(IPriceOracle _oracle) {\n        oracle = _oracle;\n    }\n\n    function depositCollateral() external payable {\n        require(msg.value &gt; 0, \"no collateral\");\n        collateral[msg.sender] += msg.value;\n    }\n\n    function _maxBorrow(address user) internal view returns (uint256) {\n        uint256 price = oracle.getCollateralPrice(); // e.g. ETH price in USD 1e18\n        uint256 collateralUsd = (collateral[user] * price) / 1e18;\n        return (collateralUsd * collateralFactorBps) / 10_000;\n    }\n\n    function borrow(uint256 amountUsd) external {\n        uint256 maxBorrowUsd = _maxBorrow(msg.sender);\n        require(debt[msg.sender] + amountUsd &lt;= maxBorrowUsd, \"exceeds limit\");\n\n        debt[msg.sender] += amountUsd;\n        // transfer stablecoin from pool (omitted)\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Borrow limits derive from total collateral, not just requested amounts.</li> <li>Economic invariant: <code>debt[user] &lt;= maxBorrow(user)</code> is enforced on every borrow.</li> <li>Price oracle is explicitly integrated (and can be hardened per SC03).</li> </ul>","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>Abracadabra (March 2025, $12.9M loss)   Flawed collateral accounting in GMX V2 CauldronV4 contracts. Attackers used a three-stage method: (1) made a deposit into GMX designed to fail, leaving tokens stuck in OrderAgent; (2) self-liquidated their position so the contract erased the position but failed to remove the associated order and collateral; (3) used the \"ghost\" collateral to borrow 6,260 ETH (~$12.9M). Economic invariants (collateral \u2194 debt) were broken by the deposit-fail and liquidation path.   Key lessons:</li> <li>All economic invariants (e.g., minimum collateralization, max LTV) must be provable and enforced on every state transition.</li> <li>Introducing new spell/strategy types must go through formal review of how they interact with the existing system.  </li> <li>https://blog.solidityscan.com/abracadabra-hack-analysis-f2efcdee9c05</li> <li>https://www.halborn.com/blog/post/explained-the-abracadabra-money-hack-march-2025</li> <li>https://www.coindesk.com/business/2025/03/25/abracadabra-drained-of-usd13m-in-exploit-targeting-cauldrons-tied-to-gmx-liquidity-tokens</li> <li> <p>https://threesigma.xyz/blog/exploit/abracadabra-gmx-defi-exploit-explained</p> </li> <li> <p>Yearn Finance (November 2025, $9M loss)   A design flaw in the yETH weighted stableswap pool's fixed-point iteration solver. By performing highly imbalanced add/remove liquidity operations, attackers forced the solver into a divergent regime, causing the product term (\u03a0) to collapse to zero\u2014converting the pool from a hybrid stableswap invariant to a constant-sum curve. This allowed minting ~2.35\u00d710\u2075\u2076 yETH LP tokens without collateral and draining the pool. The vulnerability was invariant collapse, not reentrancy or low-level bugs.   Key lessons:</p> </li> <li>Reward and fee distribution paths must be simulation-tested across adversarial scenarios.</li> <li>Yield strategies should have clear, testable invariants (e.g., no user can claim more rewards than their fair share over time).  </li> <li>https://defimon.xyz/blog/yearn-yeth-hack-november-2025</li> <li>https://www.cryptopolitan.com/yearn-finance-begins-clawback-after-9m-hack/</li> </ul>","tags":[]},{"location":"sctop10/SC02-BusinessLogicVulnerabilities/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Model protocol economics explicitly (e.g., with adversarial simulations / agent-based models) rather than relying on intuition.</li> <li>Express core invariants in code and tests:</li> <li>\u201cTotal value withdrawn cannot exceed total deposits + realized yield\u201d</li> <li>\u201cRewards distribution is proportional to time-weighted stake\u201d</li> <li>\u201cLiquidations never result in protocol loss under honest oracle data\u201d</li> <li>Use formal verification and property-based fuzzing for key accounting paths (vaults, strategies, reward distribution).</li> <li>Version and gate new strategies / spells:</li> <li>Roll out behind caps.</li> <li>Monitor metrics and on-chain invariants before raising limits.</li> <li>Ensure governance and operations teams understand invariants, not just auditors.</li> </ul>","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/","title":"SC03:2026 Price Oracle Manipulation","text":"","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/#vulnerability-price-oracle-manipulation","title":"Vulnerability: Price Oracle Manipulation","text":"","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/#description","title":"Description","text":"<p>Price oracle manipulation describes any situation where a smart contract relies on price or valuation data that can be directly or indirectly influenced by an attacker, causing the protocol to make decisions based on incorrect values. Oracles are trust boundaries: the contract implicitly trusts that the price it receives reflects real-world or on-chain market conditions. When that trust is violated\u2014whether by manipulation, staleness, or misconfiguration\u2014protocol behavior is distorted.</p> <p>This affects all contract types that consume price data: DeFi lending and borrowing (collateral valuation, liquidation), AMMs and DEXes (spot and TWAP-based pricing), yield vaults (NAV calculations, share valuation), liquid staking and derivatives (ETH/stake price feeds), NFT and token valuations (floor price oracles), and cross-chain bridges (asset pricing for mint/burn ratios). On non-EVM chains (e.g., Move, Solana), similar patterns apply wherever external price sources feed into on-chain logic.</p> <p>Few areas to focus on:</p> <ul> <li>DEX-based oracles (spot price, TWAP, geometric mean) and resistance to flash loans, JIT liquidity, or concentrated liquidity skew</li> <li>Off-chain and hybrid feeds (Chainlink, Pyth, custom relayers) and assumptions about freshness, deviation, and multi-source aggregation</li> <li>Liquidity and market depth of the underlying price source (thin pools vs. deep markets)</li> <li>Cross-chain and L2 pricing (finality delays, sequencer ordering, message relay assumptions)</li> </ul> <p>Attackers exploit:</p> <ul> <li>Spot price manipulation via large trades, flash loans, or JIT liquidity in the same block</li> <li>TWAP manipulation over short windows or during low-liquidity periods</li> <li>Stale or stuck data when contracts do not enforce freshness or fallback behavior</li> <li>Deviation and outlier handling when aggregation logic fails to reject manipulated inputs</li> </ul>","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/#example-vulnerable-oracle-usage","title":"Example (Vulnerable Oracle Usage)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IPriceFeed {\n    function latestAnswer() external view returns (int256);\n}\n\ncontract VulnerableOracleLending {\n    IPriceFeed public priceFeed; // single-point oracle\n    mapping(address =&gt; uint256) public collateralEth;\n    mapping(address =&gt; uint256) public debtUsd;\n\n    constructor(IPriceFeed _feed) {\n        priceFeed = _feed;\n    }\n\n    function depositCollateral() external payable {\n        collateralEth[msg.sender] += msg.value;\n    }\n\n    function borrow(uint256 amountUsd) external {\n        int256 price = priceFeed.latestAnswer(); // no sanity checks, no delay\n        require(price &gt; 0, \"bad price\");\n\n        uint256 collateralUsd = (collateralEth[msg.sender] * uint256(price)) / 1e8;\n        // Allows borrowing up to 100% of collateral value \u2013 overly generous\n        require(collateralUsd &gt;= amountUsd, \"insufficient collateral\");\n\n        debtUsd[msg.sender] += amountUsd;\n        // transfer stablecoin (omitted)\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li>Single oracle source, no aggregation or sanity checks.</li> <li>No upper/lower bounds or deviation checks against past values.</li> <li>Economic parameters (100% LTV) make even minor manipulations profitable.</li> </ul>","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/#example-hardened-oracle-integration","title":"Example (Hardened Oracle Integration)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAggregatorV3 {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract RobustOracleLending {\n    IAggregatorV3 public immutable priceFeed;\n    mapping(address =&gt; uint256) public collateralEth;\n    mapping(address =&gt; uint256) public debtUsd;\n\n    uint256 public constant MAX_DELAY = 1 hours;\n    uint256 public constant COLLATERAL_FACTOR_BPS = 7500; // 75%\n\n    constructor(IAggregatorV3 _feed) {\n        priceFeed = _feed;\n    }\n\n    function _getSafePrice() internal view returns (uint256) {\n        (, int256 answer, , uint256 updatedAt, uint80 answeredInRound) =\n            priceFeed.latestRoundData();\n        require(answer &gt; 0, \"bad answer\");\n        require(updatedAt != 0 &amp;&amp; block.timestamp - updatedAt &lt;= MAX_DELAY, \"stale price\");\n        require(answeredInRound != 0, \"incomplete round\");\n        return uint256(answer);\n    }\n\n    function depositCollateral() external payable {\n        require(msg.value &gt; 0, \"no collateral\");\n        collateralEth[msg.sender] += msg.value;\n    }\n\n    function borrow(uint256 amountUsd) external {\n        uint256 price = _getSafePrice();\n        uint256 collateralUsd = (collateralEth[msg.sender] * price) / 1e8;\n        uint256 maxBorrow = (collateralUsd * COLLATERAL_FACTOR_BPS) / 10_000;\n        require(debtUsd[msg.sender] + amountUsd &lt;= maxBorrow, \"exceeds limit\");\n\n        debtUsd[msg.sender] += amountUsd;\n        // transfer stablecoin (omitted)\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Uses a price feed interface with round metadata to reject stale or incomplete data.</li> <li>Applies conservative collateral factors and explicit borrowing limits.</li> <li>Encapsulates price fetch and validation in <code>_getSafePrice</code>, making reasoning and testing easier.</li> </ul> <p>In 2025, pure oracle-only mega-exploits were less frequent, but oracle manipulation was often one component in multi-vector attacks.</p>","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>NGP Token (September 2025, ~$2M loss)   The protocol's <code>getPrice()</code> function relied solely on DEX pair (Uniswap V2/PancakeSwap) reserve balances to calculate token price. Attackers used a flash loan to swap large amounts and manipulate reserves, skewing the oracle to show artificially low values, then bypassed purchase limits and cooldown protections to drain ~$2M. Oracle manipulation was the root cause.  </li> <li>https://blog.solidityscan.com/ngp-token-hack-analysis-414b6ca16d96</li> <li>https://hacken.io/insights/ngp-hack-explained/</li> <li> <p>https://coincentral.com/flash-loan-exploit-drains-2-million-from-ngp-token-on-bnb-chain/</p> </li> <li> <p>GMX (July 2025, $42M loss)   While the primary root cause was reentrancy in <code>executeDecreaseOrder</code>, the attack flow involved price feed manipulation in conjunction: the attacker manipulated global average short price for Bitcoin downward (~57\u00d7), then used a flash loan to purchase GLP at artificially low prices and redeem at inflated prices. Oracle/pricing was a key enabler of the exploit.  </p> </li> <li>https://blog.solidityscan.com/gmx-v1-hack-analysis-ed0ab0c0dd0f</li> <li>https://www.halborn.com/blog/post/explained-the-gmx-hack-july-2025</li> <li>https://blog.verichains.io/p/gmx-42m-exploit-root-cause-analysis</li> </ul>","tags":[]},{"location":"sctop10/SC03-PriceOracleManipulation/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Aggregate multiple sources:</li> <li>Use median/mean of several DEXs / oracles.</li> <li>Reject outliers and anomalous deviations.</li> <li>Time-based defenses:</li> <li>Use TWAPs over sufficient windows to resist short-lived manipulations.</li> <li>Reject prices older than a maximum staleness threshold.</li> <li>Liquidity-aware design:</li> <li>Avoid basing core prices on illiquid pools.</li> <li>Cap impact of a single pool/feed on global pricing.</li> <li>Fail-safe behavior:</li> <li>On suspicious or unavailable data, halt sensitive operations (borrowing, liquidations).</li> <li>Use circuit breakers and rate limiting on parameter changes.</li> <li>Monitoring &amp; alerting:</li> <li>Track price deviations between your oracle and reference markets.</li> <li>Set automated alerts for out-of-band movements or stuck oracles.</li> </ul>","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/","title":"SC04:2026 Flash Loan\u2013Facilitated Attacks","text":"","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/#vulnerability-flash-loanfacilitated-attacks","title":"Vulnerability: Flash Loan\u2013Facilitated Attacks","text":"","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/#description","title":"Description","text":"<p>Flash loan\u2013facilitated attacks describe exploits where an attacker uses uncollateralized, same-transaction borrowing (flash loans) to amplify an underlying vulnerability into a profitable, protocol-draining attack. Flash loans are not inherently vulnerable\u2014they are a legitimate DeFi primitive\u2014but they grant attackers arbitrarily large, transient capital within a single transaction. Any protocol that makes trust assumptions based on capital at risk or historical position size is exposed when an attacker can temporarily hold massive balances without putting their own funds at risk.</p> <p>This affects all contract types that assume economic constraints or proportional exposure: lending protocols (governance vote weight, liquidation thresholds, collateral ratios), AMMs (share minting, arbitrage, oracle skew), yield vaults (deposit/withdraw/share accounting), governance (vote buying, flash-loan governance attacks), NFT and token valuation (floor price, collateral valuation), and cross-protocol composability where one contract\u2019s state is influenced by another\u2019s liquidity. On non-EVM chains, similar concepts exist (e.g., transient large positions within a single block or batch).</p> <p>Few areas to focus on:</p> <ul> <li>Governance and voting (flash-loan vote buying, snapshot manipulation)</li> <li>Oracle and pricing (manipulating DEX/TWAP feeds with borrowed liquidity)</li> <li>Share and accounting logic (rounding, proportional calculations that assume bounded input)</li> <li>Liquidation and collateral checks (position size\u2013dependent thresholds)</li> <li>Composability (protocols that trust caller balance or pool state in a single transaction)</li> </ul> <p>Attackers construct batched transactions that:</p> <ol> <li>Borrow large capital via flash loan (Aave, dYdX, Uniswap V3 flash, or equivalent).</li> <li>Manipulate protocol state, prices, or accounting using the borrowed funds.</li> <li>Extract profit (drain liquidity, take under-collateralized loans, skew governance).</li> <li>Repay the flash loan in the same transaction, keeping the profit.</li> </ol> <p>When underlying weaknesses in business logic (SC02), oracles (SC03), arithmetic (SC07), or access control (SC01) exist, flash loans act as a force multiplier, turning small bugs into catastrophic exploits.</p>","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/#example-vulnerable-use-of-flash-loans-with-rounding-bug","title":"Example (Vulnerable Use of Flash Loans with Rounding Bug)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IFlashLender {\n    function flashLoan(\n        address receiver,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ncontract VulnerablePool {\n    uint256 public totalShares;\n    uint256 public totalAssets;\n\n    mapping(address =&gt; uint256) public sharesOf;\n\n    // Vulnerable: naive share minting with truncation benefit to sender\n    function deposit(uint256 assets) external {\n        uint256 shares;\n        if (totalShares == 0) {\n            shares = assets;\n        } else {\n            shares = (assets * totalShares) / totalAssets;\n        }\n\n        totalAssets += assets;\n        totalShares += shares;\n        sharesOf[msg.sender] += shares;\n    }\n\n    // No safeguard against flash-loan boosted deposit/withdraw loops\n}\n</code></pre> <p>Issues:</p> <ul> <li>Rounding always truncates in favor of the protocol, but with repeated flash-loan-driven cycles, a mis-tuned formula or mis-accounted state can be turned into a net gain for an attacker.</li> <li>No consideration for max slippage, caps, or frequency of operations, making repeated high-volume operations feasible.</li> </ul>","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/#example-mitigated-design-considerations","title":"Example (Mitigated Design Considerations)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract SaferPool {\n    uint256 public totalShares;\n    uint256 public totalAssets;\n    uint256 public lastUpdateBlock;\n\n    mapping(address =&gt; uint256) public sharesOf;\n\n    error TooFrequentInteraction();\n\n    modifier rateLimited() {\n        // Simple example: limit high-impact operations to once per block\n        if (lastUpdateBlock == block.number) revert TooFrequentInteraction();\n        _;\n        lastUpdateBlock = block.number;\n    }\n\n    function deposit(uint256 assets) external rateLimited {\n        require(assets &gt; 0, \"zero assets\");\n\n        uint256 shares;\n        if (totalShares == 0) {\n            shares = assets;\n        } else {\n            // Use rounding that errs in favor of the protocol and is formally analyzed\n            shares = (assets * totalShares + totalAssets - 1) / totalAssets;\n        }\n\n        totalAssets += assets;\n        totalShares += shares;\n        sharesOf[msg.sender] += shares;\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Introduces basic rate limiting to reduce susceptibility to rapid flash-loan loops.</li> <li>Uses a more conservative, explicitly documented rounding strategy.</li> <li>Encourages formal analysis of share/accounting formulas and invariants.</li> </ul> <p>Note: Real protocols should use stronger defense-in-depth mechanisms rather than relying solely on per-block limits.</p>","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>Bunni (September 2025, $8.4M loss)   A rounding error in the withdrawal function was amplified by flash loans. Attackers flash-borrowed 3M USDT, pushed the pool's spot price to extremes (USDC active balance to 28 wei), then executed 44 chained tiny withdrawals exploiting rounding\u2014decreasing USDC balance by 85.7% while only burning 84.4% of liquidity. Flash loans enabled the capital scale required.  </li> <li>https://www.halborn.com/blog/post/explained-the-bunni-hack-september-2025</li> <li>https://blog.bunni.xyz/posts/exploit-post-mortem/</li> <li> <p>https://cryptorank.io/news/feed/27dc8-bunni-hit-by-8-4m-flash-loan-exploit-rounding-error-blamed</p> </li> <li> <p>zkLend (February 2025, $9.5M loss)   A rounding error in the <code>mint()</code> function (integer division rounding down) allowed attackers to inflate the lending_accumulator via repeated deposits/withdrawals. Flash loans scaled the position\u2014turning small per-iteration precision gains into a ~$9.5M drain. Flash loans were the force multiplier.  </p> </li> <li>https://blog.solidityscan.com/zklend-hack-analysis-e494cb794f71</li> <li>https://www.halborn.com/blog/post/explained-the-zklend-hack-february-2025</li> <li>https://zircon.tech/blog/the-9-5m-zklend-hack-another-defi-security-wake-up-call/</li> </ul>","tags":[]},{"location":"sctop10/SC04-FlashLoanAttacks/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Assume flash loans exist: design economic and accounting logic on the assumption that arbitrarily large, transient capital is available to attackers.</li> <li>Rate limit sensitive operations:</li> <li>Per-block or per-epoch limits on rebasing, rebalancing, or high-impact state transitions.</li> <li>Dynamic fees that increase with the magnitude/frequency of actions.</li> <li>Cap exposure per interaction:</li> <li>Set maximum slippage, max position sizes, and borrowing caps.</li> <li>Limit how much state can change in a single transaction.</li> <li>Simulate flash loan scenarios:</li> <li>Include flash-loan-style tests in QA and audits.</li> <li>Use fuzzing to discover profitable multi-call sequences.</li> <li>Combine with strong oracles and logic:</li> <li>Flash loans are usually the multiplier; underlying issues (SC02, SC03, SC07) must be fixed at the root.</li> </ul>","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/","title":"SC05:2026 Lack of Input Validation","text":"","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/#vulnerability-lack-of-input-validation","title":"Vulnerability: Lack of Input Validation","text":"","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/#description","title":"Description","text":"<p>Lack of input validation describes any situation where a smart contract processes external data\u2014function parameters, calldata, cross-chain messages, or signed payloads\u2014without rigorously enforcing that the data is well-formed, within expected bounds, and authorized for the intended operation. Contracts that assume inputs are benign leave themselves open to malformed or adversarial data that pushes the system into unsafe states, corrupts accounting, or bypasses intended checks.</p> <p>This applies across all contract types: DeFi (fee bps, slippage, amounts, addresses), NFTs (token IDs, metadata, royalty config), DAOs (proposal payloads, voting parameters), bridges (message payloads, destination chains), and generic composable contracts that accept arbitrary calldata or relayed calls. On non-EVM chains, the same principle holds: untrusted inputs from users, other contracts, or cross-chain channels must be validated before use.</p> <p>Few areas to focus on:</p> <ul> <li>Numeric parameters (amounts, fees, rates, slippage, collateral factors) and safe bounds</li> <li>Addresses (zero address, contract vs. EOA assumptions, delegated or proxy addresses)</li> <li>Off-chain and signed data (signatures, expiry, nonce replay)</li> <li>Cross-chain and bridge payloads (message format, chain ID, sender verification)</li> <li>Admin and governance inputs (configuration values, upgrade parameters)\u2014often treated as trusted but can be misconfigured or exploited</li> </ul> <p>Attackers exploit:</p> <ul> <li>Out-of-bounds values (e.g., fee &gt; 100%, zero amounts, max uint) that break invariants</li> <li>Malformed addresses or payloads that bypass allowlists or cause unexpected behavior</li> <li>Replay and ordering attacks when nonce/expiry/chain ID are not validated</li> <li>Composability edge cases when contracts assume caller format or trust relayed data</li> </ul> <p>In 2025, input validation issues often appeared as a contributing factor, e.g., failure to enforce safe ranges on parameters controlling liquidity or interest computations.</p>","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/#example-vulnerable-parameter-handling","title":"Example (Vulnerable Parameter Handling)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract VulnerableConfig {\n    uint256 public feeBps;      // basis points 0\u201310_000\n    uint256 public maxDeposit;  // upper bound for deposits\n\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setConfig(uint256 _feeBps, uint256 _maxDeposit) external {\n        // Missing: access control and bounds checks\n        feeBps = _feeBps;\n        maxDeposit = _maxDeposit;\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li>No access control: anyone can call <code>setConfig</code>.</li> <li>No validation of <code>_feeBps</code> or <code>_maxDeposit</code>:</li> <li><code>feeBps</code> could exceed 100%, breaking fee logic.</li> <li><code>maxDeposit</code> could be set to an unsafe or zero value, disrupting the protocol.</li> </ul>","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/#example-fixed-version-with-strong-validation","title":"Example (Fixed Version with Strong Validation)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract SafeConfig {\n    uint256 public feeBps;      // 0\u20131_000 (max 10% fee)\n    uint256 public maxDeposit;  // upper bound for deposits\n\n    address public immutable owner;\n\n    error NotOwner();\n    error InvalidFee();\n    error InvalidMaxDeposit();\n\n    constructor(uint256 initialFeeBps, uint256 initialMaxDeposit) {\n        owner = msg.sender;\n        _setConfig(initialFeeBps, initialMaxDeposit);\n    }\n\n    function _setConfig(uint256 _feeBps, uint256 _maxDeposit) internal {\n        if (_feeBps &gt; 1_000) revert InvalidFee();\n        if (_maxDeposit == 0) revert InvalidMaxDeposit();\n        feeBps = _feeBps;\n        maxDeposit = _maxDeposit;\n    }\n\n    function setConfig(uint256 _feeBps, uint256 _maxDeposit) external {\n        if (msg.sender != owner) revert NotOwner();\n        _setConfig(_feeBps, _maxDeposit);\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Validates that fee is bounded within a documented, safe range.</li> <li>Requires <code>maxDeposit</code> to be non-zero, preventing misconfiguration.</li> <li>Restricts configuration changes to the contract owner (see SC01 for more advanced RBAC).</li> </ul>","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>Cetus (May 2025, $223M loss)   The primary root cause was a flawed overflow check in <code>checked_shlw</code> (see SC09). However, insufficient input validation was a contributing factor\u2014the protocol allowed extreme liquidity parameters (e.g., ~2^113) without bounds checks. When combined with the flawed arithmetic, these unvalidated inputs produced dangerous edge cases leading to pool drains.  </li> <li>https://dedaub.com/blog/the-cetus-amm-200m-hack-how-a-flawed-overflow-check-led-to-catastrophic-loss/</li> <li>https://www.cyfrin.io/blog/inside-the-223m-cetus-exploit-root-cause-and-impact-analysis</li> <li> <p>https://www.halborn.com/blog/post/explained-the-cetus-hack-may-2025</p> </li> <li> <p>Ionic Money (February 2025, ~$6.9M loss)   Attackers used social engineering to convince the protocol to list a counterfeit LBTC token. Once listed, the protocol accepted it as collateral without validating token authenticity on-chain (e.g., verification that listed collateral contracts are legitimate). Attackers minted 250 fake LBTC and used it to borrow ~$8.6M. Note: The root cause was partly off-chain (governance/listing process); the on-chain vulnerability was insufficient validation that collateral tokens are genuine before trusting whitelisted addresses. </p> </li> <li>https://www.halborn.com/blog/post/explained-the-ionic-money-hack-february-2025</li> <li>https://rekt.news/ionic-money-rekt</li> </ul>","tags":[]},{"location":"sctop10/SC05-LackOfInputValidation/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Validate all external inputs, including:</li> <li>Function parameters (amounts, addresses, configuration values)</li> <li>Off-chain-signed data and calldata payloads</li> <li>Cross-chain messages and bridge payloads</li> <li>Enforce tight invariants:</li> <li>Ranges for fees, interest rates, leverage, and collateral factors.</li> <li>Non-zero requirements for key addresses and limits.</li> <li>Use custom errors and explicit checks to keep validation clear and gas-efficient.</li> <li>Treat admin and governance inputs as untrusted until validated\u2014misconfiguration can be as damaging as explicit exploits.</li> <li>Include negative tests for invalid inputs (fuzzing, property tests) to ensure unexpected values are rejected.</li> </ul>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/","title":"SC06:2026 Unchecked External Calls","text":"","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#vulnerability-unchecked-external-calls","title":"Vulnerability: Unchecked External Calls","text":"","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#description","title":"Description","text":"<p>Unchecked external calls describe any situation where a smart contract invokes another contract or address (via <code>call</code>, <code>delegatecall</code>, <code>staticcall</code>, or high-level calls like <code>transfer</code>/<code>send</code>) without fully accounting for the callee\u2019s behavior, return value, or reentrancy potential. The calling contract implicitly trusts that the callee will behave as expected\u2014returning success, not re-entering, and not executing arbitrary logic. When that assumption is violated, the caller can be left in an inconsistent state or exploited.</p> <p>This affects all contract types that perform external interactions: DeFi (token transfers, DEX swaps, vault deposits, flash loan callbacks), NFTs (transfers with hooks, marketplace payouts), DAOs (execution of proposal calldata), bridges (message relay, asset transfers), and composable protocols (arbitrary callbacks, ERC-777/ERC-721/ERC-1155 receiver hooks, ERC-4626 deposit/withdraw hooks). On non-EVM chains, analogous patterns exist (e.g., Move\u2019s <code>vector::borrow</code>, Solana CPI) where cross-program invocations can re-enter or behave unexpectedly.</p> <p>Few areas to focus on:</p> <ul> <li>Token transfers (ERC-20, ERC-721, ERC-1155) and non-standard return values or reverting behavior</li> <li>Callback and hook interfaces (ERC-777 <code>tokensReceived</code>, ERC-4626 <code>afterDeposit</code>/<code>beforeWithdraw</code>, <code>onFlashLoan</code>, <code>onERC721Received</code>)</li> <li>Low-level calls (<code>call</code>, <code>delegatecall</code>, <code>callcode</code>) and gas/storage implications</li> <li>Composability flows (vault calling strategy, strategy calling DEX) where reentrancy can cross multiple contracts</li> </ul> <p>Attackers exploit:</p> <ul> <li>Reentrancy by implementing malicious logic in callbacks or in tokens that hook into transfers (see SC08)</li> <li>Silent failures when return values are ignored (e.g., non-returning ERC-20s) and state is left inconsistent</li> <li>Unexpected code execution when calling user-supplied or protocol-configurable addresses</li> </ul> <p>Unchecked external calls are rarely the sole root cause but are a critical enabler for reentrancy (SC08), business logic exploits (SC02), and accounting inconsistencies.</p>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#example-vulnerable-unchecked-call-pattern","title":"Example (Vulnerable Unchecked Call Pattern)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IToken {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract VulnerablePayout {\n    IToken public token;\n\n    mapping(address =&gt; uint256) public rewards;\n\n    constructor(IToken _token) {\n        token = _token;\n    }\n\n    function claim() external {\n        uint256 amount = rewards[msg.sender];\n        require(amount &gt; 0, \"no rewards\");\n\n        // Vulnerable: does not check return value or reentrancy\n        token.transfer(msg.sender, amount);\n\n        // State update after external call\n        rewards[msg.sender] = 0;\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li>The <code>transfer</code> call\u2019s return value is ignored; if transfer fails, rewards remain non-zero but the user did not receive tokens.</li> <li>State is updated after the external call, opening reentrancy possibilities (if the token is malicious).</li> </ul>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#example-hardened-external-call-handling","title":"Example (Hardened External Call Handling)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ISafeToken {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract SafePayout {\n    ISafeToken public immutable token;\n    mapping(address =&gt; uint256) public rewards;\n\n    error NoRewards();\n    error TransferFailed();\n\n    constructor(ISafeToken _token) {\n        token = _token;\n    }\n\n    function claim() external {\n        uint256 amount = rewards[msg.sender];\n        if (amount == 0) revert NoRewards();\n\n        // Move state change *before* external call to mitigate reentrancy on this variable\n        rewards[msg.sender] = 0;\n\n        bool ok = token.transfer(msg.sender, amount);\n        if (!ok) {\n            // revert and restore state if needed (not shown here for brevity)\n            revert TransferFailed();\n        }\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>State is updated before the external call, limiting simple reentrancy on <code>rewards</code>.</li> <li>The token transfer\u2019s return value is checked; failure results in a revert, preventing silent inconsistencies.</li> </ul> <p>Note: For full reentrancy protection, see SC08 and consider <code>ReentrancyGuard</code>, checks-effects-interactions, and pull-based patterns.</p>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>GMX (July 2025, $42M loss)   Unsafe external interactions and state updates after external calls allowed attackers to re-enter and manipulate accounting. The <code>executeDecreaseOrder</code> function transferred control to an attacker-supplied contract address during the refund process, enabling reentrancy. External call ordering, lack of proper checks, and reliance on assumptions about callee behavior amplified the impact.  </li> <li>https://blog.solidityscan.com/gmx-v1-hack-analysis-ed0ab0c0dd0f</li> <li> <p>https://www.halborn.com/blog/post/explained-the-gmx-hack-july-2025</p> </li> <li> <p>Arcadia Finance (July 2025, $3.5M loss)   The <code>SwapLogic._swapRouter()</code> and <code>RebalancerSpot</code> contracts allowed arbitrary external calls to user-supplied router addresses via <code>swapData</code> parameters, without validating the callee. The attacker registered a malicious contract as both the router and a whitelisted ArcadiaAccount, then used the router callback to spoof privileged execution contexts and invoke <code>setAssetManager()</code> / <code>flashAction()</code>. The protocol assumed the router would not have elevated permissions\u2014an assumption not enforced in code. Unchecked callbacks and trust in external callee behavior enabled the drain.  </p> </li> <li>https://blog.solidityscan.com/arcadia-finance-hack-analysis-a03a722e554d</li> <li>https://www.guardrail.ai/blog/arcadia-finance-hack-july-2025</li> </ul>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Treat all external calls as untrusted:</li> <li>Even \u201cstandard\u201d tokens or well-known protocols can be upgraded or replaced.</li> <li>Assume they may re-enter or revert unexpectedly.</li> <li>Use the checks-effects-interactions pattern:</li> <li>Validate pre-conditions.</li> <li>Update internal state.</li> <li>Only then perform external calls.</li> <li>Prefer pull over push for payments:</li> <li>Allow users to withdraw rather than pushing funds to arbitrary addresses in loops.</li> <li>Check return values and handle all failure modes:</li> <li>Use libraries like OpenZeppelin\u2019s <code>SafeERC20</code> to wrap token operations.</li> <li>Be extremely careful with:</li> <li>Low-level calls (<code>call</code>, <code>delegatecall</code>, <code>callcode</code>)</li> <li>Arbitrary callbacks (e.g., hooks, onERC721Received, onFlashLoan callbacks)</li> </ul>","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/","title":"SC07:2026 Arithmetic Errors (Rounding & Precision)","text":"","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/#vulnerability-arithmetic-errors-rounding-precision-loss","title":"Vulnerability: Arithmetic Errors (Rounding &amp; Precision Loss)","text":"","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/#description","title":"Description","text":"<p>Arithmetic errors (rounding and precision loss) describe any situation where a smart contract performs integer-based calculations that produce incorrect or exploitable results due to truncation, scaling, or unit conversion. Smart contracts are limited to integer arithmetic; any division, fixed-point scaling, or conversion between units can lose precision, introduce asymmetric rounding, or\u2014when combined with unchecked blocks or non-EVM semantics\u2014cause overflow/underflow (see SC09).</p> <p>This affects all contract types that compute numeric values: DeFi (share minting/burning, LP tokens, interest accrual, swap outputs, AMM invariant updates), yield vaults and ERC-4626 (asset/share conversions), rebasing tokens, reward distribution, and NFT/token economics. On non-EVM chains (e.g., Move, Rust-based), integer semantics and available precision differ; similar risks apply wherever arithmetic drives economic outcomes.</p> <p>Few areas to focus on:</p> <ul> <li>Share and LP token calculations (deposit/withdraw formulas, rounding direction)</li> <li>Interest and reward accrual (compounding, time-weighted averages)</li> <li>Swap and AMM math (constant product, concentrated liquidity, output calculations)</li> <li>Fixed-point and scaling (1e18, 1e8 conventions, cross-token conversions)</li> <li>Rebasing and proportional distribution (per-user vs. global accounting)</li> </ul> <p>Attackers exploit:</p> <ul> <li>Rounding bias (e.g., rounding that favors depositor or protocol under adversarial sequences)</li> <li>Repeated small gains via flash loans (SC04) or high-frequency interactions</li> <li>Edge cases (zero total supply, first depositor, extreme ratios) where formulas break down</li> <li>Precision loss in multi-step computations that accumulates across operations</li> </ul> <p>When combined with flash loans (SC04) or business logic flaws (SC02), arithmetic errors can be amplified into protocol-draining exploits.</p>","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/#example-vulnerable-share-calculation","title":"Example (Vulnerable Share Calculation)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract VulnerableShares {\n    uint256 public totalAssets;\n    uint256 public totalShares;\n\n    mapping(address =&gt; uint256) public balanceOf;\n\n    function deposit(uint256 assets) external {\n        require(assets &gt; 0, \"zero\");\n\n        uint256 shares;\n        if (totalShares == 0) {\n            shares = assets;\n        } else {\n            // Rounds down and may favor the depositor under certain edge states\n            shares = (assets * totalShares) / totalAssets;\n        }\n\n        totalAssets += assets;\n        totalShares += shares;\n        balanceOf[msg.sender] += shares;\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li>Rounding always truncates; under adversarial sequences of deposits/withdrawals, this can be gamed.</li> <li>No invariant tests to ensure that total share value remains consistent across edge cases.</li> </ul>","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/#example-more-robust-arithmetic-invariant-aware-design","title":"Example (More Robust Arithmetic &amp; Invariant-Aware Design)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract SaferShares {\n    uint256 public totalAssets;\n    uint256 public totalShares;\n\n    mapping(address =&gt; uint256) public balanceOf;\n\n    error ZeroAmount();\n    error InvalidState();\n\n    function deposit(uint256 assets) external {\n        if (assets == 0) revert ZeroAmount();\n\n        uint256 shares;\n        if (totalShares == 0 || totalAssets == 0) {\n            // Explicitly define initial conditions\n            shares = assets;\n        } else {\n            // Use rounding strategy intentionally (up or down) and test it\n            shares = (assets * totalShares + totalAssets - 1) / totalAssets; // round up\n        }\n\n        uint256 newTotalAssets = totalAssets + assets;\n        if (newTotalAssets &lt; totalAssets) revert InvalidState(); // overflow guard\n\n        totalAssets = newTotalAssets;\n        totalShares += shares;\n        balanceOf[msg.sender] += shares;\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Explicitly handles initial states and avoids division by zero.</li> <li>Uses a clearly documented rounding strategy (<code>round up</code> in this example).</li> <li>Adds overflow checks and custom errors for clarity.</li> </ul> <p>Real-world protocols should pair such logic with formal reasoning and invariants (e.g., through formal verification or property-based tests).</p>","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li>zkLend (February 2025, $9.5M loss)   A rounding error in the <code>mint()</code> function\u2014integer division rounding down\u2014caused a mismatch between recorded and actual values. A withdrawal that should have burned 1.5 tokens rounded down to 1.0, allowing attackers to artificially inflate the lending_accumulator via repeated deposits/withdrawals and drain ~$9.5M.  </li> <li>https://blog.solidityscan.com/zklend-hack-analysis-e494cb794f71</li> <li> <p>https://www.halborn.com/blog/post/explained-the-zklend-hack-february-2025</p> </li> <li> <p>Bunni (September 2025, $8.4M loss)   Precision bugs in the withdrawal function's rounding logic. Developers assumed rounding down the idle balance would be \"safe,\" but repeated operations created an exploitable loophole\u2014the attacker decreased USDC balance by 85.7% while only burning 84.4% of liquidity, enabling disproportionate value extraction.  </p> </li> <li>https://www.halborn.com/blog/post/explained-the-bunni-hack-september-2025</li> <li>https://blog.bunni.xyz/posts/exploit-post-mortem/</li> <li>https://cryptotimes.io/2025/09/05/bunni-reveals-code-flaw-behind-8-4-million-exploit</li> </ul>","tags":[]},{"location":"sctop10/SC07-ArithmeticErrors/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Use safe math patterns (Solidity 0.8+ has built-in checks, but logic around them still matters).</li> <li>Clearly document and test your rounding strategy:</li> <li>Decide whether rounding should favor the protocol or users.</li> <li>Prove that repeated interactions cannot create \u201cfree value\u201d.</li> <li>Rely on well-reviewed math libraries for complex operations:</li> <li>Fixed-point math (e.g., 1e18 scaling)</li> <li>High-precision exponentiation or logarithms</li> <li>Incorporate invariant checks:</li> <li>E.g., <code>totalAssets</code> vs. sum of user balances, or share/value consistency after operations.</li> <li>Use fuzz testing and differential testing to discover edge cases around small/large values and repeated operations.</li> </ul>","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/","title":"SC08:2026 Reentrancy Attacks","text":"","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/#vulnerability-reentrancy-attacks","title":"Vulnerability: Reentrancy Attacks","text":"","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/#description","title":"Description","text":"<p>Reentrancy describes any situation where a smart contract performs an external call (to another contract or address), and the callee can call back into the original contract before the first invocation has completed and state has been fully updated. If the caller is not designed to be reentrancy-safe, the callback can observe stale state and exploit it\u2014e.g., withdrawing more than the caller\u2019s balance, double-counting rewards, or manipulating accounting across complex multi-step flows.</p> <p>This affects all contract types that perform external calls: DeFi (token transfers, DEX swaps, vault deposits/withdrawals, flash loan callbacks), NFTs (transfers with ERC-721/ERC-1155 receiver hooks, marketplace payouts), DAOs (proposal execution that invokes external contracts), bridges (message relay, asset transfers), and composable protocols (ERC-777 hooks, ERC-4626 deposit/withdraw hooks). Reentrancy can be single-function (same function called recursively), cross-function (callback into a different function), or cross-contract (callback traverses multiple contracts). On non-EVM chains, analogous patterns exist wherever cross-program invocations can recurse.</p> <p>Few areas to focus on:</p> <ul> <li>Classic withdraw-before-update (state change after external call)</li> <li>Callback and hook interfaces (ERC-777, ERC-721/1155 receivers, ERC-4626, flash loan callbacks)</li> <li>Cross-function reentrancy (read-your-writes assumptions between functions)</li> <li>Read-only reentrancy (view functions or oracles reading state during a callback)</li> <li>Cross-contract and multi-module reentrancy (vault \u2192 strategy \u2192 DEX flows)</li> </ul> <p>Attackers exploit:</p> <ul> <li>Malicious tokens or receivers that re-enter on transfer/hook callbacks</li> <li>Flash loan callbacks that execute attacker logic before repayment</li> <li>Complex call graphs where state is inconsistent mid-transaction across modules</li> </ul>","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/#example-vulnerable-reentrancy-pattern","title":"Example (Vulnerable Reentrancy Pattern)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IToken {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract VulnerableVault {\n    IToken public immutable token;\n    mapping(address =&gt; uint256) public balances;\n\n    constructor(IToken _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) external {\n        // Assume token already transferred in for brevity\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] &gt;= amount, \"insufficient\");\n\n        // External call before state update \u2013 reentrancy window\n        token.transfer(msg.sender, amount);\n\n        balances[msg.sender] -= amount;\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li>An attacker using a malicious token / proxy can re-enter <code>withdraw</code> from within the <code>transfer</code> call, repeatedly withdrawing based on the unchanged <code>balances[msg.sender]</code>.</li> </ul>","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/#example-reentrancy-safe-withdraw","title":"Example (Reentrancy-Safe Withdraw)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface ITokenSafe {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract SafeVault is ReentrancyGuard {\n    ITokenSafe public immutable token;\n    mapping(address =&gt; uint256) public balances;\n\n    error InsufficientBalance();\n    error TransferFailed();\n\n    constructor(ITokenSafe _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) external {\n        // Assume token already transferred in for brevity\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external nonReentrant {\n        uint256 bal = balances[msg.sender];\n        if (bal &lt; amount) revert InsufficientBalance();\n\n        // Effects first\n        balances[msg.sender] = bal - amount;\n\n        // Then interaction\n        bool ok = token.transfer(msg.sender, amount);\n        if (!ok) revert TransferFailed();\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li>Uses <code>nonReentrant</code> modifier from OpenZeppelin\u2019s <code>ReentrancyGuard</code>.</li> <li>Applies checks-effects-interactions pattern to minimize reentrancy windows.</li> <li>Checks transfer return value and reverts on failure.</li> </ul>","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/#2025-case-study","title":"2025 Case Study","text":"<ul> <li>GMX (July 2025, $42M loss)   GMX V1 contracts were exploited via a classic yet sophisticated reentrancy vector in <code>executeDecreaseOrder</code>. The function accepted the attacker's smart contract address as a parameter; when it transferred control to that address during the refund process, the attacker re-entered and manipulated global average short prices, AUM, and GLP valuations. State updates after external calls and lack of reentrancy guards enabled the drain. The vulnerability was introduced in 2022 as an unaudited patch.  </li> <li>https://blog.solidityscan.com/gmx-v1-hack-analysis-ed0ab0c0dd0f</li> <li>https://www.halborn.com/blog/post/explained-the-gmx-hack-july-2025</li> <li>https://blog.verichains.io/p/gmx-42m-exploit-root-cause-analysis</li> </ul>","tags":[]},{"location":"sctop10/SC08-ReentrancyAttacks/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Use <code>ReentrancyGuard</code> or similar reentrancy locks on stateful functions that:</li> <li>Modify balances or internal accounting.</li> <li>Perform external calls that could re-enter the contract.</li> <li>Follow checks-effects-interactions:</li> <li>Check preconditions.</li> <li>Apply all state changes.</li> <li>Only then call external contracts.</li> <li>Treat ERC-777 hooks, ERC-4626 hooks, and other callbacks as reentrancy vectors.</li> <li>Carefully review:</li> <li>Cross-function interactions (e.g., <code>deposit</code> calling <code>withdraw</code> internally).</li> <li>Multi-contract systems where reentrancy may occur across modules, not just within a single contract.</li> <li>Include reentrancy-focused fuzzing and unit tests, especially where external calls are involved.</li> </ul>","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/","title":"SC09:2026 Integer Overflow and Underflow","text":"","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#vulnerability-integer-overflow-and-underflow","title":"Vulnerability: Integer Overflow and Underflow","text":"","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#description","title":"Description","text":"<p>Integer overflow and underflow describe situations where arithmetic operations produce values outside the representable range of the operand type. In Solidity 0.8+, arithmetic is checked by default and reverts on overflow/underflow. However, explicit <code>unchecked</code> blocks, assembly, or custom libraries can disable these checks. On non-EVM platforms (e.g., Move, Sui, Solana, Rust-based chains), default overflow semantics differ\u2014some wrap silently, some abort\u2014and incorrect assumptions or flawed custom checks can lead to wrapped values, miscomputed balances, and broken invariants.</p> <p>This affects all contract types that perform arithmetic: DeFi (pool invariants, balances, interest, shares), NFTs (supply, token IDs), bridges (amounts, sequence numbers), and any logic involving large or user-controlled numeric inputs. The impact is especially severe when overflow/underflow breaks economic invariants (e.g., k = x * y in AMMs) or enables balance manipulation.</p> <p>Few areas to focus on:</p> <ul> <li>EVM/Solidity (use of <code>unchecked</code>, assembly, pre-0.8 codebases)</li> <li>Non-EVM chains (Move, Sui, Aptos, Solana, etc.) and their default overflow semantics</li> <li>Multiplication and exponentiation (high risk of overflow with large operands)</li> <li>Subtraction and decrement (underflow when subtrahend &gt; minuend)</li> <li>Casting and type conversion (downcasting uint256 to uint128, etc.)</li> </ul> <p>Attackers exploit:</p> <ul> <li>Unchecked blocks in Solidity where overflow/underflow is assumed impossible but edge cases exist</li> <li>Non-EVM semantics where silent wrap or custom checks can be bypassed</li> <li>Large or crafted inputs that trigger overflow in multiplication or addition chains</li> <li>Invariant-breaking values (e.g., overflow producing a small k that passes naive checks)</li> </ul>","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#example-1-solidity-pre-08-overflow-evm","title":"Example 1: Solidity Pre-0.8 Overflow (EVM)","text":"<p>In Solidity versions before 0.8.0, arithmetic overflow and underflow occurred silently\u2014no revert, no error. Values wrapped around (e.g., <code>uint8</code> 255 + 1 = 0). Solidity 0.8.0+ fixes this by default; overflow/underflow reverts unless explicitly wrapped in <code>unchecked</code>.</p> <p>Vulnerable (Solidity 0.7.x):</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ncontract VulnerableToken {\n    mapping(address =&gt; uint256) public balances;\n\n    function transfer(address to, uint256 amount) external {\n        // UNDERFLOW: if balances[msg.sender] &lt; amount, wraps to huge value\n        balances[msg.sender] -= amount;  // Silent underflow!\n        balances[to] += amount;          // Silent overflow possible\n    }\n}\n</code></pre> <p>Fixed (Option A\u2014SafeMath for 0.7.x):</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract SafeToken {\n    using SafeMath for uint256;\n    mapping(address =&gt; uint256) public balances;\n\n    function transfer(address to, uint256 amount) external {\n        balances[msg.sender] = balances[msg.sender].sub(amount);  // Reverts on underflow\n        balances[to] = balances[to].add(amount);                   // Reverts on overflow\n    }\n}\n</code></pre> <p>Fixed (Option B\u2014Upgrade to Solidity 0.8+):</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SafeToken {\n    mapping(address =&gt; uint256) public balances;\n\n    function transfer(address to, uint256 amount) external {\n        balances[msg.sender] -= amount;  // Reverts on underflow (checked by default)\n        balances[to] += amount;          // Reverts on overflow\n    }\n}\n</code></pre> <p>Key takeaway: Solidity 0.8.0+ provides built-in overflow/underflow checks. Use <code>unchecked</code> only when you have strong guarantees; otherwise prefer checked arithmetic.</p>","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#example-2-cetus-protocolsuimove-non-evm","title":"Example 2: Cetus Protocol\u2014Sui/Move (Non-EVM)","text":"<p>On May 22, 2025, Cetus Protocol (largest DEX on Sui) lost ~$223M due to a flawed overflow check in the <code>integer-mate</code> library. In Move, addition and multiplication abort on overflow, but left shift (<code>&lt;&lt;</code>) does NOT abort\u2014it truncates silently. The protocol used a custom <code>checked_shlw</code> to guard a <code>&lt;&lt; 64</code> shift; the guard was wrong.</p> <p>Root cause: <code>checked_shlw</code> in <code>math_u256.move</code> used an incorrect threshold. It should reject values with any non-zero bits in the top 64 bits (i.e., <code>n &gt;= 1 &lt;&lt; 192</code>). The implementation used <code>n &gt; (0xFFFFFFFFFFFFFFFF &lt;&lt; 192)</code> instead, which is wrong and allowed values \u2265 2^192 to pass, then overflow on <code>n &lt;&lt; 64</code>.</p> <p>Vulnerable <code>checked_shlw</code> (integer-mate, Sui Move):</p> <pre><code>// integer-mate/sui/sources/math_u256.move\n// VULNERABLE: incorrect overflow threshold\npublic fun checked_shlw(n: u256): (u256, bool) {\n    let mask = 0xFFFFFFFFFFFFFFFF &lt;&lt; 192;  // WRONG! Produces wrong threshold\n    if (n &gt; mask) {\n        (0, true)   // Should signal overflow\n    } else {\n        ((n &lt;&lt; 64), false)  // Overflow occurs here for n &gt;= 2^192\u2014Move truncates silently\n    }\n}\n</code></pre> <p>Fixed <code>checked_shlw</code>:</p> <pre><code>// FIXED: correct overflow check\u2014reject if any bits in top 64 bits\npublic fun checked_shlw(n: u256): (u256, bool) {\n    // Correct: shifting left by 64 overflows if n &gt;= 2^192\n    if (n &gt;= 1 &lt;&lt; 192) {\n        (0, true)   // Overflow\u2014abort path\n    } else {\n        ((n &lt;&lt; 64), false)\n    }\n}\n</code></pre> <p>Where it was used: The CLMM function <code>get_delta_a</code> in <code>clmm_math.move</code> computed token A required for a liquidity position. It called:</p> <pre><code>let (numerator, overflowing) = math_u256::checked_shlw(\n    full_math_u128::full_mul(liquidity, sqrt_price_diff)\n);\nassert!(!overflowing);  // Assertion passed incorrectly due to flawed check\n</code></pre> <p>With <code>liquidity \u2248 2^113</code> and <code>sqrt_price_diff \u2248 2^79</code>, the product was <code>\u2248 2^192 + \u03b5</code>. The flawed <code>checked_shlw</code> allowed it through; <code>n &lt;&lt; 64</code> overflowed and truncated to a tiny value. The protocol then computed that only 1 unit of token A was needed to mint massive liquidity (~10^37 units), enabling the drain.</p> <p>Attack flow (simplified): Flash swap \u2192 open narrow tick position \u2192 call <code>add_liquidity</code> with crafted liquidity parameter \u2192 undercharged (1 token) while credited huge liquidity \u2192 remove liquidity \u2192 drain pools \u2192 repay flash swap.</p>","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#example-3-solidity-08-with-unchecked-explicit-opt-out","title":"Example 3: Solidity 0.8+ with <code>unchecked</code> (Explicit Opt-Out)","text":"<p>Even on Solidity 0.8+, <code>unchecked</code> disables checks. Use only when overflow/underflow is provably impossible:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract UncheckedExample {\n    function bad(uint256 x, uint256 y) external pure returns (uint256) {\n        unchecked {\n            return x * y;  // Can overflow; no revert\n        }\n    }\n\n    function good(uint256 x) external pure returns (uint256) {\n        unchecked {\n            return x - 1;  // Safe only if caller ensures x &gt;= 1\n        }\n    }\n}\n</code></pre> <p>Avoid <code>unchecked</code> for user-controlled or unbounded inputs unless you have formal reasoning or tests proving safety.</p>","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#2025-case-study-cetus-may-2025-223m-loss","title":"2025 Case Study: Cetus (May 2025, $223M loss)","text":"<p>Cetus Protocol on Sui was exploited via a flawed <code>checked_shlw</code> in the shared <code>integer-mate</code> library. The function was meant to prevent u256 overflow when shifting left by 64 bits during CLMM liquidity calculations. The overflow check used the wrong threshold (<code>0xFFFFFFFFFFFFFFFF &lt;&lt; 192</code> instead of <code>1 &lt;&lt; 192</code>), allowing values \u2265 2^192 to pass. In Move, left shift does not abort on overflow\u2014it truncates. The truncated numerator caused <code>get_delta_a</code> to return that only 1 token was required to mint enormous liquidity. Attackers repeated this across pools using flash swaps, draining ~$223M. Key lessons: (1) Move shift operations do not abort on overflow; (2) custom overflow guards must be rigorously verified; (3) shared math libraries are high-risk and need formal analysis. - https://dedaub.com/blog/the-cetus-amm-200m-hack-how-a-flawed-overflow-check-led-to-catastrophic-loss/ - https://www.cyfrin.io/blog/inside-the-223m-cetus-exploit-root-cause-and-impact-analysis - https://www.halborn.com/blog/post/explained-the-cetus-hack-may-2025 - https://blog.verichains.io/p/cetus-protocol-hacked-analysis</p>","tags":[]},{"location":"sctop10/SC09-IntegerOverflowUnderflow/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>On Solidity/EVM:</li> <li>Avoid <code>unchecked</code> arithmetic unless you have strong reasons and tests proving safety.</li> <li>Use explicit checks and custom errors for critical invariants.</li> <li>Favor well-reviewed math libraries (for fixed-point, exponentiation, etc.).</li> <li>On non-EVM environments (e.g., Move, Rust-based chains):</li> <li>Understand the language\u2019s default overflow semantics.</li> <li>Use safe arithmetic constructs or libraries where available.</li> <li>Add assertions and invariants around critical arithmetic.</li> <li>Test with extreme value ranges:</li> <li>Minimum and maximum values for all numeric types.</li> <li>Fuzz tests that target edge cases (near boundaries where overflow/underflow is likely).</li> </ul>","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/","title":"SC10:2026 Proxy & Upgradeability Vulnerabilities","text":"","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#vulnerability-proxy-upgradeability-vulnerabilities","title":"Vulnerability: Proxy &amp; Upgradeability Vulnerabilities","text":"","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#description","title":"Description","text":"<p>Proxy and upgradeability vulnerabilities describe any situation where a smart contract uses an upgradeable architecture (proxy, beacon, or implementation-swapping pattern) and the upgrade path, initialization, or admin controls are misdesigned or misconfigured. Upgradeable contracts separate a proxy (which holds state and delegates calls) from an implementation (which contains logic). When upgradeability is improperly secured, attackers can hijack the proxy admin or upgrade role to deploy malicious implementations, re-initialize contracts to seize ownership, or bypass critical checks in initialization or migration steps.</p> <p>This affects all contract types that use upgradeability: DeFi (lending, vaults, DEXes), NFTs (collections, marketplaces), DAOs (governance, treasuries), bridges (messengers, asset contracts), and L2/cross-chain systems. Common patterns include Transparent Proxy, UUPS (EIP-1822), Beacon Proxy, and custom router-implementation designs. On non-EVM chains, analogous upgrade mechanisms exist (e.g., Move modules, Solana program upgrades) with similar trust and initialization risks.</p> <p>Few areas to focus on:</p> <ul> <li>Upgrade and admin roles (who can change the implementation, storage layout compatibility)</li> <li>Initialization and re-initialization (unprotected <code>initialize</code>, missing <code>initializer</code> guards, storage collisions)</li> <li>Proxy delegation (<code>delegatecall</code> context, <code>msg.sender</code>/<code>msg.value</code> propagation)</li> <li>Storage layout (slot collisions between proxy and implementation, append-only storage)</li> <li>Timelocks and governance (upgrade process, rollback capability)</li> </ul> <p>Attackers exploit:</p> <ul> <li>Unprotected upgrade functions that allow any caller to point the proxy to a malicious implementation</li> <li>Re-initialization to reset ownership, configuration, or access controls</li> <li>Initialization through delegatecall where implementation can be initialized with attacker-controlled parameters</li> <li>Storage collision between proxy and implementation leading to overwrites</li> </ul> <p>These issues often overlap with access control (SC01) but warrant separate attention due to the systemic impact of proxy and upgrade mechanisms.</p>","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#example-vulnerable-upgradeable-proxy-admin","title":"Example (Vulnerable Upgradeable Proxy Admin)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract VulnerableProxyAdmin {\n    address public admin;\n    address public implementation;\n\n    constructor(address _implementation) {\n        // Critical: no way to set custom admin; implicitly trusts deployer logic\n        admin = msg.sender;\n        implementation = _implementation;\n    }\n\n    function upgrade(address newImplementation) external {\n        // Missing: access control (only admin) and sanity checks\n        implementation = newImplementation;\n    }\n}\n</code></pre> <p>Issues:</p> <ul> <li>No access control on <code>upgrade</code>; any caller can change <code>implementation</code>.</li> <li>No checks on <code>newImplementation</code> (e.g., interface compatibility, non-zero address).</li> </ul>","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#example-safer-upgradeability-pattern","title":"Example (Safer Upgradeability Pattern)","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SafeProxyAdmin is Ownable {\n    address public implementation;\n\n    event Upgraded(address indexed newImplementation);\n\n    error InvalidImplementation();\n\n    constructor(address _implementation) {\n        _setImplementation(_implementation);\n        _transferOwnership(msg.sender);\n    }\n\n    function _setImplementation(address _implementation) internal {\n        if (_implementation == address(0)) revert InvalidImplementation();\n        implementation = _implementation;\n    }\n\n    function upgrade(address newImplementation) external onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n}\n</code></pre> <p>Security Improvements:</p> <ul> <li><code>upgrade</code> is restricted to the contract owner (which should itself be a robust governance or multisig).</li> <li>Implementation addresses are validated and upgrades are logged via events.</li> </ul>","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#initialization-re-initialization-risks","title":"Initialization &amp; Re-Initialization Risks","text":"<p>Initialization functions (e.g., <code>initialize()</code>, <code>initializer</code> modifiers in OpenZeppelin) are critical in upgradeable patterns. Common pitfalls:</p> <ul> <li>Unprotected initializers that anyone can call.</li> <li>Re-initialization that can reset ownership, configuration, or state.</li> <li>Initialization logic that can be reached through delegatecalls from proxies in unintended ways.</li> </ul> <p>Basic example:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract VulnerableLogic {\n    address public owner;\n\n    // Missing initializer guard\n    function initialize(address _owner) external {\n        owner = _owner;\n    }\n}\n</code></pre> <p>If used behind a proxy without proper initialization control, attackers can call <code>initialize</code> via the proxy and set themselves as owner, taking over the protocol.</p>","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#2025-case-studies","title":"2025 Case Studies","text":"<ul> <li> <p>Kinto Protocol (July 2025, $1.55M loss)   Attackers exploited uninitialized ERC1967 proxy contracts. They detected freshly deployed proxy contracts that had not been properly initialized, then initialized them with malicious implementations containing dormant backdoors. Months later, the attacker activated the backdoor, upgraded the proxy to malicious code, and minted K tokens directly to drain $1.55M. The vulnerability: unprotected initialization allowing anyone to become the proxy admin.  </p> </li> <li> <p>Uninitialized Proxy Campaign (2025, $10M+ across protocols)   A broader campaign targeted uninitialized ERC1967 proxies across multiple EVM chains. Attackers used automated scanning to detect newly deployed proxies before legitimate developers could initialize them, then initialized with malicious implementations. The backdoors lay dormant for months, evading audits. When activated, attackers could upgrade proxies and drain funds.  </p> </li> <li>https://audita.io/blog-articles/the-proxy-hack-uninitialized-contracts-costing-defi-10m-in-losses</li> <li>https://medium.com/mamori-finance/post-mortem-k-proxy-hack-our-path-forward-c2c3809882c6</li> </ul>","tags":[]},{"location":"sctop10/SC10-ProxyAndUpgradeabilityVulnerabilities/#best-practices-mitigations","title":"Best Practices &amp; Mitigations","text":"<ul> <li>Use well-established proxy patterns and libraries (e.g., OpenZeppelin UUPS/transparent proxies) instead of bespoke designs.</li> <li>Protect upgrade and admin roles with robust governance / multisigs; never leave them on EOAs without strong operational controls.</li> <li>Apply initializer guards:</li> <li>Use <code>initializer</code> and <code>reinitializer</code> modifiers correctly.</li> <li>Lock implementation contracts once deployed to prevent direct initialization.</li> <li>Require timelocks and multi-step processes for upgrades:</li> <li>Announce upgrade proposals.</li> <li>Allow time for review/monitoring before execution.</li> <li>Maintain comprehensive upgrade runbooks and checklists, including:</li> <li>Testing of migrations.</li> <li>Verification of new implementation code and storage layout.</li> <li>On-chain simulation of upgrade steps where possible.</li> </ul>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/","title":"Alternate Top 15: Web3 Attack Vectors (Beyond Smart Contracts)","text":"<p>This list complements the OWASP Smart Contract Top 10 : 2026 by cataloguing significant non-smart-contract attack vectors in the Web3 space. These threats target infrastructure, custody, social layers, and operational security rather than on-chain logic.</p> <p>Scope &amp; Purpose: This is an awareness list for protocols, Web3 users, stakeholders, and the CXO suite to look out for. It is not ranked by losses, frequency, or any statistics\u2014ordering does not imply relative severity or prevalence. Use it alongside the OWASP Smart Contract Top 10 for a broader view of Web3 security risks.</p> Future Development <p>This list will be developed, ranked, and maintained in the near future. Methodology, data sources, and update cycles will be established as the OWASP Smart Contract Top 10 project evolves. Stakeholder feedback and incident data will inform future iterations.</p> <p></p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa01-multisig-hijacking","title":"WA01 \u2014 Multisig Hijacking","text":"<p>Description: Attackers manipulate the signing interface or approval flow so that signers approve transactions without clearly seeing what they authorise. Blind signing, UI spoofing, and malicious JavaScript injected into wallet frontends allow attackers to trick multisig operators into executing delegatecalls or upgrades that hand over control.</p> <p>2025 Example: Malicious code was injected into Safe{Wallet}'s signing interface (app.safe.global), attributed to a breached Safe{Wallet} developer machine. Signers saw one transaction but executed another\u2014a delegatecall to an attacker-controlled contract. Hardware wallets typically lack the ability to parse complex Safe transactions, enabling blind signing. Similar techniques target DAO treasuries and custody setups.</p> <p>Case Study: Bybit $1.5B \u2014 Largest Crypto Heist in History (Feb 2025) </p> <p>The Bybit hack remains the largest crypto heist by amount stolen in 2025 and in recorded history (~$1.5B, ~401,000 ETH). The FBI attributes operation \"TraderTraitor\" to North Korea's Lazarus group. Bybit used Safe{Wallet} for its Ethereum multisig cold wallet. Attackers compromised Safe{Wallet}'s developer infrastructure (via a breached developer machine; AWS S3/CloudFront credentials likely exposed) and injected malicious JavaScript into app.safe.global. When Bybit's signers approved a cold-to-warm transfer, the compromised UI presented a legitimate-looking transaction but executed a delegatecall to an attacker-controlled contract instead. Funds were drained; at least $300M had been laundered by March 2025. Third-party audits (Sygnia, Verichains) confirmed the root cause was malicious code from Safe{Wallet}'s infrastructure\u2014not Bybit's own systems. This incident illustrates how multisig hijacking can target high-value CEX custody; see also WA07.</p> <p>References:</p> <ul> <li>BlockSec \u2014 Bybit $1.5B Hack: In-Depth Analysis of the Malicious Safe Wallet Upgrade Attack</li> <li>BleepingComputer \u2014 Lazarus hacked Bybit via breached Safe{Wallet} developer machine</li> <li>Trail of Bits \u2014 Maturing your smart contracts beyond private key risk (Radiant, WazirX, Bybit case studies)</li> </ul> <p>Key lessons: Never trust signing UIs blindly; verify transaction calldata independently; use hardware signing with display verification; audit frontend and CDN integrity.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa02-supply-chain-attacks-npm-pypi-oss","title":"WA02 \u2014 Supply Chain Attacks (npm, PyPI, OSS)","text":"<p>Description: Attackers compromise open-source package registries (npm, PyPI) to distribute crypto-draining malware, credential stealers, clipboard hijackers, or cryptominers. Malicious code executes in the same context as browser wallets or CI pipelines, enabling theft of keys, keystores, and on-chain authorisations.</p> <p>Examples: (1) Sept 2025 \u2014 chalk/npm: A phishing campaign (npmjs[.]help) targeting the <code>chalk</code> maintainer led to malware in 18 packages (&gt;2B weekly downloads). The payload hooked <code>fetch</code>, <code>XMLHttpRequest</code>, and <code>window.ethereum</code> to intercept wallet transactions across multiple chains. (2) Dec 2023 \u2014 Ledger Connect Kit: Compromised npm package (versions 1.1.5\u20131.1.7) injected wallet-draining code; a phished former Ledger employee's npm access was the initial vector. Affected 100+ dApps including SushiSwap, Revoke.cash; ~$600K lost. Approximately 75% of blockchain-related malicious packages tracked by Socket in 2025 were on npm.</p> <p>References:</p> <ul> <li>Sygnia \u2014 16 Minutes to Impact: npm Supply Chain Abuse Deploys crypto-draining malware</li> <li>Socket.dev \u2014 Ledger Connect Kit Supply Chain Attack</li> <li>Socket.dev \u2014 2025 Blockchain and Cryptocurrency Threat Report</li> </ul> <p>Key lessons: Lock dependencies; use lockfiles and reproducible builds; verify package integrity; monitor for typosquatting and dependency confusion.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa03-private-key-compromise-pkc","title":"WA03 \u2014 Private Key Compromise (PKC)","text":"<p>Description: Private keys or seed phrases are stolen or leaked through phishing, malware, weak entropy, ECDSA nonce reuse, or implementation bugs. Chainalysis reports that PKC was responsible for 43.8% of funds stolen via hacks in 2024\u2014more than any other single vector. CertiK documented ~$239M in PKC losses in 2024 (1,160% YoY increase).</p> <p>2024 Examples: Ripple co-founder Chris Larsen lost ~$112M (Jan 2024) after private keys were compromised. PlayDapp (~$32.3M), FixedFloat (~$26M), and nine incidents in March 2024 alone (&gt;$22M combined) further illustrate the scale.</p> <p>References:</p> <ul> <li>Chainalysis \u2014 Crypto Hacking and Stolen Funds 2025</li> <li>CertiK \u2014 Major Private Key Compromises</li> <li>Trail of Bits \u2014 Maturing your smart contracts beyond private key risk</li> </ul> <p>Key lessons: Use HSMs and secure key storage; avoid key reuse; implement MPC or multisig for high-value ops; rotate keys; audit cryptographic implementations.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa04-drainer-malware-drainer-as-a-service-daas","title":"WA04 \u2014 Drainer Malware &amp; Drainer-as-a-Service (DaaS)","text":"<p>Description: Crypto drainers are toolkits or services that deploy phishing sites and fake dApps to trick users into granting malicious contracts permission to transfer assets (<code>approve</code>, <code>setApprovalForAll</code>, <code>permit</code>). No private key theft required\u2014social engineering plus on-chain permission abuse. Distinct from general approval phishing (WA06): drainers are packaged, sold as kits or DaaS subscriptions ($500\u2013$10K) on Telegram and darknet forums.</p> <p>2025 Stats: Scam Sniffer's 2024 report states wallet drainers stole $494 million (67% YoY increase), affecting 332,000+ wallet addresses. Largest single theft: $55.4 million; 30 incidents exceeded $1M each. Research using SilentPush identified 122 drainer domains Jan\u2013Jul 2025, 54 active. Notable kits: Inferno ($81M), MS Drainer ($59M), Venom ($27M). Targets: MetaMask, Phantom, Solflare, WalletConnect, Ledger, Coinbase Wallet.</p> <p>References:</p> <ul> <li>Scam Sniffer \u2014 2024 Web3 Phishing Attacks &amp; Wallet Drainers</li> <li>BleepingComputer \u2014 Cryptocurrency wallet drainers stole $494 million in 2024</li> <li>Decode Cybercrime \u2014 Crypto Drainers of 2025: The Rising Web of Wallet Theft</li> </ul> <p>Key lessons: Scrutinise all approval requests; avoid unlimited approvals; use revoke.cash\u2013style tools; blocklist known drainer domains and contracts.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa05-fake-interview-video-call-social-engineering","title":"WA05 \u2014 Fake Interview &amp; Video Call Social Engineering","text":"<p>Description: Attackers pose as employers or journalists, invite targets to fake interviews (Zoom, custom meeting apps), and abuse remote-control features to install malware or gain system access. Once in control, they steal wallets, credentials, and initiate unauthorised crypto transactions.</p> <p>2025 Examples: - GrassCall: BleepingComputer reports Russian-speaking group \"Crazy Evil\" posted fake jobs for \"ChainSeeker.io\" on CryptoJobsList and WellFound. Applicants downloaded malicious \"GrassCall\" meeting software that installed info-stealing malware (Rhadamanthys on Windows, AMOS Stealer on macOS); hundreds reported drained wallets. Recorded Future attributes $5M+ stolen through similar scams since 2021. - ELUSIVE COMET: Trail of Bits and Malwarebytes document fake \"Bloomberg Crypto\" interviews via X and Calendly (bloombergconferences@gmail.com). Attackers used Zoom's remote control feature, renaming themselves to \"Zoom\" so the permission prompt appeared legitimate, granting full system access for malware deployment and credential theft.</p> <p>References:</p> <ul> <li>BleepingComputer \u2014 GrassCall malware campaign drains crypto wallets via fake job interviews</li> <li>Trail of Bits \u2014 Mitigating ELUSIVE COMET Zoom remote control attacks</li> <li>Malwarebytes \u2014 Zoom attack tricks victims into allowing remote access</li> <li>SEAL \u2014 Advisory on ELUSIVE COMET</li> </ul> <p>Key lessons: Verify interviewer identity through official channels; avoid downloading custom meeting software; treat remote-control requests with extreme suspicion.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa06-uiux-spoofing-approval-phishing","title":"WA06 \u2014 UI/UX Spoofing &amp; Approval Phishing","text":"<p>Description: Attackers create spoofed or cloned sites (e.g., OpenSea, Uniswap) or misleading prompts that trick users into signing transactions granting malicious contracts spending authority (<code>approve</code>, <code>setApprovalForAll</code>, <code>permit</code>, or Permit2). Users believe they are claiming an airdrop, minting an NFT, or swapping\u2014they instead grant unlimited token/NFT transfer rights. Chainalysis estimated at least $374M stolen via approval phishing in 2023. Emerging vector: EIP-7702 <code>SetCode</code> delegation scams, where users are tricked into \"upgrading\" their wallet but grant full control to a malicious contract.</p> <p>References:</p> <ul> <li>Chainalysis \u2014 Approval Phishing Scams 2023</li> <li>Security Alliance \u2014 Using EIP-7702 (Wallet Security)</li> <li>Gate.io \u2014 Permit, Uniswap Permit2, and Signature Phishing</li> <li>MetaMask \u2014 Signature Phishing</li> </ul> <p>Key lessons: Verify URLs; use bookmark preferred sites; avoid unlimited approvals; carefully review signing content; watch for high-risk signature popups.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa07-centralised-exchange-web225-infrastructure-breaches","title":"WA07 \u2014 Centralised Exchange &amp; Web2/2.5 Infrastructure Breaches","text":"<p>Description: Custody, exchange infrastructure, and operational security failures\u2014not smart contract bugs\u2014cause the largest single losses. Cold/warm wallet procedures, internal tooling, and human error are exploited. Web2.5 (hybrid centralised\u2013decentralised) systems inherit both on-chain and off-chain risks.</p> <p>2025 Example: Bybit $1.5B (February 2025)\u2014largest crypto heist in history. FBI attributes the operation \"TraderTraitor\" to North Korean Lazarus group. Attackers compromised Safe{Wallet} infrastructure (via breached developer machine) and injected malicious code into app.safe.global; Bybit signers using Safe unknowingly approved a wallet upgrade transaction. ~401,000 ETH stolen; funds drained within 13 blocks. At least $300M had been laundered by March 2025. IC3 PSA 2025.</p> <p>References:</p> <ul> <li>BBC \u2014 North Korean hackers cash out hundreds of millions from $1.5bn ByBit hack</li> <li>BleepingComputer \u2014 FBI confirms Lazarus hackers were behind $1.5B Bybit crypto heist</li> <li>IC3 \u2014 North Korea Responsible for $1.5 Billion Bybit Hack</li> <li>BlockSec \u2014 Bybit $1.5B Hack: In-Depth Analysis</li> </ul> <p>Key lessons: Segregate custody; use specialised security tooling; enforce M-of-N signing with independent verification; audit infra and processes.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa08-phishing-general-social-engineering","title":"WA08 \u2014 Phishing &amp; General Social Engineering","text":"<p>Description: Phishing emails, fake support sites, and impersonation trick users into revealing seed phrases, recovery phrases, or passwords. Unlike approval phishing (WA06) or drainer sites (WA04), these attacks aim to steal credentials directly\u2014once obtained, attackers have full control. AI has increased scale and sophistication in 2024\u20132025.</p> <p>2024 Example: Fake Ledger data-breach emails (Dec 2024) impersonating \"support@ledger.com\" claimed recovery phrases were exposed and directed users to a fake Ledger site to \"verify\" their 24-word phrase. Credential phishing targets seed phrases, not on-chain approvals.</p> <p>References:</p> <ul> <li>BleepingComputer \u2014 Fake Ledger data breach emails try to steal crypto wallets</li> <li>Elliptic \u2014 The State of Crypto Scams 2025</li> <li>Ledger Support \u2014 Beware of phishing attempts</li> </ul> <p>Key lessons: Never share seed phrases or private keys; Ledger/support will never ask for recovery phrases; verify official channels; use hardware wallets; enable 2FA; avoid clicking links in unsolicited messages.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa09-romance-investment-impersonation-recovery-pig-butchering-scams","title":"WA09 \u2014 Romance, Investment, Impersonation, Recovery &amp; Pig Butchering Scams","text":"<p>Description: Social-engineering scams that exploit trust, urgency, or authority to trick victims into sending crypto. Multiple techniques overlap:</p> <ul> <li>Romance &amp; pig butchering: Long-term romance or friendship scams where attackers build trust over weeks or months, then direct victims to fake investment platforms. A February 2024 study (Griffin &amp; Mei, University of Texas) estimated more than $75 billion stolen worldwide (Jan 2020\u2013Feb 2024). Often involves call centers and human trafficking victims forced to operate scams. Chainalysis reports pig butchering accounted for 33.2% of crypto scam revenue in 2024, ~40% YoY growth.</li> <li>Investment scams: Fake trading platforms, Ponzi schemes, and \u201cguaranteed returns\u201d that lure victims to deposit crypto. Investment fraud accounted for ~71% of crypto-related losses in 2023 per some estimates.</li> <li>Impersonation scams: Fraudsters pose as exchange support, government officials, influencers, or law enforcement. FBI warnings cite exchange impersonators requesting credentials via unsolicited calls; fake law firms and government impersonators pressure victims to pay \u201cfees\u201d or \u201cback taxes.\u201d</li> <li>Recovery scams: Scammers target victims who were already drained, posing as law firms or \u201crecovery services\u201d to extract more. IC3 reported recovery scams exceeding $9.9M (Feb 2023\u2013Feb 2024).</li> <li>Giveaway scams: \u201cSend 1 ETH, get 2 back\u201d\u2013style offers via spoofed influencer accounts or livestreams.</li> </ul> <p>References:</p> <ul> <li>TIME \u2014 Pig-Butchering Scam $75 Billion</li> <li>Chainalysis \u2014 Pig Butchering Scam Revenue 2024</li> <li>IC3 \u2014 Fictitious Law Firms Targeting Crypto Scam Victims</li> <li>IC3 \u2014 Scammers Impersonating Cryptocurrency Exchanges</li> <li>Elliptic \u2014 The State of Crypto Scams 2025</li> </ul> <p>Key lessons: Be wary of unsolicited investment advice; avoid sending crypto to unknown platforms; never pay upfront \u201crecovery\u201d fees; verify identity through official channels (call back via published numbers); ignore giveaway offers from social media or livestreams.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa10-rug-pulls-fake-airdrops-token-impersonation","title":"WA10 \u2014 Rug Pulls, Fake Airdrops &amp; Token Impersonation","text":"<p>Description: Fraudulent token launches, fake airdrops, and token impersonation (same name/logo as legitimate projects) lure users into buying or claiming. Rug pulls remove liquidity or dump; fake airdrop claim pages often drain via malicious approvals (overlaps with WA04/WA06). Token impersonators create fake versions of trending or legitimate tokens.</p> <p>2023-2024 Examples: Omni Network (Apr 2024)\u2014legitimate OMNI airdrop coincided with scammers launching a fake OMNI token that rugged 100%. Blockfence research identified 1,300+ fake token rug pulls on Ethereum stealing &gt;$32M from ~42,000 victims, impersonating projects (e.g., Blockfence, Wisealth) and memecoins (Pepe variants).</p> <p>References:</p> <ul> <li>CoinTelegraph \u2014 Omni token dumps after airdrop as scammers rug fake token</li> <li>Blockfence \u2014 $32M Stolen: Over 1,300 Fake Tokens Rugged</li> <li>MetaMask \u2014 Rug pulls and airdrop scams</li> </ul> <p>Key lessons: Verify contract addresses and official links; avoid FOMO-driven connects; use blocklists for known scam tokens and domains.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa11-wrench-attacks-physical-coercion","title":"WA11 \u2014 Wrench Attacks &amp; Physical Coercion","text":"<p>Description: Attackers bypass technical controls entirely by threatening, kidnapping, or physically coercing key individuals (founders, operators, whales) to authorise transfers, reveal seed phrases, or sign governance actions. Traditional \u201c$5 wrench attacks\u201d have Web3-specific variants, including in-person extortion and forced travel to jurisdictions with weaker protections.</p> <p>2020\u20132024 Examples: Academic research from UCL\u2019s AFT 2024 paper \u201cInvestigating Wrench Attacks\u201d catalogues dozens of physical attacks against cryptocurrency holders, including home invasions, kidnappings, and extortion cases across Europe and Asia, many of which remain under-reported. AP reporting and industry commentary highlight Ledger co-founder kidnapping attempts and rising \u201cwrench attack\u201d risk during bull markets.</p> <p>References:</p> <ul> <li>UCL / AFT 2024 \u2014 Investigating Wrench Attacks: Physical Attacks Targeting Cryptocurrency Users</li> <li>AP News \u2014 Why \u2018wrench attacks\u2019 on wealthy crypto holders are on the rise</li> <li>Cointelegraph \u2014 Can panic wallets stop a wrench?</li> </ul> <p>Key lessons: Treat high-value keys like physical cash; minimise human single points of failure; use time-locked withdrawals, duress-wallet patterns, spend limits, and geography-aware controls; train staff on physical security and incident response.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa12-insider-threats-collusive-abuse","title":"WA12 \u2014 Insider Threats &amp; Collusive Abuse","text":"<p>Description: Employees, contractors, or trusted partners abuse legitimate access to wallets, admin panels, RPC infrastructure, or deployment pipelines to steal funds or exfiltrate secrets. Collusion with external attackers can turn otherwise \u201csecure\u201d controls (multisig, approval workflows) into rubber stamps if signers or approvers are compromised or bribed.</p> <p>Examples: An insider at Solana\u2019s Cypher Protocol admitted to stealing ~$300K in 2024 by abusing privileged access to protocol keys and treasury flows. A former employee of New Zealand exchange Cryptopia kept customer data after being laid off and later stole ~NZD 245,000 in crypto from user accounts, demonstrating how departed staff can remain a live threat without rigorous offboarding.</p> <p>References:</p> <ul> <li>CoinDesk \u2014 Insider at Solana\u2019s Cypher Protocol Admits to Stealing $300K</li> <li>The Block \u2014 Ex-employee pleads guilty to stealing over $170,000 from Cryptopia</li> </ul> <p>Key lessons: Apply least-privilege and segregation of duties; require independent verification for large movements; log and monitor administrative actions; rotate roles and access; run background checks and enforce strong offboarding procedures.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa13-dns-domain-routing-infrastructure-hijacking","title":"WA13 \u2014 DNS, Domain &amp; Routing Infrastructure Hijacking","text":"<p>Description: Compromise of DNS providers, domain registrar accounts, BGP routes, or CDN configurations lets attackers silently redirect traffic from legitimate dApps, wallets, bridges, and exchanges to cloned phishing sites. Even technically sophisticated users can be tricked when real domains temporarily resolve to malicious infrastructure.</p> <p>Examples: In 2022, attackers gained access to Namecheap DNS settings for DeFi projects including Convex, Ribbon, and DeFiSaver, injecting malicious code that prompted users for unlimited approvals and stole &gt;$500K. In May 2024, Curve Finance reported repeated DNS hijacks of <code>curve.fi</code>, where users were redirected to wallet-draining phishing pages despite the underlying smart contracts remaining uncompromised.</p> <p>References:</p> <ul> <li>Revoke.cash \u2014 Namecheap DNS Hijack Exploit Breakdown</li> <li>Cointelegraph / TradingView \u2014 Curve Finance warns its DNS has been hijacked again</li> </ul> <p>Key lessons: Lock registrar accounts (2FA, hardware keys, registry locks); monitor DNS and TLS certificate changes; use multi-region, multi-provider DNS; deploy phishing-resistant browser protections and content-security policies.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa14-wallet-software-extension-app-compromises","title":"WA14 \u2014 Wallet Software, Extension &amp; App Compromises","text":"<p>Description: Exploiting bugs or supply-chain weaknesses in wallet desktop apps, mobile apps, and browser extensions enables attackers to bypass UI safeguards, inject malicious signing prompts, or silently approve transactions. Malicious updates, compromised signing keys, or 0-days in wallet code can instantly endanger all users who install the affected version.</p> <p>2025 Example: In late 2025, attackers abused stolen Chrome Web Store API credentials from Trust Wallet\u2019s infrastructure (\u201cShai-Hulud\u201d supply-chain attack) to publish a malicious 2.68 version of the Trust Wallet browser extension, which exfiltrated seed phrases disguised as analytics traffic and drained an estimated $7\u20138.5M from thousands of users. Related campaigns in the same window compromised additional Chrome extensions, illustrating the systemic risk of extension-store access keys.</p> <p>References:</p> <ul> <li>Trust Wallet \u2014 Browser Extension v2.68 Incident: Community Update</li> <li>Rescana \u2014 Trust Wallet Chrome Extension Supply Chain Attack</li> <li>SecurityWeek \u2014 Several Chrome Extensions Compromised in Supply Chain Attack</li> </ul> <p>Key lessons: Prefer audited, open-source wallets with secure release processes; verify app publishers; enable automatic revocation or rollback mechanisms; monitor wallet security advisories and rotate devices when compromise is suspected.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#wa15-nation-state-infiltration-via-fake-hiring-malicious-oss-contributions","title":"WA15 \u2014 Nation-State Infiltration via Fake Hiring &amp; Malicious OSS Contributions","text":"<p>Description: State-backed groups infiltrate crypto and Web3 ecosystems by posing as legitimate developers or employers, using fake job interviews, recruiter personas, and seemingly benign open source contributions or npm packages to compromise developer machines, CI pipelines, and production infrastructure. Once inside, they steal keys, cloud credentials, and source code, or poison software supply chains to facilitate large-scale exchange and protocol heists.</p> <p>2022\u20132025 Examples: North Korea\u2013linked Lazarus subgroup \u201cTraderTraitor\u201d has repeatedly targeted blockchain and crypto firms with fake hiring campaigns and DeFi-themed open source projects, seeding malicious npm packages that delivered infostealers (e.g., BeaverTail / InvisibleFerret) to developer laptops. U.S. DOJ actions in 2025 highlighted at least 136 victim companies and $2.2M+ in illicit wages funneled to Pyongyang, with over $15M in crypto seized across related cases; among them, an Atlanta blockchain R&amp;D company that unknowingly hired four DPRK developers who then stole &gt;$900K in cryptocurrency. The same cluster of activity has been tied to multi-hundred-million-dollar thefts including the DMM Bitcoin hack (~$308M, May 2024) and the Bybit $1.5B incident, where compromised developer infrastructure and poisoned software supply chains played a central role.</p> <p>References:</p> <ul> <li>Wiz \u2014 TraderTraitor: Deep Dive into North Korea\u2019s $1.5B Crypto Heists</li> <li>Stacklok \u2014 Dependency Hijacking: North Korea\u2019s New Wave of DeFi-Themed Open Source Attacks</li> <li>lazarusholic \u2014 Inside the GitHub Infrastructure Powering North Korea\u2019s \u201cContagious Interview\u201d npm Attacks</li> <li>U.S. DOJ \u2014 Major Enforcement Actions Targeting North Korean Remote IT Worker Schemes</li> <li>Reuters \u2014 North Koreans Use Fake Names, Scripts to Land Remote IT Work</li> <li>CoinDesk \u2014 How North Korea Infiltrated the Crypto Industry</li> <li>Chainalysis / Google Threat Intelligence / Mandiant \u2014 DPRK IT Worker Schemes (joint reporting and advisories)</li> </ul> <p>Key lessons: Treat unsolicited hiring outreach and \u201ccontribution offers\u201d with suspicion; isolate development and CI environments; enforce strict review and provenance checks on new dependencies and OSS contributions; monitor for anomalous developer activity and outbound traffic; plan for nation-state\u2013class adversaries in threat models for high-value protocols and exchanges.</p>","tags":[]},{"location":"sctop10/Web3-Attack-Vectors-Top15/#summary-table","title":"Summary Table","text":"ID Attack Vector Primary Target Example WA01 Multisig Hijacking Custody, multisig operators Safe{Wallet} signing UI compromise WA02 Supply Chain (npm, PyPI) Developers, wallet users chalk/npm Sept 2025, Ledger Connect Kit 2023 WA03 Private Key Compromise Key holders, infra Chris Larsen $112M, PlayDapp, FixedFloat WA04 Drainer Malware / DaaS End users, retail $494M (2024), Inferno $81M, MS Drainer $59M WA05 Fake Interview / Video Call Social Eng. Job seekers, executives GrassCall, ELUSIVE COMET WA06 Deceptive dApp Interfaces &amp; Approval Phishing End users Spoofed OpenSea/Uniswap, Permit2, EIP-7702 WA07 CEX &amp; Web2/2.5 Infrastructure Exchanges, custodians Bybit $1.5B (largest heist) WA08 Phishing &amp; General Social Engineering Broad Fake Ledger support emails (Dec 2024) WA09 Romance, Investment, Impersonation, Recovery &amp; Pig Butchering Scams Retail, vulnerable users Pig butchering ~$75B, recovery scams $9.9M+ WA10 Rug Pulls, Fake Airdrops &amp; Token Impersonation Retail, degens Omni fake token, 1,300 fake tokens $32M WA11 Wrench Attacks &amp; Physical Coercion Key individuals, executives Kidnapping, extortion for seed phrases WA12 Insider Threats &amp; Collusive Abuse Teams, custodians, DAOs Rogue employee drains treasury WA13 DNS, Domain &amp; Routing Hijacking dApps, exchanges, wallets DNS hijack redirects to phishing frontends WA14 Wallet Software &amp; Extension Compromise Wallet users Malicious wallet update injects drain prompts WA15 Nation-State Infiltration via Fake Hiring &amp; Malicious OSS Contributions Devs, infra, protocols DPRK \u201cTraderTraitor\u201d fake hiring &amp; npm attacks","tags":[]},{"location":"sctop10/data-sources/","title":"Data Sources for the 2026 Ranking","text":"<p>The OWASP Smart Contract Top 10 2026 draws on multiple data sources to ensure the ranking reflects both practitioner judgment and real-world incident trends. This page documents those sources and how they inform the final list.</p>","tags":[]},{"location":"sctop10/data-sources/#primary-practitioner-survey","title":"Primary: Practitioner Survey","text":"","tags":[]},{"location":"sctop10/data-sources/#survey-design","title":"Survey Design","text":"<p>A structured, anonymised survey was conducted by OWASP SCS Team to collect practitioner rankings of risk categories. The survey targeted:</p> Primary Contributors Secondary Contributors Smart contract auditors Incident response teams Protocol security leads Bug bounty triagers L1/L2 infrastructure security teams Red team / blue team practitioners Wallet and custody security engineers","tags":[]},{"location":"sctop10/data-sources/#survey-content","title":"Survey Content","text":"<p>Respondents were asked to:</p> <ol> <li>Assign ranks (1\u201310) to each risk category, where 1 = highest risk.</li> <li>Describe factors that influenced their ranking (e.g., frequency in production, ease of exploitation, size of losses).</li> <li>Suggest additional or emerging risk categories not captured by the current list.</li> <li>Indicate their confidence in the ranking provided.</li> </ol>","tags":[]},{"location":"sctop10/data-sources/#survey-link","title":"Survey Link","text":"<p>The survey remains open for ongoing data collection:</p> <p>Participate in the 2026 Top 10 Survey</p>","tags":[]},{"location":"sctop10/data-sources/#data-handling","title":"Data Handling","text":"<ul> <li>Responses are anonymised for public reporting.</li> <li>Aggregated insights (e.g., mean ranks, tier distributions) are used to inform the ranking.</li> <li>Individual responses or identities are not shared publicly unless explicitly consented.</li> </ul>","tags":[]},{"location":"sctop10/data-sources/#secondary-2025-incident-data","title":"Secondary: 2025 Incident Data","text":"","tags":[]},{"location":"sctop10/data-sources/#real-world-incidents","title":"Real-World Incidents","text":"<p>The 2026 list is forward-looking and grounded in 2025 security incidents. High-impact breaches and exploit classifications from 2025 were used to:</p> <ul> <li>Validate and refine the ordering suggested by survey responses</li> <li>Identify emerging categories (e.g., Proxy &amp; Upgradeability, Arithmetic Errors)</li> <li>Assign appropriate prominence to categories that drove large losses</li> </ul>","tags":[]},{"location":"sctop10/data-sources/#incident-databases","title":"Incident Databases","text":"","tags":[]},{"location":"sctop10/data-sources/#1-solidityscan-web3hackhub","title":"1. SolidityScan Web3HackHub","text":"<p>Comprehensive database of blockchain-related incidents, attack vectors, and financial losses. Documents breaches from 2011 onward.</p> <p>Learn about Hacks &amp; Prevent Attacks</p> <p></p>","tags":[]},{"location":"sctop10/data-sources/#2-slowmist-web3-hacked","title":"2. SlowMist Web3 Hacked","text":"<p>SlowMist's curated database of Web3 security incidents and hacks.</p> <p>SlowMist Hacked</p>","tags":[]},{"location":"sctop10/data-sources/#3-defi-attack-vectors-for-2025-video","title":"3. DeFi Attack Vectors for 2025 (Video)","text":"<p>Video analysis of the top DeFi attack vectors by risk for 2025.</p> <p>Watch on YouTube</p>","tags":[]},{"location":"sctop10/data-sources/#4-defihacklabs-incident-explorer","title":"4. DeFiHackLabs Incident Explorer","text":"<p>Explore and analyse DeFi hack incidents. Reproduce incidents using Foundry via GitHub.</p> <p>DeFi Hack Incidents Explorer</p>","tags":[]},{"location":"sctop10/data-sources/#5-blocksec-security-incident-library","title":"5. BlockSec Security Incident Library","text":"<p>Crypto security incidents library with searchable incident data.</p> <p>BlockSec Security Incidents</p> <p>Embedding notice</p> <p>Some external sites may block embedding (X-Frame-Options). If a preview does not load, use the link above to open the source directly.</p>","tags":[]},{"location":"sctop10/data-sources/#other-references","title":"Other References","text":"Source Description Public breach reports and post-mortems Protocol-specific incident analyses (e.g., Balancer, GMX, Cetus, zkLend, Bunni, Abracadabra, Yearn, ResupplyFi, Cork Protocol, Ionic Money, NGP Token). Security research and DeFi attack summaries Community and vendor analyses of prevalent attack vectors and trends.","tags":[]},{"location":"sctop10/data-sources/#2025-incident-categories-illustrative","title":"2025 Incident Categories (Illustrative)","text":"<p>Incident data from 2025 highlighted the following categories as drivers of major losses:</p> <ul> <li>Access Control: Balancer V2 (~$128M), Zoth ($8.4M)</li> <li>Business Logic: Abracadabra ($12.9M), Yearn Finance ($9M)</li> <li>Price Oracle Manipulation: NGP Token (~$2M), GMX (oracle component of $42M)</li> <li>Flash Loan\u2013Facilitated: Bunni ($8.4M), zkLend ($9.5M)</li> <li>Lack of Input Validation: Cetus ($223M), Ionic Money (~$6.9M)</li> <li>Unchecked External Calls / Reentrancy: GMX ($42M), Cork Protocol ($12M)</li> <li>Arithmetic Errors: zkLend ($9.5M), Bunni ($8.4M)</li> <li>Integer Overflow: Cetus ($223M on Sui/Move)</li> <li>Proxy &amp; Upgradeability: ResupplyFi ($9.8M)</li> </ul> <p>These figures informed the relative weighting and inclusion of categories in the final 2026 Top 10.</p>","tags":[]},{"location":"sctop10/data-sources/#total-lost-value-tlv-reports","title":"Total Lost Value (TLV) Reports","text":"<p>The following reports provide aggregated data on total value lost to exploits, hacks, and fraud in Web3. They are used to contextualise incident impact and validate category prominence.</p>","tags":[]},{"location":"sctop10/data-sources/#1-solidityscan-credshields-2025-annual-report-state-of-web3-security-2025","title":"1. SolidityScan / CredShields 2025 Annual Report \u2014 State of Web3 Security 2025","text":"<p>View on Google Drive</p>","tags":[]},{"location":"sctop10/data-sources/#2-beosin-2025-global-web3-security-report","title":"2. Beosin 2025 Global Web3 Security Report","text":"<p>Download PDF</p> <p>2025 Web3 total losses: $3.375B across 313 incidents (hacks, phishing, rug pulls).</p> <p></p>","tags":[]},{"location":"sctop10/data-sources/#3-slowmist-blockchain-security-and-aml-annual-report-2025","title":"3. SlowMist Blockchain Security and AML Annual Report 2025","text":"<p>Download PDF</p> <p>Distribution of causes for security incidents in 2025\u2014contract vulnerability, account compromise, oracle attacks, and more.</p> <p></p>","tags":[]},{"location":"sctop10/data-sources/#4-hackenproof-web3-security-report-2025","title":"4. HackenProof Web3 Security Report 2025","text":"<p>HackenProof's Web3 security report for 2025. DocSend viewer\u2014open in new tab for full document preview.</p> <p>View HackenProof Report</p>","tags":[]},{"location":"sctop10/data-sources/#5-quillaudits-exploited-ledgers-the-web3-hack-report-2025","title":"5. QuillAudits Exploited Ledgers: The Web3 Hack Report 2025","text":"<p>QuillAudits' annual report on exploited DeFi protocols. DocSend viewer\u2014open in new tab for full document preview.</p> <p>View QuillAudits Report</p>","tags":[]},{"location":"sctop10/data-sources/#6-scamsniffer-2025-crypto-phishing-losses-fall-83-to-84-million","title":"6. ScamSniffer 2025: Crypto Phishing Losses Fall 83% to $84 Million","text":"<p>Read on Scam Sniffer</p>","tags":[]},{"location":"sctop10/data-sources/#tertiary-qualitative-and-expert-input","title":"Tertiary: Qualitative and Expert Input","text":"","tags":[]},{"location":"sctop10/data-sources/#free-text-survey-responses","title":"Free-Text Survey Responses","text":"<p>Qualitative responses from the survey were analysed for recurring themes:</p> <ul> <li>Upgradeability and proxy risk</li> <li>Economic and incentive design flaws</li> <li>Cross-chain and bridge failures</li> <li>Supply-chain and dependency risks</li> <li>Operational and governance failures</li> </ul>","tags":[]},{"location":"sctop10/data-sources/#expert-review","title":"Expert Review","text":"<p>Community maintainers and contributors reviewed the preliminary statistical ordering against:</p> <ul> <li>Practitioner narratives from the survey</li> <li>Published security research and DeFi attack summaries</li> <li>Alignment with OWASP and industry terminology</li> </ul>","tags":[]},{"location":"sctop10/data-sources/#2025-incident-data-summary","title":"2025 Incident Data Summary","text":"","tags":[]},{"location":"sctop10/data-sources/#data-sources","title":"Data Sources","text":"Source Incidents Description Role in Analysis SolidityScan Web3HackHub 130+ Primary incident database with attack type classifications Primary source for calculated totals BlockSec Security Incidents 74 Root-cause classified incidents (Precision Loss, Access Control Issue, etc.) Primary source; provides precise root-cause labels SlowMist Hacked 200+ (filtered) Annotated database; filtered to smart-contract-vector incidents only Primary source; adds smart-contract-filtered incidents DeFiHackLabs 88+ PoC-focused repository; Foundry-based incident reproductions Reference/comparison; validates incident coverage <p>Total analyzed: 122 unique protocols (deduplicated across SolidityScan, BlockSec, SlowMist) Total loss: $905.4M (smart-contract-vector only; excludes phishing, CEX, rugpulls)</p> <p>Note: DeFiHackLabs provides proof-of-concept reproductions and incident documentation but is not included in the calculated totals table. It serves as a validation source\u2014incidents appearing in DeFiHackLabs (e.g., HegicOptions $104M, MIM_Spell $1.7M\u2013$13.4M) are cross-referenced with other sources. Many incidents documented in SolidityScan, BlockSec, or SlowMist are not present in DeFiHackLabs (e.g., Cetus $260M, UPCX $70M, Stream Finance $93M), indicating complementary coverage across databases.</p>","tags":[]},{"location":"sctop10/data-sources/#major-hacks-2025","title":"Major Hacks (2025)","text":"Protocol Loss Category Source Cetus $260M SC09 (Integer Overflow) SolidityScan, BlockSec, SlowMist Balancer V2 $128M SC07 (Precision Loss) SolidityScan, BlockSec UPCX $70M SC01 (Access Control) SolidityScan Infini $50M SC01 (Access Control) SolidityScan, SlowMist UXLINK $48M SC01 (Access Control) SolidityScan GMX $42M SC08 (Reentrancy) SolidityScan, BlockSec, SlowMist Stream Finance $93M SC02 (Business Logic) SolidityScan zkLend $9.5M SC07 (Precision Loss) BlockSec, SolidityScan Yearn Finance $9M SC02 (Business Logic) BlockSec, SlowMist Resupply $9.5M SC07 (Precision Loss) All sources Cork Protocol $12M SC01 (Access Control) All sources (including DeFiHackLabs) Abracadabra $13M SC04 (Flash Loan) BlockSec, SlowMist MIM_Spell $13.4M SC02 (Business Logic) BlockSec, DeFiHackLabs HegicOptions $104M SC02 (Business Logic) DeFiHackLabs, BlockSec","tags":[]},{"location":"sctop10/data-sources/#calculated-totals-by-category","title":"Calculated Totals by Category","text":"OWASP Category Total Loss Major Incidents SC01 - Access Control $220.0M UPCX, Infini, UXLINK, Cork SC02 - Business Logic $188.7M Stream Finance, GMX, MIM_Spell, Yearn SC09 - Integer Overflow $260.4M Cetus, LeverageSIR, Bankroll SC07 - Arithmetic Errors $138.1M Balancer, Resupply, zkLend SC04 - Flash Loan $27.8M Abracadabra, zkLend, Shibarium SC08 - Reentrancy $42.1M GMX, StepHeroNFTs SC03 - Price Oracle $20.7M Odin.fun, Loopscale, Moonwell SC05 - Input Validation $4.1M Arcadia, ZeUSD SC10 - Proxy &amp; Upgradeability $2.9M Morpho Blue, iEarn SC06 - Unchecked External Calls $552K Silo","tags":[]},{"location":"sctop10/data-sources/#ranking-justification","title":"Ranking Justification","text":"<p>The OWASP Top 10 2026 ranking is primarily driven by practitioner survey mean rank, with 2025 incident data serving as validation:</p> <ul> <li>SC01 (Access Control) \u2014 Ranked #1 by survey; #2 in total loss ($220M), #2 in frequency (30 incidents) \u2192 Strong alignment</li> <li>SC02 (Business Logic) \u2014 Ranked #2 by survey; #3 in total loss ($188.7M), #1 in frequency (58 incidents, 47.5%) \u2192 Strong alignment</li> <li>SC09 (Integer Overflow) \u2014 Ranked #9 by survey; #1 in total loss ($260.4M) but only 3 incidents \u2192 Ranking reflects low frequency despite high impact</li> </ul> <p>Key insight: Survey prioritizes frequency and pervasiveness (SC01, SC02) over single-incident outliers (SC09, SC07). This aligns with practitioner focus on preventing common vulnerabilities rather than rare but catastrophic events.</p>","tags":[]},{"location":"sctop10/data-sources/#calculation-methodology","title":"Calculation Methodology","text":"<ol> <li>Data Collection: Incidents extracted from SolidityScan, BlockSec, and SlowMist Datasets. DeFiHackLabs used for reference and validation (not included in totals).</li> <li>Deduplication: Protocols appearing in multiple sources use the maximum reported amount; category preference: BlockSec &gt; SlowMist &gt; SolidityScan when amounts equal.</li> <li>Filtering: Excludes phishing, CEX infrastructure breaches, rugpulls, and private-key-compromise incidents (non\u2013smart-contract vectors).</li> <li>Mapping: Attack types mapped to OWASP categories using source-specific root-cause labels (e.g., \"Access Control Issue\" \u2192 SC01, \"Precision Loss\" \u2192 SC07, \"Contract Vulnerability\" \u2192 SC02).</li> <li>Aggregation: Totals calculated per category; incident counts reflect unique protocols.</li> </ol> <p>DeFiHackLabs Analysis: DeFiHackLabs provides 88+ 2025 incidents with Foundry PoCs. Key incidents include HegicOptions ($104M, SC02), MIM_Spell/Abracadabra ($1.7M\u2013$13.4M, SC02), Cork Protocol ($12M, SC01), Resupply ($9.5M, SC07), and others. These are cross-referenced with other sources for validation. DeFiHackLabs focuses on reproducible PoCs rather than comprehensive incident coverage, which is why SolidityScan, BlockSec, and SlowMist are used for the primary calculated totals.</p>","tags":[]},{"location":"sctop10/data-sources/#risk-metrics-and-formulae","title":"Risk Metrics and Formulae","text":"<p>The following metrics are calculated for each OWASP category to inform ranking decisions.</p>","tags":[]},{"location":"sctop10/data-sources/#metric-definitions","title":"Metric Definitions","text":"Metric Formula (plain-text) What it means Total Value Lost (TVL) <code>TVL_j = \u03a3 A_i,j  for i = 1..n_j</code> Sum of all losses in USD for category <code>j</code> across its <code>n_j</code> incidents. Total Incidents (smart-contract only) <code>N_total = \u03a3 n_j  for j = 1..10</code> Count of unique smart contract incidents across all OWASP categories (after dedup). For 2025, <code>N_total = 122</code>. Frequency <code>F_j = (n_j / N_total) \u00d7 100%</code> Share of 2025 smart contract incidents that fall into category <code>j</code> (percentage). Likelihood (annual) <code>L_j = n_j / T</code> Incidents per year for category <code>j</code> over period <code>T</code> (here, <code>T = 1</code> year for 2025). Relative Likelihood <code>L_rel,j = n_j / max(n_1, \u2026, n_10)</code> Likelihood of category <code>j</code> relative to the most frequent category (0\u20131 scale). Average Loss per Incident <code>A\u0304_j = TVL_j / n_j</code> Mean loss size for incidents in category <code>j</code>. Ease of Exploitation (proxy) <code>E_j = (count of \\\"ease of exploitation\\\" mentions for j) / (total survey responses)</code> How often practitioners cite a category as easy to exploit (0\u20131 scale, derived from survey). Composite Risk Score <code>R_j = w_1\u00b7F_j + w_2\u00b7(TVL_j / TVL_max) + w_3\u00b7E_j</code> Combined score using frequency, impact, and ease of exploitation (example weights: <code>w_1 = 0.4</code>, <code>w_2 = 0.3</code>, <code>w_3 = 0.3</code>). <p>Examples (2025 data):</p> <ul> <li>SC01 (Access Control): <code>TVL_01 \u2248 $220.0M</code>, <code>n_01 = 30</code>.  </li> <li>SC02 (Business Logic): <code>n_02 = 58</code>, so <code>F_02 \u2248 58 / 122 \u2248 47.5%</code> (highest frequency / likelihood).  </li> <li>SC09 (Integer Overflow): <code>TVL_09 \u2248 $260.4M</code>, <code>n_09 = 3</code>, so <code>A\u0304_09 \u2248 $86.8M</code> per incident (high impact, low frequency).</li> </ul>","tags":[]},{"location":"sctop10/data-sources/#visual-relationship-of-metrics-conceptual","title":"Visual Relationship of Metrics (Conceptual)","text":"<pre><code>flowchart LR\n    A[\"Incidents per Category\"] --&gt; B[\"Total Incidents&lt;br/&gt;(N_total)\"]\n    A --&gt; C[\"Total Value Lost&lt;br/&gt;(TVL_j)\"]\n    A --&gt; D[\"Frequency&lt;br/&gt;(F_j)\"]\n    B --&gt; D\n    A --&gt; E[\"Likelihood&lt;br/&gt;(L_j)\"]\n    A --&gt; F[\"Average Loss&lt;br/&gt;(A\u0304_j)\"]\n    G[\"Survey Responses\"] --&gt; H[\"Ease of Exploitation&lt;br/&gt;(E_j)\"]\n    D --&gt; I[\"Composite Risk Score&lt;br/&gt;(R_j)\"]\n    C --&gt; I\n    H --&gt; I</code></pre> <p>The OWASP Smart Contract Top 10 2026 ultimately prioritises survey mean rank as the primary ordering signal, with these quantitative metrics used to validate and explain the final ranking.</p>","tags":[]},{"location":"sctop10/data-sources/#attribution","title":"Attribution","text":"<p>The survey and data collection for the 2026 ranking were coordinated by CredShields in collaboration with the OWASP Smart Contract Top 10 project. Data sources are attributed where applicable; methodology and statistics are documented in Methodology.</p>","tags":[]},{"location":"sctop10/methodology/","title":"Ranking Methodology","text":"<p>This methodology explains the conceptual framework and underlying calculations used to form the OWASP Smart Contract Top 10 2026. The process combines survey responses from practitioners with 2025 incident data and qualitative feedback to produce a transparent, reproducible ranking.</p>","tags":[]},{"location":"sctop10/methodology/#overview","title":"Overview","text":"<p>The aim is to make the ranking process transparent and reproducible:</p> <ul> <li>Individual survey responses are aggregated into per-category statistics (mean, median, standard deviation, etc.).</li> <li>The primary ordering is driven by mean rank, with supporting metrics used when categories are close.</li> <li>Qualitative input and 2025 breach data inform category definitions and refinements.</li> </ul>","tags":[]},{"location":"sctop10/methodology/#elicitation-model","title":"Elicitation Model","text":"","tags":[]},{"location":"sctop10/methodology/#risk-categories","title":"Risk Categories","text":"<p>The framework uses a fixed set of distinct risk categories. For the 2026 process, the survey and analysis covered categories including:</p> <ul> <li>Access Control Vulnerabilities</li> <li>Business Logic Vulnerabilities (Logic Errors)</li> <li>Price Oracle Manipulation</li> <li>Flash Loan\u2013Facilitated Attacks</li> <li>Lack of Input Validation</li> <li>Unchecked External Calls</li> <li>Reentrancy Attacks</li> <li>Arithmetic Errors / Integer Overflow and Underflow</li> <li>Proxy &amp; Upgradeability Vulnerabilities</li> <li>Insecure Randomness (later removed)</li> <li>Denial of Service (DoS) Attacks (later removed)</li> <li>Arithmetic Errors (added)</li> <li>Proxy &amp; Upgradeability Vulnerabilities (added)</li> </ul> <p>Respondents assign a rank from 1 to K to each category, where K is the total number of categories (for the Top 10, K = 10).</p>","tags":[]},{"location":"sctop10/methodology/#direction-of-the-scale","title":"Direction of the Scale","text":"<p>Ranks are interpreted in the conventional way:</p> <ul> <li>1 = highest risk / highest priority  </li> <li>K = lowest risk / lowest priority  </li> </ul> <p>No inversion, rescaling, or transformation of the raw ranks is performed. Lower numbers indicate greater perceived importance.</p>","tags":[]},{"location":"sctop10/methodology/#data-preparation","title":"Data Preparation","text":"","tags":[]},{"location":"sctop10/methodology/#structure-of-the-data","title":"Structure of the Data","text":"<p>Conceptually, the data is represented as a matrix R where:</p> <ul> <li>Each row corresponds to a single respondent</li> <li>Each column corresponds to a risk category</li> <li>r<sub>i,j</sub> is the rank assigned by respondent i to category j</li> </ul>","tags":[]},{"location":"sctop10/methodology/#cleaning-and-validation","title":"Cleaning and Validation","text":"<p>Before aggregation, the following steps are applied:</p> <ol> <li>Header detection: Identify the row containing column names (e.g., timestamp label).</li> <li>Row selection: Treat all subsequent non-empty rows as responses; ignore introductory text or metadata.</li> <li>Type checks: For each rank cell, strip whitespace and validate that it is an integer in the range {1, 2, \u2026, K}.</li> <li>Filtering: Treat non-numeric or out-of-range values as missing; exclude them from numerical calculations.</li> </ol> <p>These steps ensure that only well-formed ranking data is used in the analysis.</p>","tags":[]},{"location":"sctop10/methodology/#aggregation-of-rankings","title":"Aggregation of Rankings","text":"","tags":[]},{"location":"sctop10/methodology/#per-category-summary-statistics","title":"Per-Category Summary Statistics","text":"<p>For each category j, we consider the set of valid ranks S<sub>j</sub>. On this set we compute:</p> Statistic Description Mean rank Arithmetic mean; lower values indicate higher perceived risk on average. Median rank Middle value of the sorted sample; robust to outliers. Standard deviation Captures disagreement among respondents; larger values indicate more polarised views. Min / Max Range of observed ranks (e.g., whether a category was ever ranked 1 or 10). #rank1 Count of respondents who placed the category at rank 1. #top3 Count of respondents who placed the category in the top 3.","tags":[]},{"location":"sctop10/methodology/#primary-aggregation-metric","title":"Primary Aggregation Metric","text":"<p>The primary metric used to order categories is the mean rank:</p> <p>Lower mean rank \u21d2 higher place in the final Top 10.</p> <p>This choice:</p> <ul> <li>Respects the ordinal structure of the scale</li> <li>Incorporates the full distribution of responses</li> <li>Yields a simple, explainable ordering</li> </ul>","tags":[]},{"location":"sctop10/methodology/#supporting-metrics","title":"Supporting Metrics","text":"<p>When two categories have similar mean ranks, the following are used to refine the ordering:</p> <ul> <li>Median ranks \u2014 reveal skew and broad agreement</li> <li>Standard deviations \u2014 highlight polarised opinions</li> <li>#rank1 and #top3 \u2014 indicate intensity of concern (e.g., a category may be a frequent first choice even without the lowest mean)</li> </ul>","tags":[]},{"location":"sctop10/methodology/#how-the-statistics-are-computed","title":"How the Statistics Are Computed","text":"<p>For each category j, the following quantities are computed from the valid ranks S<sub>j</sub>:</p> Statistic Formula / Definition Mean rank r\u0304<sub>j</sub> = (1 / n<sub>j</sub>) \u00d7 \u03a3 r over r \u2208 S<sub>j</sub> Median Middle value of the sorted sample (or average of the two central values if n<sub>j</sub> is even) Standard deviation \u03c3<sub>j</sub> = \u221a[(1 / n<sub>j</sub>) \u00d7 \u03a3 (r \u2212 r\u0304<sub>j</sub>)\u00b2] Min / Max Minimum and maximum observed ranks in S<sub>j</sub> #rank1 Count of respondents who placed category j at rank 1 #top3 Count of respondents who placed category j at rank 1, 2, or 3 <p>Categories are ordered by ascending mean rank (lower mean \u21d2 higher place in the Top 10). The actual computed statistics depend on the survey data at the time of analysis; the formulas above define how they are derived.</p>","tags":[]},{"location":"sctop10/methodology/#from-statistics-to-the-final-ranked-list","title":"From Statistics to the Final Ranked List","text":"","tags":[]},{"location":"sctop10/methodology/#construction-procedure","title":"Construction Procedure","text":"<ol> <li>For each category, compute mean, median, standard deviation, and auxiliary counts.</li> <li>Sort categories by increasing mean rank to obtain a preliminary ordering.</li> <li>For categories with very similar mean ranks, use medians, dispersion, and #rank1/#top3 to decide on any refinements.</li> <li>Cross-check the statistical ordering against 2025 incident data and qualitative feedback to align with practitioner narratives and emerging themes.</li> </ol> <p>This approach is both data-driven and context-aware: numerical outputs guide the ordering, while qualitative and incident-based input prevents over-interpretation of small numerical differences.</p>","tags":[]},{"location":"sctop10/methodology/#risk-tiers","title":"Risk Tiers","text":"<p>Rather than treating the list as a strictly linear order, it is useful to think in terms of tiers:</p> <ul> <li>Top tier \u2014 Categories with the lowest mean ranks and high concentrations of rank-1 and top-3 placements (e.g., Access Control, Business Logic, Price Oracle Manipulation).</li> <li>Middle tier \u2014 Moderate mean ranks with less consensus (e.g., Flash Loan\u2013Facilitated Attacks, Lack of Input Validation).</li> <li>Tail \u2014 Consistently ranked lower but still important (e.g., Insecure Randomness, DoS).</li> </ul> <p>These tiers inform how much narrative emphasis and documentation each category receives.</p>","tags":[]},{"location":"sctop10/methodology/#qualitative-dimensions","title":"Qualitative Dimensions","text":"<p>The survey design includes free-text questions about:</p> <ul> <li>Factors influencing rankings (e.g., frequency in production, ease of exploitation, size of losses, difficulty of prevention, systemic impact).</li> <li>Additional or emerging risk categories not captured by the current list.</li> </ul> <p>Qualitative responses are tokenised, normalised, and clustered into themes such as:</p> <ul> <li>Upgradeability and proxy risk</li> <li>Economic and incentive design</li> <li>Cross-chain and bridge failures</li> <li>Supply-chain attacks</li> <li>Operational or governance failures</li> </ul> <p>These themes shape how categories are defined, described, and grouped in the final Top 10\u2014for example, informing the promotion of Proxy &amp; Upgradeability Vulnerabilities and Arithmetic Errors based on 2025 incident data, even when survey categories differed slightly.</p>","tags":[]},{"location":"sctop10/methodology/#related-pages","title":"Related Pages","text":"<ul> <li>Data Sources \u2014 Survey, incident databases, and external references used for the 2026 ranking.</li> </ul>","tags":[]},{"location":"sctop10/archive/2023/Top10%3A2023/","title":"Top10:2023","text":"","tags":[]},{"location":"sctop10/archive/2023/Top10%3A2023/#owasp-smart-contract-top-10-2023","title":"OWASP Smart Contract Top 10: 2023","text":"<ul> <li>SC01:2023 - Reentrancy Attacks</li> <li>SC02:2023 - Integer Overflow and Underflow</li> <li>SC03:2023 - Timestamp Dependence</li> <li>SC04:2023 - Access Control Vulnerabilities</li> <li>SC05:2023 - Front-running Attacks</li> <li>SC06:2023 - Denial of Service (DoS) Attacks</li> <li>SC07:2023 - Logic Errors</li> <li>SC08:2023 - Insecure Randomness</li> <li>SC09:2023 - Gas Limit Vulnerabilities</li> <li>SC10:2023 - Unchecked External Calls</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/","title":"SC01:2025 Access Control Vulnerabilities","text":"","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#vulnerability-improper-access-control","title":"Vulnerability: Improper Access Control","text":"","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#description","title":"Description:","text":"<p>An access control vulnerability is a security flaw that allows unauthorized users to access or modify the contract's data or functions. These vulnerabilities arise when the contract's code fails to adequately restrict access based on user permission levels. Access control in smart contracts can relate to governance and critical logic, such as minting tokens, voting on proposals, withdrawing funds, pausing and upgrading the contracts, and changing ownership.</p>","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_AccessControl {\n    mapping(address =&gt; uint256) public balances;\n\n    // Burn function with no access control\n    function burn(address account, uint256 amount) public {\n        require(balances[account] &gt;= amount, \"Insufficient balance\");\n        balances[account] -= amount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#impact","title":"Impact:","text":"<ul> <li>Attackers can gain unauthorized access to critical functions and data within the contract, compromising its integrity and security.</li> <li>Vulnerabilities can lead to the theft of funds or assets controlled by the contract, causing significant financial damage to users and stakeholders.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#remediation","title":"Remediation:","text":"<ul> <li>Ensure initialization functions can only be called once and exclusively by authorized entities.</li> <li>Use established access control patterns like Ownable or RBAC (Role-Based Access Control) in your contracts to manage permissions and ensure that only authorized users can access certain functions. This can be done by adding appropriate access control modifiers, such as <code>onlyOwner</code> or custom roles to sensitive functions.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import the Ownable contract from OpenZeppelin to manage ownership\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Solidity_AccessControl is Ownable {\n    mapping(address =&gt; uint256) public balances;\n\n    // Burn function with proper access control, only accessible by the contract owner\n    function burn(address account, uint256 amount) public onlyOwner {\n        require(balances[account] &gt;= amount, \"Insufficient balance\");\n        balances[account] -= amount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC01-AccessControlVulnerabilities/#examples-of-smart-contracts-that-fell-victim-to-improper-access-control-attacks","title":"Examples of Smart Contracts That Fell Victim to Improper Access Control Attacks:","text":"<ol> <li>HospoWise Hack : A Comprehensive Hack Analysis</li> <li>LAND NFT Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/","title":"SC02:2025 Price Oracle Manipulation","text":"","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#vulnerability-price-oracle-manipulation","title":"Vulnerability: Price Oracle Manipulation","text":"","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#description","title":"Description:","text":"<p>Price Oracle Manipulation is a critical vulnerability in smart contracts that rely on external data feeds (oracles) to fetch prices or other information. In decentralized finance (DeFi), oracles are used to provide real-world data, such as asset prices, to smart contracts. However, if the data provided by the oracle is manipulated, it can result in incorrect contract behavior. Attackers can exploit oracles by manipulating the data they supply, leading to devastating consequences such as unauthorized withdrawals, excessive leverage, or even draining liquidity pools. Proper safeguards and validation mechanisms are essential to prevent this type of attack. Example (Vulnerable contract):</p>","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#example-vulnerable-contract","title":"Example (Vulnerable Contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function getLatestPrice() external view returns (int);\n}\n\ncontract PriceOracleManipulation {\n    address public owner;\n    IPriceFeed public priceFeed;\n\n    constructor(address _priceFeed) {\n        owner = msg.sender;\n        priceFeed = IPriceFeed(_priceFeed);\n    }\n\n    function borrow(uint256 amount) public {\n        int price = priceFeed.getLatestPrice();\n        require(price &gt; 0, \"Price must be positive\");\n\n        // Vulnerability: No validation or protection against price manipulation\n        uint256 collateralValue = uint256(price) * amount;\n\n        // Borrow logic based on manipulated price\n        // If an attacker manipulates the oracle, they could borrow more than they should\n    }\n\n    function repay(uint256 amount) public {\n        // Repayment logic\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#impact","title":"Impact:","text":"<ul> <li>Attackers could manipulate the oracle to inflate the price of an asset, allowing them to borrow more funds than they would otherwise be entitled to.</li> <li>In cases where the manipulated price leads to a false assessment of collateral, legitimate users may face liquidation due to incorrect valuations.</li> <li>If an oracle is compromised, attackers can exploit the manipulated data to drain the contract\u2019s liquidity pools or even cause a contract to become insolvent.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#remediation","title":"Remediation:","text":"<ul> <li>Aggregate data from multiple, independent oracles to reduce the risk of manipulation by any single source.</li> <li>Set minimum and maximum thresholds for the prices received from the oracle to prevent drastic price swings from affecting the contract\u2019s logic.</li> <li>Introduce a time lock between price updates to prevent instant changes that could be exploited by attackers.</li> <li>Use cryptographic proofs to ensure the authenticity of data received from oracles, such as requiring signatures from trusted parties.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function getLatestPrice() external view returns (int);\n}\n\ncontract PriceOracleManipulation {\n    address public owner;\n    IPriceFeed public priceFeed;\n    int public minPrice = 1000; // Set minimum acceptable price\n    int public maxPrice = 2000; // Set maximum acceptable price\n\n    constructor(address _priceFeed) {\n        owner = msg.sender;\n        priceFeed = IPriceFeed(_priceFeed);\n    }\n\n    function borrow(uint256 amount) public {\n        int price = priceFeed.getLatestPrice();\n        require(price &gt; 0 &amp;&amp; price &gt;= minPrice &amp;&amp; price &lt;= maxPrice, \"Price manipulation detected\");\n\n        uint256 collateralValue = uint256(price) * amount;\n\n        // Borrow logic based on valid price\n    }\n\n    function repay(uint256 amount) public {\n        // Repayment logic\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC02-PriceOracleManipulation/#examples-of-smart-contracts-that-fell-victim-to-price-oracle-manipulation-attacks","title":"Examples of Smart Contracts that fell victim to Price Oracle Manipulation Attacks :","text":"<ol> <li>Polter Finance Hack Analysis </li> <li>BonqDAO Protocol : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/","title":"SC03:2025 Logic Errors","text":"","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#vulnerability-logic-errors","title":"Vulnerability: Logic Errors","text":"","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#description","title":"Description:","text":"<p>Logic errors, also known as business logic vulnerabilities, are subtle flaws in smart contracts. They occur when the contract's code does not match its intended behavior. These errors can manifest in various forms, such as faulty math in reward distribution, improper token minting mechanisms, or incorrect calculations in lending and borrowing logic. Such vulnerabilities are elusive, hiding within the contract's logic and waiting to be discovered.</p>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#examples-of-logic-errors","title":"Examples of Logic Errors:","text":"<ol> <li>Faulty Reward Distribution: Miscalculations in dividing rewards among stakeholders, leading to unfair allocations.</li> <li>Improper Token Minting: Unchecked or erroneous minting logic that allows infinite or unintended token generation.</li> <li>Lending Pool Imbalances: Incorrect tracking of deposits and withdrawals, causing inconsistencies in pool reserves.</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LogicErrors {\n    mapping(address =&gt; uint256) public userBalances;\n    uint256 public totalLendingPool;\n\n    function deposit() public payable {\n        userBalances[msg.sender] += msg.value;\n        totalLendingPool += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(userBalances[msg.sender] &gt;= amount, \"Insufficient balance\");\n\n        // Faulty calculation: Incorrectly reducing the user's balance without updating the total lending pool\n        userBalances[msg.sender] -= amount;\n\n        // This should update the total lending pool, but it's omitted here.\n\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    function mintReward(address to, uint256 rewardAmount) public {\n        // Faulty minting logic: Reward amount not validated\n        userBalances[to] += rewardAmount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#impact","title":"Impact:","text":"<ul> <li>Logic errors can cause a smart contract to behave unexpectedly or even become entirely unusable. These errors can lead to:</li> <li>Loss of Funds: Incorrect reward distribution or pool imbalances draining contract funds.</li> <li>Excessive Token Minting: Inflating token supply, undermining trust and value.</li> <li>Operational Failures: Contracts failing to perform their intended functions.</li> <li>These consequences can result in significant financial and operational losses for users and stakeholders.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#remediation","title":"Remediation:","text":"<ul> <li>Always validate your code by writing comprehensive test cases that cover all possible business logic scenarios.</li> <li>Conduct thorough code reviews and audits to identify and fix potential logic errors.</li> <li>Document the intended behavior of each function and module, and compare it to the actual implementation to ensure alignment.</li> <li>Implement guardrails, such as:</li> <li>Safe math libraries to prevent calculation errors.</li> <li>Proper checks and balances for token minting.</li> <li>Auditable reward distribution algorithms.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LogicErrors {\n    mapping(address =&gt; uint256) public userBalances;\n    uint256 public totalLendingPool;\n\n    function deposit() public payable {\n        userBalances[msg.sender] += msg.value;\n        totalLendingPool += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(userBalances[msg.sender] &gt;= amount, \"Insufficient balance\");\n\n        // Correctly reducing the user's balance and updating the total lending pool\n        userBalances[msg.sender] -= amount;\n        totalLendingPool -= amount;\n\n        (bool ok, ) = msg.sender.call{value: amount}(\"\");\n        require(ok, \"Transfer failed\");\n    }\n\n    function mintReward(address to, uint256 rewardAmount) public {\n        require(rewardAmount &gt; 0, \"Reward amount must be positive\");\n\n        // Safeguarded minting logic\n        userBalances[to] += rewardAmount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC03-LogicErrors/#examples-of-smart-contracts-that-fell-victim-to-business-logic-attacks","title":"Examples of Smart Contracts That Fell Victim to Business Logic Attacks:","text":"<ol> <li>Level Finance Hack : A Comprehensive Hack Analysis</li> <li>BNO Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/","title":"SC04:2025 Lack of Input Validation","text":"","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#vulnerability-lack-of-input-validation","title":"Vulnerability: Lack of Input Validation","text":"","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#description","title":"Description:","text":"<p>Input validation ensures that a smart contract processes only valid and expected data. When contracts fail to validate incoming inputs, they inadvertently expose themselves to security risks such as logic manipulation, unauthorized access, and unexpected behavior.For example, if a contract assumes user inputs are always valid without verification, attackers can exploit this trust to introduce malicious data. This lack of input validation compromises the security and reliability of the smart contract.</p>","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#example-vulnerable-contract","title":"Example (Vulnerable Contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LackOfInputValidation {\n    mapping(address =&gt; uint256) public balances;\n\n    function setBalance(address user, uint256 amount) public {\n        // The function allows anyone to set arbitrary balances for any user without validation.\n        balances[user] = amount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#impact","title":"Impact:","text":"<ul> <li>Attackers can manipulate inputs to drain funds, steal tokens, or cause other financial harm.</li> <li>Improper inputs can corrupt state variables, leading to unreliable and insecure contract behavior.</li> <li>Attackers may exploit the contract to perform unauthorized transactions or operations, impacting both the user and the broader system.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#remediation","title":"Remediation:","text":"<ul> <li>Ensure that inputs conform to the expected type.</li> <li>Validate that inputs fall within acceptable boundaries.</li> <li>Ensure that only authorized entities can invoke specific functions.</li> <li>Validate the structure of inputs, such as address formats or string lengths.</li> <li>Always halt execution and provide clear error messages when inputs fail validation.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LackOfInputValidation {\n    mapping(address =&gt; uint256) public balances;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not authorized\");\n        _;\n    }\n\n    function setBalance(address user, uint256 amount) public onlyOwner {\n        require(user != address(0), \"Invalid address\");\n        balances[user] = amount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC04-LackOfInputValidation/#examples-of-smart-contracts-that-fell-victim-to-attacks-due-to-lack-of-input-validation","title":"Examples of Smart Contracts that fell victim to attacks due to Lack of Input Validation:","text":"<ol> <li>Convergence Finance : A Comprehensive Hack Analysis</li> <li>Socket Gateway : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/","title":"SC05:2025 Reentrancy","text":"","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#vulnerability-reentrancy-attacks","title":"Vulnerability: Reentrancy Attacks","text":"","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#description","title":"Description:","text":"<p>A reentrancy attack exploits the vulnerability in smart contracts when a function makes an external call to another contract before updating its own state. This allows the external contract, possibly malicious, to reenter the original function and repeat certain actions, like withdrawals, using the same state. Through such attacks, an attacker can possibly drain all the funds from a contract.</p>","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount &gt; 0, \"Insufficient balance\");\n\n        // Vulnerability: Ether is sent before updating the user's balance, allowing reentrancy.\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        // Update balance after sending Ether\n        balances[msg.sender] = 0;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#impact","title":"Impact:","text":"<ul> <li>The most immediate and impactful consequence is the draining of funds. Attackers exploit vulnerabilities to withdraw more money than they are entitled to, potentially emptying the contract's balance completely.</li> <li>An attacker can trigger unauthorized function calls. This can lead to unintended actions being executed within the contract or related systems.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#remediation","title":"Remediation:","text":"<ul> <li>Always ensure that every state change happens before calling external contracts, i.e., update balances or code internally before calling external code.</li> <li>Use function modifiers that prevent reentrancy, like OpenZeppelin\u2019s Re-entrancy Guard.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount &gt; 0, \"Insufficient balance\");\n\n        // Fix: Update the user's balance before sending Ether\n        balances[msg.sender] = 0;\n\n        // Then send Ether\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC05-Reentrancy/#examples-of-smart-contracts-that-fell-victim-to-reentrancy-attacks","title":"Examples of Smart Contracts that fell victim to Reentrancy Attacks:","text":"<ol> <li>Rari Capital : A Comprehensive Hack Analysis</li> <li>Orion Protocol : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/","title":"SC06:2025 Unchecked External Calls","text":"","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#vulnerability-unchecked-external-calls","title":"Vulnerability: Unchecked External Calls","text":"","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#description","title":"Description:","text":"<p>Unchecked external calls refer to a security flaw where a contract makes an external call to another contract or address without properly checking the outcome of that call. In Ethereum, when a contract calls another contract, the called contract can fail silently without throwing an exception. If the calling contract doesn\u2019t check the return value, it might incorrectly assume the call was successful, even if it wasn't. This can lead to inconsistencies in the contract state and vulnerabilities that attackers can exploit.</p>","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Solidity_UncheckedExternalCall {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes memory _data) public {\n        require(callee.delegatecall(_data));\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#impact","title":"Impact:","text":"<ul> <li>Unchecked external calls can result in failed transactions, causing the intended operations to not be completed successfully. This can lead to the loss of funds, as the contract may proceed under the false assumption that the transfer was successful. Additionally, it can create an incorrect contract state, making the contract vulnerable to further exploits and inconsistencies in its logic.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#remediation","title":"Remediation:","text":"<ul> <li>Always check the return value of low-level calls (<code>call</code>, <code>delegatecall</code>, <code>staticcall</code>) and <code>send()</code> \u2014 do not assume success. Use <code>require(success, \"message\")</code> after <code>(bool success, ) = target.call{...}(...)</code>.</li> <li>For ETH transfers, prefer <code>call{value}(\"\")</code> with explicit success checks over <code>transfer()</code> or <code>send()</code> (see SCWE-079); <code>transfer()</code> has a 2300 gas stipend and can cause DoS when the recipient is a contract.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; \n\ncontract Solidity_UncheckedExternalCall {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes memory _data) public {\n        // Ensure that delegatecall succeeds\n        (bool success, ) = callee.delegatecall(_data);\n        require(success, \"Delegatecall failed\");  // Check the return value to handle failure\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC06-UncheckedExternalCalls/#examples-of-smart-contracts-that-fell-victim-to-unchecked-external-call-attacks","title":"Examples of Smart Contracts That Fell Victim to Unchecked External Call Attacks:","text":"<ol> <li>Punk Protocol Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/","title":"SC07:2025 Flash Loan Attacks","text":"","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/#vulnerability-flash-loan-attacks","title":"Vulnerability: Flash Loan Attacks","text":"","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/#description","title":"Description:","text":"<p>Flash loan attacks exploit the ability to borrow large sums of funds without collateral within a single transaction. These attacks leverage the atomic nature of blockchain transactions, where all operations must succeed or fail together. By combining flash loans with other vulnerabilities like oracle manipulation, reentrancy, or faulty logic, attackers can manipulate contract behavior and drain funds.</p>","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/#examples-of-flash-loan-exploits","title":"Examples of Flash Loan Exploits:","text":"<ol> <li>Oracle Manipulation: Using borrowed funds to skew price oracles, triggering under-collateralized liquidations.</li> <li>Liquidity Pool Draining: Leveraging flash loans to remove liquidity or exploit poorly designed AMM mechanics.</li> <li>Arbitrage Exploits: Exploiting price discrepancies across platforms by manipulating liquidity.</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/#impact","title":"Impact:","text":"<ul> <li>Loss of Funds: Exploiters can drain protocol reserves or manipulate collateralized loans to steal assets.</li> <li>Market Disruptions: Temporary price manipulation or liquidity depletion affecting users and platforms.</li> <li>Ecosystem Damage: Loss of trust in protocols, resulting in reduced user adoption and financial impact.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/#remediation","title":"Remediation:","text":"<ul> <li>Avoid reliance on flash loans in critical logic: Restrict sensitive functions to operate only within validated and predictable conditions.</li> <li>Robust Oracle Design: Use time-weighted average prices (TWAP) or decentralized oracles resistant to manipulation.</li> <li>Comprehensive Testing: Include tests simulating flash loan scenarios and edge cases.</li> <li>Access Control: Limit access to critical functions to prevent unauthorized or malicious transactions.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC07-FlashLoanAttacks/#examples-of-flash-loan-exploits_1","title":"Examples of Flash Loan Exploits:","text":"<ol> <li>UwUlend Hack: A Comprehensive Hack Analysis</li> <li>Doughfina Hack: A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/","title":"SC08:2025 Integer Overflow and Underflow","text":"","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#vulnerability-integer-overflow-and-underflow","title":"Vulnerability: Integer Overflow and Underflow","text":"","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#description","title":"Description:","text":"<p>Ethereum Virtual Machine (EVM) defines fixed-size data types for integers. This implies that the range of numbers that an integer variable can represent is finite.For instance, a \u201cuint8\u201d (unsigned integer of 8 bits; i.e., non-negative) can only store integers that fall between 0 and 255. The outcome of trying to store any value greater than 255 into an \u201cuint8\u201d will lead to an overflow. Similarly, the outcome of subtracting \u201c1\u201d from \u201c0\u201d will produce 255. This is called underflow.When an arithmetic operation exceeds or falls short of a type\u2019s maximum or minimum size, an overflow or underflow occurs.For signed integers, the outcome will be a bit different. If we try subtracting \u201c1\u201d from an int8 whose value is -128, we get 127. This is because signed int types, which may represent negative values, start over once we reach the highest negative value.Two straightforward examples of this behavior include periodic mathematical functions (adding 2 to the argument of sin leaves the value intact) and odometers in automobiles, which track distance traveled (they reset to 000000 after the maximum number, i.e., 999999, is exceeded).</p> <p>Important Note:- In Solidity <code>0.8.0</code> and above, the compiler automatically handles checking for overflows and underflows in arithmetic operations, reverting the transaction if an overflow or underflow occurs. Solidity <code>0.8.0</code> also introduces the <code>unchecked</code> keyword, which allows developers to perform arithmetic operations without these automatic checks, explicitly permitting overflow without reverting. This can be particularly useful for optimizing gas usage in cases where overflow is not a concern or where the wraparound behavior is desired, similar to how arithmetic behaved in earlier versions of Solidity.</p>","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.4.17;\n\ncontract Solidity_OverflowUnderflow {\n    uint8 public balance;\n\n    constructor() public {\n        balance = 255; // Maximum value of uint8\n    }\n\n    // Increments the balance by a given value\n    function increment(uint8 value) public {\n        balance += value; // Vulnerable to overflow\n    }\n\n    // Decrements the balance by a given value\n    function decrement(uint8 value) public {\n        balance -= value; // Vulnerable to underflow\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#impact","title":"Impact:","text":"<ul> <li>An attacker could exploit such vulnerabilities to artificially increase account balances or token amounts, potentially allowing them to withdraw more funds than they legitimately own.</li> <li>An attacker might alter the intended flow of contract logic, leading to unauthorized actions like stealing assets or minting an excessive number of tokens.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#remediation","title":"Remediation:","text":"<ul> <li>The simplest approach is to use Solidity compiler version 0.8.0 or higher, as it automatically handles overflow and underflow checks.</li> <li>Make Use of the latest Safe Math Libraries: For the Ethereum community, OpenZeppelin has done a fantastic job creating and auditing secure libraries. Its SafeMath library, in particular, can be used to prevent under/overflow vulnerabilities. It provides functions like add(), sub(), mul(), etc., that carry out basic arithmetic operations and automatically revert if an overflow or underflow occurs.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_OverflowUnderflow {\n    uint8 public balance;\n\n    constructor() {\n        balance = 255; // Maximum value of uint8\n    }\n\n    // Increments the balance by a given value\n    function increment(uint8 value) public {\n        balance += value; // Solidity 0.8.x automatically checks for overflow\n    }\n\n    // Decrements the balance by a given value\n    function decrement(uint8 value) public {\n        require(balance &gt;= value, \"Underflow detected\");\n        balance -= value;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC08-IntegerOverUnderFlow/#examples-of-smart-contracts-that-fell-victim-to-integer-overflow-and-underflow-attacks","title":"Examples of Smart Contracts that fell victim to Integer Overflow and Underflow Attacks:","text":"<ol> <li>PoWH Coin Ponzi Scheme : A Comprehensive Hack Analysis</li> <li>Poolz Finance : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/","title":"SC09:2025 Insecure Randomness","text":"","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#vulnerability-insecure-randomness","title":"Vulnerability: Insecure Randomness","text":"","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#description","title":"Description:","text":"<p>Random number generators are essential for applications like gambling, game-winner selection, and random seed generation. On Ethereum, generating random numbers is challenging due to its deterministic nature. Since Solidity cannot produce true random numbers, it relies on pseudorandom factors. Additionally, complex calculations in Solidity are costly in terms of gas.</p> <p>Insecure Mechanisms Create Random Numbers in Solidity: Developers often use block-related methods to generate random numbers, such as:   - block.timestamp: Current block timestamp.   - blockhash(uint blockNumber): Hash of a given block (only for the last 256 blocks).   - block.difficulty: Current block difficulty (post-merge/PoS: deprecated; use <code>block.prevrandao</code> instead \u2014 both are insecure for value-at-stake randomness).   - block.number: Current block number.   - block.coinbase: Address of the current block's proposer/validator (post-merge: no miners).</p> <p>These methods are insecure because validators (or miners on PoW chains) can manipulate them, affecting the contract's logic.</p>","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_InsecureRandomness {\n    constructor() payable {}\n\n    function guess(uint256 _guess) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(block.timestamp, block.difficulty, msg.sender) // Using insecure mechanisms for random number generation\n            ) \n        );\n\n        if (_guess == answer) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#impact","title":"Impact:","text":"<ul> <li>Insecure randomness can be exploited by attackers to gain an unfair advantage in games, lotteries, and any other contracts that rely on random number generation. By predicting or manipulating the supposedly random outcomes, attackers can influence the results in their favor. This can lead to unfair wins, financial losses for other participants, and a general lack of trust in the smart contract's integrity and fairness. </li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#remediation","title":"Remediation:","text":"<ul> <li>Using oracles (e.g., Chainlink VRF, Provable \u2014 formerly Oraclize) as external sources of randomness. Care should be taken while trusting the Oracle. Multiple Oracles can also be used.</li> <li>Using Commitment Schemes \u2014 A cryptographic primitive that uses a commit-reveal approach can be followed. It also has wide applications in coin flipping, zero-knowledge proofs, and secure computation. E.g.: RANDAO.</li> <li>Chainlink VRF \u2014 It is a provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability.</li> <li>The Signidice Algorithm \u2014 Suitable for PRNG in applications involving two parties using cryptographic signatures.</li> <li>Bitcoin Block Hashes \u2014 Oracles like BTCRelay can be used which act as a bridge between Ethereum and Bitcoin. Contracts on Ethereum can request future block hashes from the Bitcoin Blockchain as a source of entropy. It should be noted that this approach is not safe against the miner incentive problem and should be implemented with caution.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\"; // Note: Chainlink VRF V1 is deprecated; use VRF V2 (VRFConsumerBaseV2) in production\n\ncontract Solidity_InsecureRandomness is VRFConsumerBase {\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n\n    constructor(address _vrfCoordinator, address _linkToken, bytes32 _keyHash, uint256 _fee) \n        VRFConsumerBase(_vrfCoordinator, _linkToken) \n    {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n\n    function requestRandomNumber() public returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) &gt;= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n    }\n\n    function guess(uint256 _guess) public {\n        require(randomResult &gt; 0, \"Random number not generated yet\");\n        if (_guess == randomResult) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC09-InsecureRandomness/#examples-of-smart-contracts-that-fell-victim-to-insecure-randomness-attacks","title":"Examples of Smart Contracts That Fell Victim to Insecure Randomness Attacks:","text":"<ol> <li>Roast Football Hack : A Comprehensive Hack Analysis</li> <li>FFIST Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/","title":"SC10:2025 Denial Of Service","text":"","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/#vulnerability-denial-of-service","title":"Vulnerability: Denial Of Service","text":"","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/#description","title":"Description:","text":"<p>A Denial of Service (DoS) attack in Solidity involves exploiting vulnerabilities to exhaust resources like gas, CPU cycles, or storage, making a smart contract unusable. Common types include gas exhaustion attacks, where malicious actors create transactions requiring excessive gas, reentrancy attacks that exploit contract call sequences to access unauthorized funds, and block gas limit attacks that consume block gas, hindering legitimate transactions.</p>","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_DOS {\n    address public king;\n    uint256 public balance;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, \"Need to pay more to become the king\");\n\n        //If the current king has a malicious fallback function that reverts, it will prevent the new king from claiming the throne, causing a Denial of Service.\n        (bool sent,) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/#impact","title":"Impact:","text":"<ul> <li>A successful DoS attack can render the smart contract unresponsive, preventing users from interacting with it as intended. This can disrupt critical operations and services relying on the contract.</li> <li>DoS attacks can lead to financial losses, especially in decentralized applications (dApps) where smart contracts manage funds or assets.</li> <li>A DoS attack can tarnish the reputation of the smart contract and its associated platform. Users may lose trust in the platform's security and reliability, leading to a loss of users and business opportunities.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/#remediation","title":"Remediation:","text":"<ul> <li>Ensure smart contracts can handle consistent failures, such as asynchronous processing of potentially failing external calls, to maintain contract integrity and prevent unexpected behavior.</li> <li>Use pull-over-push pattern: instead of pushing ETH to the previous king (which can fail if they are a contract with a reverting fallback), record their pending balance and let them withdraw via a separate <code>withdraw()</code> function.</li> <li>Be cautious when using <code>call</code> for external calls, loops, and traversals to avoid excessive gas consumption, which could lead to failed transactions or unexpected costs.</li> <li>Avoid over-authorizing a single role in contract permissions. Instead, divide permissions reasonably and use multi-signature wallet management for roles with critical permissions to prevent permission loss due to private key compromise.</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/SC10-DenialOfService/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_DOS {\n    address public king;\n    uint256 public balance;\n    mapping(address =&gt; uint256) public pendingWithdrawals;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, \"Need to pay more to become the king\");\n\n        address previousKing = king;\n        uint256 previousBalance = balance;\n\n        // Update state first\n        king = msg.sender;\n        balance = msg.value;\n\n        // Pull-over-push: record pending withdrawal instead of pushing ETH.\n        // The previous king withdraws via withdraw() \u2014 no external call during claimThrone,\n        // so a malicious fallback cannot cause DoS.\n        if (previousKing != address(0)) {\n            pendingWithdrawals[previousKing] = previousBalance;\n        }\n    }\n\n    function withdraw() external {\n        uint256 amount = pendingWithdrawals[msg.sender];\n        require(amount &gt; 0, \"Nothing to withdraw\");\n        pendingWithdrawals[msg.sender] = 0;\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/","title":"Top10:2025","text":"","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#owasp-smart-contract-top-10-2025","title":"OWASP Smart Contract Top 10: 2025","text":"<p>The OWASP Smart Contract Top 10 (2025) is based on analysis of real-world incidents and research conducted during 2024, capturing the most critical risk categories affecting smart contracts.</p>","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#2025-ranking","title":"2025 Ranking","text":"<ul> <li>SC01:2025 - Access Control Vulnerabilities</li> <li>SC02:2025 - Price Oracle Manipulation</li> <li>SC03:2025 - Logic Errors</li> <li>SC04:2025 - Lack of Input Validation</li> <li>SC05:2025 - Reentrancy Attacks</li> <li>SC06:2025 - Unchecked External Calls</li> <li>SC07:2025 - Flash Loan Attacks</li> <li>SC08:2025 - Integer Overflow and Underflow</li> <li>SC09:2025 - Insecure Randomness</li> <li>SC10:2025 - Denial of Service (DoS) Attacks</li> </ul>","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#overview","title":"Overview","text":"Title Description SC01 - Access Control Vulnerabilities Access control flaws allow unauthorized users to access or modify a contract's data or functions. These vulnerabilities arise when the code fails to enforce proper permission checks, potentially leading to severe security breaches. SC02 - Price Oracle Manipulation Price Oracle Manipulation exploits vulnerabilities in how smart contracts fetch external data. By tampering with or controlling oracle feeds, attackers can affect contract logic, leading to financial losses or system instability. SC03 - Logic Errors Logic errors, or business logic vulnerabilities, occur when a contract's behavior deviates from its intended functionality. Examples include incorrect reward distribution, token minting issues, or flawed lending/borrowing logic. SC04 - Lack of Input Validation Insufficient input validation can lead to vulnerabilities where an attacker may manipulate the contract by providing harmful or unexpected inputs, potentially breaking logic or causing unexpected behaviors. SC05 - Reentrancy Attacks Reentrancy attacks exploit the ability to reenter a vulnerable function before its execution is complete. This can lead to repeated state changes, often resulting in drained contract funds or broken logic. SC06 - Unchecked External Calls Failing to verify the success of external function calls can result in unintended consequences. When a called contract fails, the calling contract may incorrectly proceed, risking integrity and functionality. SC07 - Flash Loan Attacks Flash loans, while useful, can be exploited to manipulate protocols by executing multiple actions in a single transaction. These attacks often result in drained liquidity, altered prices, or exploited business logic. SC08 - Integer Overflow and Underflow Arithmetic errors due to exceeding the limits of fixed-size integers can lead to serious vulnerabilities, such as incorrect calculations or token theft. Unsigned integers wrap around on underflow, while signed integers flip between extremes. SC09 - Insecure Randomness Due to the deterministic nature of blockchain networks, generating secure randomness is challenging. Predictable or manipulable randomness can lead to exploitation in lotteries, token distributions, or other randomness-dependent functionalities. SC10 - Denial of Service (DoS) Attacks DoS attacks exploit vulnerabilities to exhaust contract resources, rendering it non-functional. Examples include excessive gas consumption in loops or function calls designed to disrupt normal contract operation.","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#data-sources","title":"Data Sources","text":"","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#solidityscans-web3hackhub","title":"SolidityScan's Web3HackHub","text":"<p>To identify and validate the OWASP Smart Contract Top 10 vulnerabilities, we incorporated insights from multiple authoritative sources, with a notable focus on SolidityScan's Web3HackHub (2024). This resource provides a comprehensive database of blockchain-related incidents, offering valuable data on attack vectors, financial losses, and trends. </p> <p>Web3HackHub documents breaches from 2011 onward, enabling analysis of evolving attack methods, the increasing sophistication of exploits, and lessons learned from each incident.</p> <p>Key highlights from Web3HackHub for 2024 include:</p> <ul> <li>Total Financial Impact: $1.42 billion lost across 149 documented incidents in 2024.</li> <li>Top Attack Vectors (by frequency, total losses):<ul> <li>Access Control Vulnerabilities: $953.2M in losses.</li> <li>Logic Errors: $63.8M in losses.</li> <li>Reentrancy Attacks: $35.7M in losses.</li> <li>Flash Loan Attacks: $33.8M in losses.</li> <li>Lack of Input Validation: $14.6M in losses.</li> <li>Price Oracle Manipulation: $8.8M in losses. </li> <li>Unchecked External Calls: $550.7K in losses.</li> </ul> </li> </ul> <p></p>","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#other-sources","title":"Other Sources","text":"<p>In addition to SolidityScan's Web3HackHub, incorporating insights from Peter Kacherginsky's \"Top 10 DeFi Attack Vectors - 2024\" provides valuable data for creating the OWASP Smart Contract Top 10 for 2025. Peter's analysis is instrumental in understanding the evolving threat landscape and aligning the OWASP Smart Contract Top 10 with real-world observations.</p> <p>By integrating data from both SolidityScan's Web3HackHub and Kacherginsky's \"Top 10 DeFi Attack Vectors - 2024,\" we were able to provide a well-rounded justification for the 2025 rankings. </p>","tags":[]},{"location":"sctop10/archive/2025/Top10%3A2025/#licensing","title":"Licensing","text":"<p>The OWASP Smart Contract Top 10 (2025) is licensed under the CC BY-NC-SA 4.0, the Creative Commons Attribution-ShareAlike 4.0 license. Some rights reserved.</p>","tags":[]}]}